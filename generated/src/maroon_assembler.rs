// Generated by dsl::codegen from IR
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(non_snake_case)]

use crate::ir::FiberType;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct TestIncrementTask {
  pub inStrValue: u64,
  pub inStrRespFutureId: String,
  pub inStrRespQueueName: String,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct TestCreateQueueMessagePub {
  pub value: u64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct TestCreateQueueMessage {
  pub value: u64,
  pub publicFutureId: FutureU64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct TestCalculatorTask {
  pub a: u64,
  pub b: u64,
  pub responseFutureId: FutureU64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct TestInfiniteSummatorQueueMessagePub {
  pub a: u64,
  pub b: u64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct TestInfiniteSummatorQueueMessage {
  pub a: u64,
  pub b: u64,
  pub publicFutureId: FutureU64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct FutureTestIncrementTask(pub String);

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct FutureU64(pub String);

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct FutureUnit(pub String);

#[derive(Clone, Debug, Default)]
pub struct RootHeap {}

#[derive(Clone, Debug, Default)]
pub struct TestCalculatorHeap {
  pub in_vars: TestCalculatorInVars,
}

#[derive(Clone, Debug, Default)]
pub struct TestCalculatorInVars {
  pub calculationRequestsQueueName: String,
}

#[derive(Clone, Debug, Default)]
pub struct TestCreateQueueHeap {}

#[derive(Clone, Debug, Default)]
pub struct TestFunctionsCallHeap {
  pub binarySearchValues: Vec<u64>,
  pub in_vars: TestFunctionsCallInVars,
}

#[derive(Clone, Debug, Default)]
pub struct TestFunctionsCallInVars {
  pub binarySearchArray: Vec<u64>,
  pub binarySearchTarget: u64,
  pub factorialStart: u64,
  pub multa: u64,
  pub multb: u64,
}

#[derive(Clone, Debug, Default)]
pub struct TestInfiniteSummatorHeap {}

#[derive(Clone, Debug, Default)]
pub struct TestRootFiberHeap {}

#[derive(Clone, Debug, Default)]
pub struct TestRootFiberSleepTestHeap {}

#[derive(Clone, Debug, Default)]
pub struct TestSelectQueueHeap {}

#[derive(Clone, Debug, Default)]
pub struct TestTaskExecutorIncrementerHeap {
  pub in_vars: TestTaskExecutorIncrementerInVars,
}

#[derive(Clone, Debug, Default)]
pub struct TestTaskExecutorIncrementerInVars {
  pub inTaskqueuename: String,
}

#[derive(Clone, Debug, Default)]
pub struct Heap {
  pub root: RootHeap,
  pub testCalculator: TestCalculatorHeap,
  pub testCreateQueue: TestCreateQueueHeap,
  pub testFunctionsCall: TestFunctionsCallHeap,
  pub testInfiniteSummator: TestInfiniteSummatorHeap,
  pub testRootFiber: TestRootFiberHeap,
  pub testRootFiberSleepTest: TestRootFiberSleepTestHeap,
  pub testSelectQueue: TestSelectQueueHeap,
  pub testTaskExecutorIncrementer: TestTaskExecutorIncrementerHeap,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum State {
  Completed,
  Idle,
  RootMainEntry,
  RootMainReturn,
  TestCalculatorMainCalculate,
  TestCalculatorMainDebugGottenTask,
  TestCalculatorMainDebugVars,
  TestCalculatorMainEntry,
  TestCalculatorMainResponse,
  TestCalculatorMainReturn,
  TestCalculatorMainSelectQueue,
  TestCreateQueueMainAnswer,
  TestCreateQueueMainAwaitOnQueue,
  TestCreateQueueMainCleanUp,
  TestCreateQueueMainCorrectCreation,
  TestCreateQueueMainDebugVars,
  TestCreateQueueMainDebugVars2,
  TestCreateQueueMainDebugVars3,
  TestCreateQueueMainEntry,
  TestCreateQueueMainExtractFutAndInc,
  TestCreateQueueMainReturn,
  TestCreateQueueMainWrongQueueCreation,
  TestFunctionsCallBinarySearchCalculateDiv,
  TestFunctionsCallBinarySearchCmpLess,
  TestFunctionsCallBinarySearchEntry,
  TestFunctionsCallBinarySearchGoLeft,
  TestFunctionsCallBinarySearchGoLeftCheckOverflow,
  TestFunctionsCallBinarySearchGoRight,
  TestFunctionsCallBinarySearchRecursiveCall,
  TestFunctionsCallBinarySearchReturnNone,
  TestFunctionsCallBinarySearchReturnFound,
  TestFunctionsCallBinarySearchReturnIfEqual,
  TestFunctionsCallBinarySearchReturnResult,
  TestFunctionsCallFactorialEntry,
  TestFunctionsCallFactorialFactorialCall,
  TestFunctionsCallFactorialMultiply,
  TestFunctionsCallFactorialReturn,
  TestFunctionsCallFactorialReturn1,
  TestFunctionsCallFactorialSubtract,
  TestFunctionsCallMainAfterBinary,
  TestFunctionsCallMainAfterFactorial,
  TestFunctionsCallMainAfterMultiply,
  TestFunctionsCallMainBinarySearch,
  TestFunctionsCallMainEntry,
  TestFunctionsCallMainFactorial,
  TestFunctionsCallMainFinish,
  TestFunctionsCallMainMultiply,
  TestFunctionsCallMainSetBSearchValues,
  TestFunctionsCallMultEntry,
  TestFunctionsCallSubEntry,
  TestInfiniteSummatorMainCalculate,
  TestInfiniteSummatorMainCreateQueue,
  TestInfiniteSummatorMainEntry,
  TestInfiniteSummatorMainResponse,
  TestInfiniteSummatorMainReturn,
  TestInfiniteSummatorMainSelectQueue,
  TestRootFiberMainAwaitResponse,
  TestRootFiberMainAwaitResponse2,
  TestRootFiberMainCreateFiber,
  TestRootFiberMainCreateFuture,
  TestRootFiberMainCreateQueueues,
  TestRootFiberMainEntry,
  TestRootFiberMainPrepareCalculationRequests,
  TestRootFiberMainReturn,
  TestRootFiberMainReturnDbg,
  TestRootFiberMainSendCalculationRequest,
  TestRootFiberSleepTestMainCreatePrimitives,
  TestRootFiberSleepTestMainEntry,
  TestRootFiberSleepTestMainReturn,
  TestRootFiberSleepTestMainReturnDbg,
  TestRootFiberSleepTestMainSeelect,
  TestSelectQueueMainCompare,
  TestSelectQueueMainEntry,
  TestSelectQueueMainIncFromFut,
  TestSelectQueueMainInitFutureId,
  TestSelectQueueMainPrepareCond,
  TestSelectQueueMainReturn,
  TestSelectQueueMainSelectCounter,
  TestSelectQueueMainStartWork,
  TestTaskExecutorIncrementerMainAwait,
  TestTaskExecutorIncrementerMainDebug2,
  TestTaskExecutorIncrementerMainDebugVars,
  TestTaskExecutorIncrementerMainDebugVars2,
  TestTaskExecutorIncrementerMainEntry,
  TestTaskExecutorIncrementerMainIncrement,
  TestTaskExecutorIncrementerMainInitQueueName,
  TestTaskExecutorIncrementerMainReturn,
  TestTaskExecutorIncrementerMainReturnResult,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum Value {
  ArrayU64(Vec<u64>),
  Bool(bool),
  FutureTestIncrementTask(FutureTestIncrementTask),
  FutureU64(FutureU64),
  FutureUnit(FutureUnit),
  OptionString(Option<String>),
  OptionU64(Option<u64>),
  String(String),
  TestCalculatorTask(TestCalculatorTask),
  TestCreateQueueMessage(TestCreateQueueMessage),
  TestCreateQueueMessagePub(TestCreateQueueMessagePub),
  TestIncrementTask(TestIncrementTask),
  TestInfiniteSummatorQueueMessage(TestInfiniteSummatorQueueMessage),
  TestInfiniteSummatorQueueMessagePub(TestInfiniteSummatorQueueMessagePub),
  U64(u64),
  Unit(()),
}

pub fn pub_to_private(
  val: Value,
  future_id: String,
) -> Value {
  match val {
    Value::TestCreateQueueMessagePub(m) => {
      Value::TestCreateQueueMessage(TestCreateQueueMessage { value: m.value, publicFutureId: FutureU64(future_id) })
    }
    Value::TestInfiniteSummatorQueueMessagePub(m) => {
      Value::TestInfiniteSummatorQueueMessage(TestInfiniteSummatorQueueMessage {
        a: m.a,
        b: m.b,
        publicFutureId: FutureU64(future_id),
      })
    }
    _ => panic!("pub_to_private is only for PubQueueMessage values"),
  }
}

pub fn private_to_pub(val: Value) -> Value {
  match val {
    Value::TestCreateQueueMessage(m) => Value::TestCreateQueueMessagePub(TestCreateQueueMessagePub { value: m.value }),
    Value::TestInfiniteSummatorQueueMessage(m) => {
      Value::TestInfiniteSummatorQueueMessagePub(TestInfiniteSummatorQueueMessagePub { a: m.a, b: m.b })
    }
    _ => panic!("private_to_pub is only for PubQueueMessage values"),
  }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(String, Value),
  // In-place updates to the current frame (offset -> new Value)
  FrameAssign(Vec<(usize, Value)>),
}
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum FutureKind {
  FutureTestIncrementTask,
  FutureU64,
  FutureUnit,
}

pub fn wrap_future_id(
  kind: FutureKind,
  id: String,
) -> Value {
  match kind {
    FutureKind::FutureTestIncrementTask => Value::FutureTestIncrementTask(FutureTestIncrementTask(id)),
    FutureKind::FutureU64 => Value::FutureU64(FutureU64(id)),
    FutureKind::FutureUnit => Value::FutureUnit(FutureUnit(id)),
  }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum SuccessBindKind {
  String,
  Future(FutureKind),
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum SelectArm {
  FutureVar { future_id: String, bind: Option<String>, next: State },
  Queue { queue_name: String, bind: String, next: State },
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum CreatePrimitiveValue {
  Future,
  Queue { name: String, public: bool },
  // Create a scheduled timer future that resolves after `ms` milliseconds.
  // The created future is a Void future (Unit), i.e., it signals completion with no value.
  Schedule { ms: u64 },
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum SetPrimitiveValue {
  QueueMessage { queue_name: String, value: Value },
  Future { id: String, value: Value },
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  GoTo(State),
  Select(Vec<SelectArm>),
  // Atomically create runtime primitives and branch based on outcome.
  Create {
    primitives: Vec<CreatePrimitiveValue>,
    success_next: State,
    success_binds: Vec<String>,
    success_kinds: Vec<SuccessBindKind>,
    fail_next: State,
    fail_binds: Vec<String>,
  },
  // Return can carry an optional value to be consumed by the runtime.
  Return(Value),
  ReturnVoid,
  Todo(String),
  // Broadcast updates to async primitives (queues/futures) and continue to `next`.
  SetValues {
    values: Vec<SetPrimitiveValue>,
    next: State,
  },
  // Debug
  // Print a string message and continue to the provided next state.
  Debug(&'static str, State),
  // Print all current-frame vars in order and continue to next state.
  DebugPrintVars(State),
  // Spawn new fibers (fire-and-forget) and continue to `next`.
  // Runtime may ignore this for now; present for forward-compat.
  CreateFibers {
    details: Vec<(FiberType, Vec<Value>)>,
    next: State,
  },
}

pub fn func_args_count(e: &State) -> usize {
  match e {
    State::RootMainEntry => 0,
    State::RootMainReturn => 0,
    State::TestCalculatorMainEntry => 3,
    State::TestCalculatorMainCalculate => 3,
    State::TestCalculatorMainDebugGottenTask => 3,
    State::TestCalculatorMainDebugVars => 3,
    State::TestCalculatorMainResponse => 3,
    State::TestCalculatorMainReturn => 3,
    State::TestCalculatorMainSelectQueue => 3,
    State::TestCreateQueueMainEntry => 6,
    State::TestCreateQueueMainAnswer => 6,
    State::TestCreateQueueMainAwaitOnQueue => 6,
    State::TestCreateQueueMainCleanUp => 6,
    State::TestCreateQueueMainCorrectCreation => 6,
    State::TestCreateQueueMainDebugVars => 6,
    State::TestCreateQueueMainDebugVars2 => 6,
    State::TestCreateQueueMainDebugVars3 => 6,
    State::TestCreateQueueMainExtractFutAndInc => 6,
    State::TestCreateQueueMainReturn => 6,
    State::TestCreateQueueMainWrongQueueCreation => 6,
    State::TestFunctionsCallBinarySearchEntry => 6,
    State::TestFunctionsCallBinarySearchCalculateDiv => 6,
    State::TestFunctionsCallBinarySearchCmpLess => 6,
    State::TestFunctionsCallBinarySearchGoLeft => 6,
    State::TestFunctionsCallBinarySearchGoLeftCheckOverflow => 6,
    State::TestFunctionsCallBinarySearchGoRight => 6,
    State::TestFunctionsCallBinarySearchRecursiveCall => 6,
    State::TestFunctionsCallBinarySearchReturnNone => 6,
    State::TestFunctionsCallBinarySearchReturnFound => 6,
    State::TestFunctionsCallBinarySearchReturnIfEqual => 6,
    State::TestFunctionsCallBinarySearchReturnResult => 6,
    State::TestFunctionsCallFactorialEntry => 4,
    State::TestFunctionsCallFactorialFactorialCall => 4,
    State::TestFunctionsCallFactorialMultiply => 4,
    State::TestFunctionsCallFactorialReturn => 4,
    State::TestFunctionsCallFactorialReturn1 => 4,
    State::TestFunctionsCallFactorialSubtract => 4,
    State::TestFunctionsCallMainEntry => 5,
    State::TestFunctionsCallMainAfterBinary => 5,
    State::TestFunctionsCallMainAfterFactorial => 5,
    State::TestFunctionsCallMainAfterMultiply => 5,
    State::TestFunctionsCallMainBinarySearch => 5,
    State::TestFunctionsCallMainFactorial => 5,
    State::TestFunctionsCallMainFinish => 5,
    State::TestFunctionsCallMainMultiply => 5,
    State::TestFunctionsCallMainSetBSearchValues => 5,
    State::TestFunctionsCallMultEntry => 3,
    State::TestFunctionsCallSubEntry => 3,
    State::TestInfiniteSummatorMainEntry => 5,
    State::TestInfiniteSummatorMainCalculate => 5,
    State::TestInfiniteSummatorMainCreateQueue => 5,
    State::TestInfiniteSummatorMainResponse => 5,
    State::TestInfiniteSummatorMainReturn => 5,
    State::TestInfiniteSummatorMainSelectQueue => 5,
    State::TestRootFiberMainEntry => 10,
    State::TestRootFiberMainAwaitResponse => 10,
    State::TestRootFiberMainAwaitResponse2 => 10,
    State::TestRootFiberMainCreateFiber => 10,
    State::TestRootFiberMainCreateFuture => 10,
    State::TestRootFiberMainCreateQueueues => 10,
    State::TestRootFiberMainPrepareCalculationRequests => 10,
    State::TestRootFiberMainReturn => 10,
    State::TestRootFiberMainReturnDbg => 10,
    State::TestRootFiberMainSendCalculationRequest => 10,
    State::TestRootFiberSleepTestMainEntry => 3,
    State::TestRootFiberSleepTestMainCreatePrimitives => 3,
    State::TestRootFiberSleepTestMainReturn => 3,
    State::TestRootFiberSleepTestMainReturnDbg => 3,
    State::TestRootFiberSleepTestMainSeelect => 3,
    State::TestSelectQueueMainEntry => 5,
    State::TestSelectQueueMainCompare => 5,
    State::TestSelectQueueMainIncFromFut => 5,
    State::TestSelectQueueMainInitFutureId => 5,
    State::TestSelectQueueMainPrepareCond => 5,
    State::TestSelectQueueMainReturn => 5,
    State::TestSelectQueueMainSelectCounter => 5,
    State::TestSelectQueueMainStartWork => 5,
    State::TestTaskExecutorIncrementerMainEntry => 4,
    State::TestTaskExecutorIncrementerMainAwait => 4,
    State::TestTaskExecutorIncrementerMainDebug2 => 4,
    State::TestTaskExecutorIncrementerMainDebugVars => 4,
    State::TestTaskExecutorIncrementerMainDebugVars2 => 4,
    State::TestTaskExecutorIncrementerMainIncrement => 4,
    State::TestTaskExecutorIncrementerMainInitQueueName => 4,
    State::TestTaskExecutorIncrementerMainReturn => 4,
    State::TestTaskExecutorIncrementerMainReturnResult => 4,
    State::Idle => 0,
    State::Completed => 0,
  }
}
pub fn global_step(
  state: State,
  vars: &[StackEntry],
  heap: &mut Heap,
) -> StepResult {
  match state {
    State::Completed => StepResult::Done,
    State::Idle => panic!("shoudnt be here"),
    State::RootMainEntry => StepResult::CreateFibers {
      details: vec![(FiberType::new("testInfiniteSummator"), vec![])],
      next: State::RootMainReturn,
    },
    State::RootMainReturn => StepResult::ReturnVoid,
    State::TestCalculatorMainEntry => StepResult::DebugPrintVars(State::TestCalculatorMainSelectQueue),
    State::TestCalculatorMainCalculate => {
      let calculationRequestsQueueName: String = heap.testCalculator.in_vars.calculationRequestsQueueName.clone();
      let request: TestCalculatorTask =
        if let StackEntry::Value(_, Value::TestCalculatorTask(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let respFutureId: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      {
        let out = { (request.a * request.b, request.responseFutureId) };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(1, Value::U64(o0)), (2, Value::FutureU64(o1))]),
          StackEntry::State(State::TestCalculatorMainResponse),
        ])
      }
    }
    State::TestCalculatorMainDebugGottenTask => {
      StepResult::Debug("got task from the queue", State::TestCalculatorMainDebugVars)
    }
    State::TestCalculatorMainDebugVars => StepResult::DebugPrintVars(State::TestCalculatorMainCalculate),
    State::TestCalculatorMainResponse => {
      let respFutureId: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::SetValues {
        values: vec![SetPrimitiveValue::Future { id: respFutureId.0.clone(), value: Value::U64(result.clone()) }],
        next: State::TestCalculatorMainReturn,
      }
    }
    State::TestCalculatorMainReturn => StepResult::ReturnVoid,
    State::TestCalculatorMainSelectQueue => {
      let calculationRequestsQueueName: String = heap.testCalculator.in_vars.calculationRequestsQueueName.clone();
      StepResult::Select(vec![SelectArm::Queue {
        queue_name: calculationRequestsQueueName.clone(),
        bind: "request".to_string(),
        next: State::TestCalculatorMainDebugGottenTask,
      }])
    }
    State::TestCreateQueueMainEntry => StepResult::Next(vec![
      StackEntry::FrameAssign(vec![(1, Value::String("randomQueueName".to_string()))]),
      StackEntry::State(State::TestCreateQueueMainWrongQueueCreation),
    ]),
    State::TestCreateQueueMainAnswer => {
      let fFutureIdResponse: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fResInc: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::SetValues {
        values: vec![SetPrimitiveValue::Future { id: fFutureIdResponse.0.clone(), value: Value::U64(fResInc.clone()) }],
        next: State::TestCreateQueueMainReturn,
      }
    }
    State::TestCreateQueueMainAwaitOnQueue => {
      let createdQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Select(vec![SelectArm::Queue {
        queue_name: createdQueueName.clone(),
        bind: "value".to_string(),
        next: State::TestCreateQueueMainExtractFutAndInc,
      }])
    }
    State::TestCreateQueueMainCleanUp => {
      let createdQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let fFutureIdResponse: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fQueuecreationerror: Option<String> =
        if let StackEntry::Value(_, Value::OptionString(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let fQueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let fResInc: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      let value: TestCreateQueueMessage =
        if let StackEntry::Value(_, Value::TestCreateQueueMessage(x)) = &vars[0] { x.clone() } else { unreachable!() };
      {
        let out = { (String::new(), None) };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(2, Value::String(o0)), (3, Value::OptionString(o1))]),
          StackEntry::State(State::TestCreateQueueMainCorrectCreation),
        ])
      }
    }
    State::TestCreateQueueMainCorrectCreation => {
      let fQueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Create {
        primitives: vec![CreatePrimitiveValue::Queue {
          name: if let StackEntry::Value(_, Value::String(x)) = &vars[1] { x.clone() } else { unreachable!() },
          public: true,
        }],
        success_next: State::TestCreateQueueMainDebugVars2,
        success_binds: vec!["created_queue_name".to_string()],
        success_kinds: vec![SuccessBindKind::String],
        fail_next: State::TestCreateQueueMainReturn,
        fail_binds: vec!["f_queueCreationError".to_string()],
      }
    }
    State::TestCreateQueueMainDebugVars => StepResult::DebugPrintVars(State::TestCreateQueueMainCleanUp),
    State::TestCreateQueueMainDebugVars2 => StepResult::DebugPrintVars(State::TestCreateQueueMainAwaitOnQueue),
    State::TestCreateQueueMainDebugVars3 => StepResult::DebugPrintVars(State::TestCreateQueueMainAnswer),
    State::TestCreateQueueMainExtractFutAndInc => {
      let createdQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let fFutureIdResponse: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fQueuecreationerror: Option<String> =
        if let StackEntry::Value(_, Value::OptionString(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let fQueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let fResInc: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      let value: TestCreateQueueMessage =
        if let StackEntry::Value(_, Value::TestCreateQueueMessage(x)) = &vars[0] { x.clone() } else { unreachable!() };
      {
        let out = { (value.publicFutureId, value.value + 2) };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(4, Value::FutureU64(o0)), (5, Value::U64(o1))]),
          StackEntry::State(State::TestCreateQueueMainDebugVars3),
        ])
      }
    }
    State::TestCreateQueueMainReturn => StepResult::ReturnVoid,
    State::TestCreateQueueMainWrongQueueCreation => {
      let fQueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Create {
        primitives: vec![
          CreatePrimitiveValue::Queue {
            name: if let StackEntry::Value(_, Value::String(x)) = &vars[1] { x.clone() } else { unreachable!() },
            public: true,
          },
          CreatePrimitiveValue::Queue {
            name: if let StackEntry::Value(_, Value::String(x)) = &vars[1] { x.clone() } else { unreachable!() },
            public: true,
          },
        ],
        success_next: State::TestCreateQueueMainReturn,
        success_binds: vec!["created_queue_name".to_string(), "created_queue_name".to_string()],
        success_kinds: vec![SuccessBindKind::String, SuccessBindKind::String],
        fail_next: State::TestCreateQueueMainDebugVars,
        fail_binds: vec!["f_queueCreationError".to_string(), "f_queueCreationError".to_string()],
      }
    }
    State::TestFunctionsCallBinarySearchEntry => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      if left > right {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchReturnNone)
      } else {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchCalculateDiv)
      }
    }
    State::TestFunctionsCallBinarySearchCalculateDiv => {
      let binarySearchArray: Vec<u64> = heap.testFunctionsCall.in_vars.binarySearchArray.clone();
      let binarySearchTarget: u64 = heap.testFunctionsCall.in_vars.binarySearchTarget.clone();
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let facCallRes: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      let factorialStart: u64 = heap.testFunctionsCall.in_vars.factorialStart.clone();
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let multa: u64 = heap.testFunctionsCall.in_vars.multa.clone();
      let multb: u64 = heap.testFunctionsCall.in_vars.multb.clone();
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let vByIndexDiv: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      {
        let out = {
          let o_div = (left + right) / 2;
          let s = &heap.testFunctionsCall;
          (o_div, s.binarySearchValues[o_div as usize])
        };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(3, Value::U64(o0)), (4, Value::U64(o1))]),
          StackEntry::State(State::TestFunctionsCallBinarySearchReturnIfEqual),
        ])
      }
    }
    State::TestFunctionsCallBinarySearchCmpLess => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let vByIndexDiv: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      if vByIndexDiv < e {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchGoRight)
      } else {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchGoLeftCheckOverflow)
      }
    }
    State::TestFunctionsCallBinarySearchGoLeft => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallBinarySearchRecursiveCall),
        StackEntry::Retrn(Some(5)),
        StackEntry::Value("a".to_string(), Value::U64(div)),
        StackEntry::Value("b".to_string(), Value::U64(1u64)),
        StackEntry::Value("sub".to_string(), Value::U64(0u64)),
        StackEntry::State(State::TestFunctionsCallSubEntry),
      ])
    }
    State::TestFunctionsCallBinarySearchGoLeftCheckOverflow => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      if div < 0u64 {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchReturnNone)
      } else {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchGoLeft)
      }
    }
    State::TestFunctionsCallBinarySearchGoRight => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::GoTo(State::TestFunctionsCallBinarySearchRecursiveCall)
    }
    State::TestFunctionsCallBinarySearchRecursiveCall => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallBinarySearchReturnResult),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("e".to_string(), Value::U64(e)),
        StackEntry::Value("left".to_string(), Value::U64(left)),
        StackEntry::Value("right".to_string(), Value::U64(right)),
        StackEntry::Value("div".to_string(), Value::U64(0u64)),
        StackEntry::Value("v_by_index_div".to_string(), Value::U64(0u64)),
        StackEntry::Value("fac_call_res".to_string(), Value::OptionU64(None)),
        StackEntry::State(State::TestFunctionsCallBinarySearchEntry),
      ])
    }
    State::TestFunctionsCallBinarySearchReturnNone => StepResult::Return(Value::OptionU64(None)),
    State::TestFunctionsCallBinarySearchReturnFound => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::OptionU64(Some(div)))
    }
    State::TestFunctionsCallBinarySearchReturnIfEqual => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let vByIndexDiv: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      if vByIndexDiv == e {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchReturnFound)
      } else {
        StepResult::GoTo(State::TestFunctionsCallBinarySearchCmpLess)
      }
    }
    State::TestFunctionsCallBinarySearchReturnResult => {
      let facCallRes: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::OptionU64(facCallRes))
    }
    State::TestFunctionsCallFactorialEntry => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      if n == 1u64 {
        StepResult::GoTo(State::TestFunctionsCallFactorialReturn1)
      } else {
        StepResult::GoTo(State::TestFunctionsCallFactorialSubtract)
      }
    }
    State::TestFunctionsCallFactorialFactorialCall => {
      let subtractRes: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallFactorialMultiply),
        StackEntry::Retrn(Some(4)),
        StackEntry::Value("n".to_string(), Value::U64(subtractRes)),
        StackEntry::Value("fac_call_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("subtract_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("result".to_string(), Value::U64(0u64)),
        StackEntry::State(State::TestFunctionsCallFactorialEntry),
      ])
    }
    State::TestFunctionsCallFactorialMultiply => {
      let facCallRes: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallFactorialReturn),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("a".to_string(), Value::U64(n)),
        StackEntry::Value("b".to_string(), Value::U64(facCallRes)),
        StackEntry::Value("mult".to_string(), Value::U64(0u64)),
        StackEntry::State(State::TestFunctionsCallMultEntry),
      ])
    }
    State::TestFunctionsCallFactorialReturn => {
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(result))
    }
    State::TestFunctionsCallFactorialReturn1 => StepResult::Return(Value::U64(1u64)),
    State::TestFunctionsCallFactorialSubtract => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallFactorialFactorialCall),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value("a".to_string(), Value::U64(n)),
        StackEntry::Value("b".to_string(), Value::U64(1u64)),
        StackEntry::Value("sub".to_string(), Value::U64(0u64)),
        StackEntry::State(State::TestFunctionsCallSubEntry),
      ])
    }
    State::TestFunctionsCallMainEntry => StepResult::DebugPrintVars(State::TestFunctionsCallMainMultiply),
    State::TestFunctionsCallMainAfterBinary => StepResult::DebugPrintVars(State::TestFunctionsCallMainFinish),
    State::TestFunctionsCallMainAfterFactorial => {
      StepResult::DebugPrintVars(State::TestFunctionsCallMainSetBSearchValues)
    }
    State::TestFunctionsCallMainAfterMultiply => StepResult::DebugPrintVars(State::TestFunctionsCallMainFactorial),
    State::TestFunctionsCallMainBinarySearch => {
      let binarySearchLeft: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let binarySearchRight: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let binarySearchTarget: u64 = heap.testFunctionsCall.in_vars.binarySearchTarget.clone();
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallMainAfterBinary),
        StackEntry::Retrn(Some(4)),
        StackEntry::Value("e".to_string(), Value::U64(binarySearchTarget)),
        StackEntry::Value("left".to_string(), Value::U64(binarySearchLeft)),
        StackEntry::Value("right".to_string(), Value::U64(binarySearchRight)),
        StackEntry::Value("div".to_string(), Value::U64(0u64)),
        StackEntry::Value("v_by_index_div".to_string(), Value::U64(0u64)),
        StackEntry::Value("fac_call_res".to_string(), Value::OptionU64(None)),
        StackEntry::State(State::TestFunctionsCallBinarySearchEntry),
      ])
    }
    State::TestFunctionsCallMainFactorial => {
      let factorialStart: u64 = heap.testFunctionsCall.in_vars.factorialStart.clone();
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallMainAfterFactorial),
        StackEntry::Retrn(Some(5)),
        StackEntry::Value("n".to_string(), Value::U64(factorialStart)),
        StackEntry::Value("fac_call_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("subtract_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("result".to_string(), Value::U64(0u64)),
        StackEntry::State(State::TestFunctionsCallFactorialEntry),
      ])
    }
    State::TestFunctionsCallMainFinish => StepResult::ReturnVoid,
    State::TestFunctionsCallMainMultiply => {
      let multa: u64 = heap.testFunctionsCall.in_vars.multa.clone();
      let multb: u64 = heap.testFunctionsCall.in_vars.multb.clone();
      StepResult::Next(vec![
        StackEntry::State(State::TestFunctionsCallMainAfterMultiply),
        StackEntry::Retrn(Some(6)),
        StackEntry::Value("a".to_string(), Value::U64(multa)),
        StackEntry::Value("b".to_string(), Value::U64(multb)),
        StackEntry::Value("mult".to_string(), Value::U64(0u64)),
        StackEntry::State(State::TestFunctionsCallMultEntry),
      ])
    }
    State::TestFunctionsCallMainSetBSearchValues => {
      let binarySearchArray: Vec<u64> = heap.testFunctionsCall.in_vars.binarySearchArray.clone();
      let binarySearchLeft: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let binarySearchResult: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let binarySearchRight: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let binarySearchTarget: u64 = heap.testFunctionsCall.in_vars.binarySearchTarget.clone();
      let factorialResult: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let factorialStart: u64 = heap.testFunctionsCall.in_vars.factorialStart.clone();
      let multResult: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let multa: u64 = heap.testFunctionsCall.in_vars.multa.clone();
      let multb: u64 = heap.testFunctionsCall.in_vars.multb.clone();
      {
        let out = {
          heap.testFunctionsCall.binarySearchValues = binarySearchArray.clone();
          (0u64, (binarySearchArray.len() as u64) - 1)
        };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(3, Value::U64(o0)), (4, Value::U64(o1))]),
          StackEntry::State(State::TestFunctionsCallMainBinarySearch),
        ])
      }
    }
    State::TestFunctionsCallMultEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let binarySearchArray: Vec<u64> = heap.testFunctionsCall.in_vars.binarySearchArray.clone();
      let binarySearchTarget: u64 = heap.testFunctionsCall.in_vars.binarySearchTarget.clone();
      let factorialStart: u64 = heap.testFunctionsCall.in_vars.factorialStart.clone();
      let mult: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let multa: u64 = heap.testFunctionsCall.in_vars.multa.clone();
      let multb: u64 = heap.testFunctionsCall.in_vars.multb.clone();
      {
        let out = { a * b };
        StepResult::Return(Value::U64(out))
      }
    }
    State::TestFunctionsCallSubEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let binarySearchArray: Vec<u64> = heap.testFunctionsCall.in_vars.binarySearchArray.clone();
      let binarySearchTarget: u64 = heap.testFunctionsCall.in_vars.binarySearchTarget.clone();
      let factorialStart: u64 = heap.testFunctionsCall.in_vars.factorialStart.clone();
      let multa: u64 = heap.testFunctionsCall.in_vars.multa.clone();
      let multb: u64 = heap.testFunctionsCall.in_vars.multb.clone();
      let sub: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      {
        let out = {
          let out = a - b;
          out
        };
        StepResult::Return(Value::U64(out))
      }
    }
    State::TestInfiniteSummatorMainEntry => StepResult::Next(vec![
      StackEntry::FrameAssign(vec![(0, Value::String("testInfiniteCalculatorQueue".to_string()))]),
      StackEntry::State(State::TestInfiniteSummatorMainCreateQueue),
    ]),
    State::TestInfiniteSummatorMainCalculate => {
      let createQueueError: Option<String> =
        if let StackEntry::Value(_, Value::OptionString(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let infiniteCalculatorQueue: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let request: TestInfiniteSummatorQueueMessage =
        if let StackEntry::Value(_, Value::TestInfiniteSummatorQueueMessage(x)) = &vars[1] {
          x.clone()
        } else {
          unreachable!()
        };
      let respFutureId: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      {
        let out = { (request.a * request.b, request.publicFutureId) };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(2, Value::U64(o0)), (4, Value::FutureU64(o1))]),
          StackEntry::State(State::TestInfiniteSummatorMainResponse),
        ])
      }
    }
    State::TestInfiniteSummatorMainCreateQueue => {
      let infiniteCalculatorQueue: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Create {
        primitives: vec![CreatePrimitiveValue::Queue {
          name: if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() },
          public: true,
        }],
        success_next: State::TestInfiniteSummatorMainSelectQueue,
        success_binds: vec!["infiniteCalculatorQueue".to_string()],
        success_kinds: vec![SuccessBindKind::String],
        fail_next: State::TestInfiniteSummatorMainReturn,
        fail_binds: vec!["createQueueError".to_string()],
      }
    }
    State::TestInfiniteSummatorMainResponse => {
      let respFutureId: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::SetValues {
        values: vec![SetPrimitiveValue::Future { id: respFutureId.0.clone(), value: Value::U64(result.clone()) }],
        next: State::TestInfiniteSummatorMainSelectQueue,
      }
    }
    State::TestInfiniteSummatorMainReturn => StepResult::ReturnVoid,
    State::TestInfiniteSummatorMainSelectQueue => {
      let infiniteCalculatorQueue: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Select(vec![SelectArm::Queue {
        queue_name: infiniteCalculatorQueue.clone(),
        bind: "request".to_string(),
        next: State::TestInfiniteSummatorMainCalculate,
      }])
    }
    State::TestRootFiberMainEntry => StepResult::Next(vec![
      StackEntry::FrameAssign(vec![(0, Value::String("rootQueue".to_string()))]),
      StackEntry::State(State::TestRootFiberMainCreateQueueues),
    ]),
    State::TestRootFiberMainAwaitResponse => {
      let responseFutureId2: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      StepResult::Select(vec![SelectArm::FutureVar {
        future_id: responseFutureId2.0.clone(),
        bind: Some("responseFromCalculator".to_string()),
        next: State::TestRootFiberMainAwaitResponse2,
      }])
    }
    State::TestRootFiberMainAwaitResponse2 => {
      let responseFutureId: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Select(vec![SelectArm::FutureVar {
        future_id: responseFutureId.0.clone(),
        bind: Some("responseFromCalculator2".to_string()),
        next: State::TestRootFiberMainReturnDbg,
      }])
    }
    State::TestRootFiberMainCreateFiber => {
      let rootQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::CreateFibers {
        details: vec![
          (
            FiberType::new("testCalculator"),
            vec![Value::String(if let StackEntry::Value(_, Value::String(x)) = &vars[0] {
              x.clone()
            } else {
              unreachable!()
            })],
          ),
          (
            FiberType::new("testCalculator"),
            vec![Value::String(if let StackEntry::Value(_, Value::String(x)) = &vars[0] {
              x.clone()
            } else {
              unreachable!()
            })],
          ),
        ],
        next: State::TestRootFiberMainCreateFuture,
      }
    }
    State::TestRootFiberMainCreateFuture => StepResult::Create {
      primitives: vec![CreatePrimitiveValue::Future, CreatePrimitiveValue::Future],
      success_next: State::TestRootFiberMainPrepareCalculationRequests,
      success_binds: vec!["responseFutureId".to_string(), "responseFutureId2".to_string()],
      success_kinds: vec![
        SuccessBindKind::Future(FutureKind::FutureU64),
        SuccessBindKind::Future(FutureKind::FutureU64),
      ],
      fail_next: State::TestRootFiberMainReturnDbg,
      fail_binds: vec!["createFutureError".to_string(), "createFutureError2".to_string()],
    },
    State::TestRootFiberMainCreateQueueues => {
      let rootQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Create {
        primitives: vec![CreatePrimitiveValue::Queue {
          name: if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() },
          public: true,
        }],
        success_next: State::TestRootFiberMainCreateFiber,
        success_binds: vec!["rootQueueName".to_string()],
        success_kinds: vec![SuccessBindKind::String],
        fail_next: State::TestRootFiberMainReturnDbg,
        fail_binds: vec!["createQueueError".to_string()],
      }
    }
    State::TestRootFiberMainPrepareCalculationRequests => {
      let calculatorTask: TestCalculatorTask =
        if let StackEntry::Value(_, Value::TestCalculatorTask(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let calculatorTask2: TestCalculatorTask =
        if let StackEntry::Value(_, Value::TestCalculatorTask(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let createFutureError: Option<String> =
        if let StackEntry::Value(_, Value::OptionString(x)) = &vars[8] { x.clone() } else { unreachable!() };
      let createFutureError2: Option<String> =
        if let StackEntry::Value(_, Value::OptionString(x)) = &vars[9] { x.clone() } else { unreachable!() };
      let createQueueError: Option<String> =
        if let StackEntry::Value(_, Value::OptionString(x)) = &vars[7] { x.clone() } else { unreachable!() };
      let responseFromCalculator: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[5] { x.clone() } else { unreachable!() };
      let responseFromCalculator2: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[6] { x.clone() } else { unreachable!() };
      let responseFutureId: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let responseFutureId2: FutureU64 =
        if let StackEntry::Value(_, Value::FutureU64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let rootQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() };
      {
        let out = {
          (
            TestCalculatorTask { a: 10, b: 15, responseFutureId: responseFutureId },
            TestCalculatorTask { a: 2, b: 4, responseFutureId: responseFutureId2 },
          )
        };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(1, Value::TestCalculatorTask(o0)), (2, Value::TestCalculatorTask(o1))]),
          StackEntry::State(State::TestRootFiberMainSendCalculationRequest),
        ])
      }
    }
    State::TestRootFiberMainReturn => StepResult::ReturnVoid,
    State::TestRootFiberMainReturnDbg => StepResult::DebugPrintVars(State::TestRootFiberMainReturn),
    State::TestRootFiberMainSendCalculationRequest => {
      let calculatorTask: TestCalculatorTask =
        if let StackEntry::Value(_, Value::TestCalculatorTask(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let calculatorTask2: TestCalculatorTask =
        if let StackEntry::Value(_, Value::TestCalculatorTask(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let rootQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::SetValues {
        values: vec![
          SetPrimitiveValue::QueueMessage {
            queue_name: rootQueueName.clone(),
            value: Value::TestCalculatorTask(calculatorTask.clone()),
          },
          SetPrimitiveValue::QueueMessage {
            queue_name: rootQueueName.clone(),
            value: Value::TestCalculatorTask(calculatorTask2.clone()),
          },
        ],
        next: State::TestRootFiberMainAwaitResponse,
      }
    }
    State::TestRootFiberSleepTestMainEntry => StepResult::Next(vec![
      StackEntry::FrameAssign(vec![(2, Value::U64(150u64))]),
      StackEntry::State(State::TestRootFiberSleepTestMainCreatePrimitives),
    ]),
    State::TestRootFiberSleepTestMainCreatePrimitives => StepResult::Create {
      primitives: vec![CreatePrimitiveValue::Schedule {
        ms: if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() },
      }],
      success_next: State::TestRootFiberSleepTestMainSeelect,
      success_binds: vec!["scheduledFutId".to_string()],
      success_kinds: vec![SuccessBindKind::Future(FutureKind::FutureUnit)],
      fail_next: State::TestRootFiberSleepTestMainReturnDbg,
      fail_binds: vec!["createScheduleError".to_string()],
    },
    State::TestRootFiberSleepTestMainReturn => StepResult::ReturnVoid,
    State::TestRootFiberSleepTestMainReturnDbg => StepResult::DebugPrintVars(State::TestRootFiberSleepTestMainReturn),
    State::TestRootFiberSleepTestMainSeelect => {
      let scheduledFutId: FutureUnit =
        if let StackEntry::Value(_, Value::FutureUnit(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Select(vec![SelectArm::FutureVar {
        future_id: scheduledFutId.0.clone(),
        bind: None,
        next: State::TestRootFiberSleepTestMainReturnDbg,
      }])
    }
    State::TestSelectQueueMainEntry => StepResult::Next(vec![
      StackEntry::FrameAssign(vec![(2, Value::String("counterStartQueue".to_string()))]),
      StackEntry::State(State::TestSelectQueueMainInitFutureId),
    ]),
    State::TestSelectQueueMainCompare => {
      let isThree: bool = if let StackEntry::Value(_, Value::Bool(x)) = &vars[4] { x.clone() } else { unreachable!() };
      if isThree {
        StepResult::GoTo(State::TestSelectQueueMainReturn)
      } else {
        StepResult::GoTo(State::TestSelectQueueMainStartWork)
      }
    }
    State::TestSelectQueueMainIncFromFut => {
      let counter: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let counterStartQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let futureId: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let isThree: bool = if let StackEntry::Value(_, Value::Bool(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let responseFromFut: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      {
        let out = { responseFromFut - 1 };
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(0, Value::U64(out))]),
          StackEntry::State(State::TestSelectQueueMainPrepareCond),
        ])
      }
    }
    State::TestSelectQueueMainInitFutureId => StepResult::Next(vec![
      StackEntry::FrameAssign(vec![(3, Value::String("testSelectQueue_future_1".to_string()))]),
      StackEntry::State(State::TestSelectQueueMainSelectCounter),
    ]),
    State::TestSelectQueueMainPrepareCond => {
      let counter: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::FrameAssign(vec![(4, Value::Bool(counter == 3u64))]),
        StackEntry::State(State::TestSelectQueueMainCompare),
      ])
    }
    State::TestSelectQueueMainReturn => StepResult::ReturnVoid,
    State::TestSelectQueueMainSelectCounter => {
      let counterStartQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let futureId: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Select(vec![
        SelectArm::Queue {
          queue_name: counterStartQueueName.clone(),
          bind: "counter".to_string(),
          next: State::TestSelectQueueMainStartWork,
        },
        SelectArm::FutureVar {
          future_id: futureId.clone(),
          bind: Some("responseFromFut".to_string()),
          next: State::TestSelectQueueMainIncFromFut,
        },
      ])
    }
    State::TestSelectQueueMainStartWork => {
      let counter: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let counterStartQueueName: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let futureId: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let isThree: bool = if let StackEntry::Value(_, Value::Bool(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let responseFromFut: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      {
        let out = { counter + 1 };
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(0, Value::U64(out))]),
          StackEntry::State(State::TestSelectQueueMainPrepareCond),
        ])
      }
    }
    State::TestTaskExecutorIncrementerMainEntry => {
      StepResult::Debug("start function", State::TestTaskExecutorIncrementerMainInitQueueName)
    }
    State::TestTaskExecutorIncrementerMainAwait => {
      let fTasksqueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Select(vec![SelectArm::Queue {
        queue_name: fTasksqueuename.clone(),
        bind: "f_task".to_string(),
        next: State::TestTaskExecutorIncrementerMainIncrement,
      }])
    }
    State::TestTaskExecutorIncrementerMainDebug2 => {
      StepResult::Debug("after increment", State::TestTaskExecutorIncrementerMainDebugVars2)
    }
    State::TestTaskExecutorIncrementerMainDebugVars => {
      StepResult::DebugPrintVars(State::TestTaskExecutorIncrementerMainAwait)
    }
    State::TestTaskExecutorIncrementerMainDebugVars2 => {
      StepResult::DebugPrintVars(State::TestTaskExecutorIncrementerMainReturnResult)
    }
    State::TestTaskExecutorIncrementerMainIncrement => {
      let fRespfutureid: FutureTestIncrementTask =
        if let StackEntry::Value(_, Value::FutureTestIncrementTask(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let fRespqueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let fTask: TestIncrementTask =
        if let StackEntry::Value(_, Value::TestIncrementTask(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fTasksqueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let inTaskqueuename: String = heap.testTaskExecutorIncrementer.in_vars.inTaskqueuename.clone();
      {
        let out = {
          let mut t_m = fTask;
          t_m.inStrValue += 1;
          (t_m.clone(), t_m.inStrRespQueueName, FutureTestIncrementTask(t_m.inStrRespFutureId))
        };
        let (o0, o1, o2) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![
            (0, Value::TestIncrementTask(o0)),
            (2, Value::String(o1)),
            (1, Value::FutureTestIncrementTask(o2)),
          ]),
          StackEntry::State(State::TestTaskExecutorIncrementerMainDebug2),
        ])
      }
    }
    State::TestTaskExecutorIncrementerMainInitQueueName => {
      let fRespfutureid: FutureTestIncrementTask =
        if let StackEntry::Value(_, Value::FutureTestIncrementTask(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let fRespqueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let fTask: TestIncrementTask =
        if let StackEntry::Value(_, Value::TestIncrementTask(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fTasksqueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let inTaskqueuename: String = heap.testTaskExecutorIncrementer.in_vars.inTaskqueuename.clone();
      {
        let out = { heap.testTaskExecutorIncrementer.in_vars.inTaskqueuename.clone() };
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(3, Value::String(out))]),
          StackEntry::State(State::TestTaskExecutorIncrementerMainDebugVars),
        ])
      }
    }
    State::TestTaskExecutorIncrementerMainReturn => StepResult::ReturnVoid,
    State::TestTaskExecutorIncrementerMainReturnResult => {
      let fRespfutureid: FutureTestIncrementTask =
        if let StackEntry::Value(_, Value::FutureTestIncrementTask(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let fRespqueuename: String =
        if let StackEntry::Value(_, Value::String(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let fTask: TestIncrementTask =
        if let StackEntry::Value(_, Value::TestIncrementTask(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::SetValues {
        values: vec![
          SetPrimitiveValue::Future { id: fRespfutureid.0.clone(), value: Value::TestIncrementTask(fTask.clone()) },
          SetPrimitiveValue::QueueMessage {
            queue_name: fRespqueuename.clone(),
            value: Value::TestIncrementTask(fTask.clone()),
          },
        ],
        next: State::TestTaskExecutorIncrementerMainReturn,
      }
    }
    _ => StepResult::Todo("uncovered-state".to_string()),
  }
}

// Registry: function key -> (prepare_from_values, result_to_value)
pub type PrepareFn = fn(Vec<Value>) -> Vec<StackEntry>;
pub type ResultFn = fn(&[StackEntry]) -> Value;

pub fn root_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::State(State::RootMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn root_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn root_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = root_prepare_main();
  stack
}

fn root_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(root_result_main(stack))
}

pub fn testCalculator_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("request".to_string(), Value::TestCalculatorTask(TestCalculatorTask::default())));
  stack.push(StackEntry::Value("result".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("respFutureId".to_string(), Value::FutureU64(FutureU64::default())));
  stack.push(StackEntry::State(State::TestCalculatorMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testCalculator_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testCalculator_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testCalculator_prepare_main();
  stack
}

fn testCalculator_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testCalculator_result_main(stack))
}

pub fn testCreateQueue_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("value".to_string(), Value::TestCreateQueueMessage(TestCreateQueueMessage::default())));
  stack.push(StackEntry::Value("f_queueName".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("created_queue_name".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("f_queueCreationError".to_string(), Value::OptionString(None)));
  stack.push(StackEntry::Value("f_future_id_response".to_string(), Value::FutureU64(FutureU64::default())));
  stack.push(StackEntry::Value("f_res_inc".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::TestCreateQueueMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testCreateQueue_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testCreateQueue_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testCreateQueue_prepare_main();
  stack
}

fn testCreateQueue_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testCreateQueue_result_main(stack))
}

pub fn testFunctionsCall_prepare_binarySearch(
  e: u64,
  left: u64,
  right: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("e".to_string(), Value::U64(e)));
  stack.push(StackEntry::Value("left".to_string(), Value::U64(left)));
  stack.push(StackEntry::Value("right".to_string(), Value::U64(right)));
  stack.push(StackEntry::Value("div".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("v_by_index_div".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("fac_call_res".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::State(State::TestFunctionsCallBinarySearchEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testFunctionsCall_result_binarySearch(stack: &[StackEntry]) -> Option<u64> {
  match stack.last() {
    Some(StackEntry::Value(_, Value::OptionU64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn testFunctionsCall_prepare_binarySearch_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let e: u64 = if let Value::U64(x) = &args[0] {
    x.clone()
  } else {
    unreachable!("invalid args for testFunctionsCall.binary_search")
  };
  let left: u64 = if let Value::U64(x) = &args[1] {
    x.clone()
  } else {
    unreachable!("invalid args for testFunctionsCall.binary_search")
  };
  let right: u64 = if let Value::U64(x) = &args[2] {
    x.clone()
  } else {
    unreachable!("invalid args for testFunctionsCall.binary_search")
  };
  let (stack, _heap) = testFunctionsCall_prepare_binarySearch(e, left, right);
  stack
}

fn testFunctionsCall_result_binarySearch_value(stack: &[StackEntry]) -> Value {
  Value::OptionU64(testFunctionsCall_result_binarySearch(stack))
}

pub fn testFunctionsCall_prepare_factorial(n: u64) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("n".to_string(), Value::U64(n)));
  stack.push(StackEntry::Value("fac_call_res".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("subtract_res".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("result".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::TestFunctionsCallFactorialEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testFunctionsCall_result_factorial(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn testFunctionsCall_prepare_factorial_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let n: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for testFunctionsCall.factorial") };
  let (stack, _heap) = testFunctionsCall_prepare_factorial(n);
  stack
}

fn testFunctionsCall_result_factorial_value(stack: &[StackEntry]) -> Value {
  Value::U64(testFunctionsCall_result_factorial(stack))
}

pub fn testFunctionsCall_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("multResult".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("factorialResult".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("binarySearchResult".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::Value("binarySearchLeft".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("binarySearchRight".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::TestFunctionsCallMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testFunctionsCall_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testFunctionsCall_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testFunctionsCall_prepare_main();
  stack
}

fn testFunctionsCall_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testFunctionsCall_result_main(stack))
}

pub fn testFunctionsCall_prepare_mult(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("mult".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::TestFunctionsCallMultEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testFunctionsCall_result_mult(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn testFunctionsCall_prepare_mult_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for testFunctionsCall.mult") };
  let b: u64 =
    if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for testFunctionsCall.mult") };
  let (stack, _heap) = testFunctionsCall_prepare_mult(a, b);
  stack
}

fn testFunctionsCall_result_mult_value(stack: &[StackEntry]) -> Value {
  Value::U64(testFunctionsCall_result_mult(stack))
}

pub fn testFunctionsCall_prepare_sub(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("sub".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::TestFunctionsCallSubEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testFunctionsCall_result_sub(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn testFunctionsCall_prepare_sub_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for testFunctionsCall.sub") };
  let b: u64 =
    if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for testFunctionsCall.sub") };
  let (stack, _heap) = testFunctionsCall_prepare_sub(a, b);
  stack
}

fn testFunctionsCall_result_sub_value(stack: &[StackEntry]) -> Value {
  Value::U64(testFunctionsCall_result_sub(stack))
}

pub fn testInfiniteSummator_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("infiniteCalculatorQueue".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value(
    "request".to_string(),
    Value::TestInfiniteSummatorQueueMessage(TestInfiniteSummatorQueueMessage::default()),
  ));
  stack.push(StackEntry::Value("result".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("createQueueError".to_string(), Value::OptionString(None)));
  stack.push(StackEntry::Value("respFutureId".to_string(), Value::FutureU64(FutureU64::default())));
  stack.push(StackEntry::State(State::TestInfiniteSummatorMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testInfiniteSummator_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testInfiniteSummator_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testInfiniteSummator_prepare_main();
  stack
}

fn testInfiniteSummator_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testInfiniteSummator_result_main(stack))
}

pub fn testRootFiber_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("rootQueueName".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("calculatorTask".to_string(), Value::TestCalculatorTask(TestCalculatorTask::default())));
  stack
    .push(StackEntry::Value("calculatorTask2".to_string(), Value::TestCalculatorTask(TestCalculatorTask::default())));
  stack.push(StackEntry::Value("responseFutureId".to_string(), Value::FutureU64(FutureU64::default())));
  stack.push(StackEntry::Value("responseFutureId2".to_string(), Value::FutureU64(FutureU64::default())));
  stack.push(StackEntry::Value("responseFromCalculator".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("responseFromCalculator2".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("createQueueError".to_string(), Value::OptionString(None)));
  stack.push(StackEntry::Value("createFutureError".to_string(), Value::OptionString(None)));
  stack.push(StackEntry::Value("createFutureError2".to_string(), Value::OptionString(None)));
  stack.push(StackEntry::State(State::TestRootFiberMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testRootFiber_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testRootFiber_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testRootFiber_prepare_main();
  stack
}

fn testRootFiber_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testRootFiber_result_main(stack))
}

pub fn testRootFiberSleepTest_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("scheduledFutId".to_string(), Value::FutureUnit(FutureUnit::default())));
  stack.push(StackEntry::Value("createScheduleError".to_string(), Value::OptionString(None)));
  stack.push(StackEntry::Value("await_milliseconds".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::TestRootFiberSleepTestMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testRootFiberSleepTest_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testRootFiberSleepTest_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testRootFiberSleepTest_prepare_main();
  stack
}

fn testRootFiberSleepTest_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testRootFiberSleepTest_result_main(stack))
}

pub fn testSelectQueue_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("counter".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("responseFromFut".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("counterStartQueueName".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("futureId".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("isThree".to_string(), Value::Bool(false)));
  stack.push(StackEntry::State(State::TestSelectQueueMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testSelectQueue_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testSelectQueue_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testSelectQueue_prepare_main();
  stack
}

fn testSelectQueue_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testSelectQueue_result_main(stack))
}

pub fn testTaskExecutorIncrementer_prepare_main() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("f_task".to_string(), Value::TestIncrementTask(TestIncrementTask::default())));
  stack.push(StackEntry::Value(
    "f_respFutureId".to_string(),
    Value::FutureTestIncrementTask(FutureTestIncrementTask::default()),
  ));
  stack.push(StackEntry::Value("f_respQueueName".to_string(), Value::String(String::new())));
  stack.push(StackEntry::Value("f_tasksQueueName".to_string(), Value::String(String::new())));
  stack.push(StackEntry::State(State::TestTaskExecutorIncrementerMainEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn testTaskExecutorIncrementer_result_main(stack: &[StackEntry]) -> () {
  let _ = stack;
  ()
}

fn testTaskExecutorIncrementer_prepare_main_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = testTaskExecutorIncrementer_prepare_main();
  stack
}

fn testTaskExecutorIncrementer_result_main_value(stack: &[StackEntry]) -> Value {
  Value::Unit(testTaskExecutorIncrementer_result_main(stack))
}

pub fn get_prepare_fn(key: &str) -> PrepareFn {
  match key {
    "root.main" => root_prepare_main_from_values,
    "testCalculator.main" => testCalculator_prepare_main_from_values,
    "testCreateQueue.main" => testCreateQueue_prepare_main_from_values,
    "testFunctionsCall.binary_search" => testFunctionsCall_prepare_binarySearch_from_values,
    "testFunctionsCall.factorial" => testFunctionsCall_prepare_factorial_from_values,
    "testFunctionsCall.main" => testFunctionsCall_prepare_main_from_values,
    "testFunctionsCall.mult" => testFunctionsCall_prepare_mult_from_values,
    "testFunctionsCall.sub" => testFunctionsCall_prepare_sub_from_values,
    "testInfiniteSummator.main" => testInfiniteSummator_prepare_main_from_values,
    "testRootFiber.main" => testRootFiber_prepare_main_from_values,
    "testRootFiberSleepTest.main" => testRootFiberSleepTest_prepare_main_from_values,
    "testSelectQueue.main" => testSelectQueue_prepare_main_from_values,
    "testTaskExecutorIncrementer.main" => testTaskExecutorIncrementer_prepare_main_from_values,
    _ => panic!("shouldnt be here"),
  }
}

pub type HeapInitFn = fn(Vec<Value>) -> Heap;

pub fn root_prepare_heap() -> Heap {
  let mut heap = Heap::default();
  heap
}

fn root_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  root_prepare_heap()
}

pub fn testCalculator_prepare_heap(calculationRequestsQueueName: String) -> Heap {
  let mut heap = Heap::default();
  heap.testCalculator.in_vars.calculationRequestsQueueName = calculationRequestsQueueName;
  heap
}

fn testCalculator_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  let calculationRequestsQueueName: String =
    if let Some(Value::String(x)) = args.get(0) { x.clone() } else { String::new() };
  testCalculator_prepare_heap(calculationRequestsQueueName)
}

pub fn testCreateQueue_prepare_heap() -> Heap {
  let mut heap = Heap::default();
  heap
}

fn testCreateQueue_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  testCreateQueue_prepare_heap()
}

pub fn testFunctionsCall_prepare_heap(
  multa: u64,
  multb: u64,
  factorialStart: u64,
  binarySearchArray: Vec<u64>,
  binarySearchTarget: u64,
) -> Heap {
  let mut heap = Heap::default();
  heap.testFunctionsCall.in_vars.multa = multa;
  heap.testFunctionsCall.in_vars.multb = multb;
  heap.testFunctionsCall.in_vars.factorialStart = factorialStart;
  heap.testFunctionsCall.in_vars.binarySearchArray = binarySearchArray;
  heap.testFunctionsCall.in_vars.binarySearchTarget = binarySearchTarget;
  heap
}

fn testFunctionsCall_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  let multa: u64 = if let Some(Value::U64(x)) = args.get(0) { x.clone() } else { 0u64 };
  let multb: u64 = if let Some(Value::U64(x)) = args.get(1) { x.clone() } else { 0u64 };
  let factorialStart: u64 = if let Some(Value::U64(x)) = args.get(2) { x.clone() } else { 0u64 };
  let binarySearchArray: Vec<u64> =
    if let Some(Value::ArrayU64(x)) = args.get(3) { x.clone() } else { Vec::<u64>::new() };
  let binarySearchTarget: u64 = if let Some(Value::U64(x)) = args.get(4) { x.clone() } else { 0u64 };
  testFunctionsCall_prepare_heap(multa, multb, factorialStart, binarySearchArray, binarySearchTarget)
}

pub fn testInfiniteSummator_prepare_heap() -> Heap {
  let mut heap = Heap::default();
  heap
}

fn testInfiniteSummator_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  testInfiniteSummator_prepare_heap()
}

pub fn testRootFiber_prepare_heap() -> Heap {
  let mut heap = Heap::default();
  heap
}

fn testRootFiber_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  testRootFiber_prepare_heap()
}

pub fn testRootFiberSleepTest_prepare_heap() -> Heap {
  let mut heap = Heap::default();
  heap
}

fn testRootFiberSleepTest_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  testRootFiberSleepTest_prepare_heap()
}

pub fn testSelectQueue_prepare_heap() -> Heap {
  let mut heap = Heap::default();
  heap
}

fn testSelectQueue_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  testSelectQueue_prepare_heap()
}

pub fn testTaskExecutorIncrementer_prepare_heap(inTaskqueuename: String) -> Heap {
  let mut heap = Heap::default();
  heap.testTaskExecutorIncrementer.in_vars.inTaskqueuename = inTaskqueuename;
  heap
}

fn testTaskExecutorIncrementer_prepare_heap_from_values(args: Vec<Value>) -> Heap {
  let inTaskqueuename: String = if let Some(Value::String(x)) = args.get(0) { x.clone() } else { String::new() };
  testTaskExecutorIncrementer_prepare_heap(inTaskqueuename)
}

pub fn get_heap_init_fn(fiber: &FiberType) -> HeapInitFn {
  match fiber.0.as_str() {
    "root" => root_prepare_heap_from_values,
    "testCalculator" => testCalculator_prepare_heap_from_values,
    "testCreateQueue" => testCreateQueue_prepare_heap_from_values,
    "testFunctionsCall" => testFunctionsCall_prepare_heap_from_values,
    "testInfiniteSummator" => testInfiniteSummator_prepare_heap_from_values,
    "testRootFiber" => testRootFiber_prepare_heap_from_values,
    "testRootFiberSleepTest" => testRootFiberSleepTest_prepare_heap_from_values,
    "testSelectQueue" => testSelectQueue_prepare_heap_from_values,
    "testTaskExecutorIncrementer" => testTaskExecutorIncrementer_prepare_heap_from_values,
    _ => |_| Heap::default(),
  }
}
