// Generated by dsl::codegen from IR
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(non_snake_case)]

use crate::ir::{FiberType, FutureLabel};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct Order {
  pub id: u64,
  pub price: u64,
  pub qty: u64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct Trade {
  pub maker_id: u64,
  pub price: u64,
  pub qty: u64,
  pub taker_id: u64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct OrderIndex {
  pub price: u64,
  pub side: String,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct Level {
  pub price: u64,
  pub qty: u64,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct BookSnapshot {
  pub asks: Vec<Level>,
  pub bids: Vec<Level>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ApplicationAsyncFooMsg {
  pub a: u64,
  pub b: u64,
}

#[derive(Clone, Debug, Default)]
pub struct ApplicationHeap {}

#[derive(Clone, Debug, Default)]
pub struct GlobalHeap {
  pub binary_search_values: Vec<u64>,
}

#[derive(Clone, Debug, Default)]
pub struct OrderBookHeap {
  pub asks_by_price: std::collections::HashMap<u64, Vec<Order>>,
  pub asks_prices: std::collections::BinaryHeap<std::cmp::Reverse<u64>>,
  pub bids_by_price: std::collections::HashMap<u64, Vec<Order>>,
  pub bids_prices: std::collections::BinaryHeap<u64>,
  pub orders_index: std::collections::HashMap<u64, OrderIndex>,
}

#[derive(Clone, Debug, Default)]
pub struct Heap {
  pub application: ApplicationHeap,
  pub global: GlobalHeap,
  pub order_book: OrderBookHeap,
}

#[derive(Clone, Debug, PartialEq)]
pub enum State {
  Completed,
  Idle,
  ApplicationAsyncFooAwait,
  ApplicationAsyncFooEntry,
  ApplicationAsyncFooReturn,
  ApplicationSleepAndPowAwait,
  ApplicationSleepAndPowCalc,
  ApplicationSleepAndPowEntry,
  GlobalAddEntry,
  GlobalBinarySearchCalculateDiv,
  GlobalBinarySearchCmpLess,
  GlobalBinarySearchEntry,
  GlobalBinarySearchGoLeft,
  GlobalBinarySearchGoLeftCheckOverflow,
  GlobalBinarySearchGoRight,
  GlobalBinarySearchRecursiveCall,
  GlobalBinarySearchReturnFound,
  GlobalBinarySearchReturnIfEqual,
  GlobalBinarySearchReturnNone,
  GlobalBinarySearchReturnResult,
  GlobalDivEntry,
  GlobalFactorialEntry,
  GlobalFactorialFactorialCall,
  GlobalFactorialMultiply,
  GlobalFactorialReturn,
  GlobalFactorialReturn1,
  GlobalFactorialSubtract,
  GlobalMultEntry,
  GlobalSubAddEntry,
  GlobalSubAddFinalize,
  GlobalSubAddSubSum,
  GlobalSubEntry,
  OrderBookAddBuyEntry,
  OrderBookAddSellEntry,
  OrderBookBestAskEntry,
  OrderBookBestBidEntry,
  OrderBookCancelEntry,
  OrderBookTopNDepthEntry,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum Value {
  ArrayTrade(Vec<Trade>),
  BookSnapshot(BookSnapshot),
  OptionU64(Option<u64>),
  U64(u64),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(String, Value),
  // In-place updates to the current frame (offset -> new Value)
  FrameAssign(Vec<(usize, Value)>),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  ScheduleTimer { ms: u64, next: State, future_id: FutureLabel },
  GoTo(State),
  Select(Vec<State>),
  // Return can carry an optional value to be consumed by the runtime.
  Return(Value),
  ReturnVoid,
  Todo(String),
  // Await a future: (future_id, optional bind_var, next_state)
  Await(FutureLabel, Option<String>, State),
  // Send a message to a fiber with function and typed args, then continue to `next`.
  SendToFiber { f_type: FiberType, func: String, args: Vec<Value>, next: State, future_id: FutureLabel },
}
pub fn func_args_count(e: &State) -> usize {
  match e {
    State::ApplicationAsyncFooAwait => 3,
    State::ApplicationAsyncFooEntry => 3,
    State::ApplicationAsyncFooReturn => 3,
    State::ApplicationSleepAndPowAwait => 3,
    State::ApplicationSleepAndPowCalc => 3,
    State::ApplicationSleepAndPowEntry => 3,
    State::GlobalAddEntry => 3,
    State::GlobalBinarySearchCalculateDiv => 6,
    State::GlobalBinarySearchCmpLess => 6,
    State::GlobalBinarySearchEntry => 6,
    State::GlobalBinarySearchGoLeft => 6,
    State::GlobalBinarySearchGoLeftCheckOverflow => 6,
    State::GlobalBinarySearchGoRight => 6,
    State::GlobalBinarySearchRecursiveCall => 6,
    State::GlobalBinarySearchReturnFound => 6,
    State::GlobalBinarySearchReturnIfEqual => 6,
    State::GlobalBinarySearchReturnNone => 6,
    State::GlobalBinarySearchReturnResult => 6,
    State::GlobalDivEntry => 3,
    State::GlobalFactorialEntry => 4,
    State::GlobalFactorialFactorialCall => 4,
    State::GlobalFactorialMultiply => 4,
    State::GlobalFactorialReturn => 4,
    State::GlobalFactorialReturn1 => 4,
    State::GlobalFactorialSubtract => 4,
    State::GlobalMultEntry => 3,
    State::GlobalSubAddEntry => 5,
    State::GlobalSubAddFinalize => 5,
    State::GlobalSubAddSubSum => 5,
    State::GlobalSubEntry => 3,
    State::OrderBookAddBuyEntry => 4,
    State::OrderBookAddSellEntry => 4,
    State::OrderBookBestAskEntry => 1,
    State::OrderBookBestBidEntry => 1,
    State::OrderBookCancelEntry => 2,
    State::OrderBookTopNDepthEntry => 2,
    State::Idle => 0,
    State::Completed => 0,
  }
}
pub fn global_step(
  state: State,
  vars: &[StackEntry],
  heap: &mut Heap,
) -> StepResult {
  match state {
    State::Completed => StepResult::Done,
    State::Idle => panic!("shoudnt be here"),
    State::ApplicationAsyncFooEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let sum: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::SendToFiber {
        f_type: FiberType::new("global"),
        func: "add".to_string(),
        args: vec![Value::U64(a), Value::U64(b)],
        next: State::ApplicationAsyncFooAwait,
        future_id: FutureLabel::new("async_add_future_1"),
      }
    }
    State::ApplicationAsyncFooAwait => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let sum: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Await(
        FutureLabel::new("async_add_future_1"),
        Some("sum".to_string()),
        State::ApplicationAsyncFooReturn,
      )
    }
    State::ApplicationAsyncFooReturn => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let sum: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(sum))
    }
    State::ApplicationSleepAndPowEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let pow: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::ScheduleTimer {
        ms: 20u64,
        next: State::ApplicationSleepAndPowAwait,
        future_id: FutureLabel::new("sleep_and_pow_entry_future"),
      }
    }
    State::ApplicationSleepAndPowAwait => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let pow: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Await(FutureLabel::new("sleep_and_pow_entry_future"), None, State::ApplicationSleepAndPowCalc)
    }
    State::ApplicationSleepAndPowCalc => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let pow: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      {
        let out = { a.pow(b as u32) };
        StepResult::Return(Value::U64(out))
      }
    }
    State::GlobalAddEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let sum: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      {
        let out = { a + b };
        StepResult::Return(Value::U64(out))
      }
    }
    State::GlobalBinarySearchEntry => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      if (left > right) {
        StepResult::GoTo(State::GlobalBinarySearchReturnNone)
      } else {
        StepResult::GoTo(State::GlobalBinarySearchCalculateDiv)
      }
    }
    State::GlobalBinarySearchReturnNone => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::OptionU64(None))
    }
    State::GlobalBinarySearchCalculateDiv => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      {
        let out = {
          let o_div = (left + right) / 2;
          let s = &heap.global;
          (o_div, s.binary_search_values[o_div as usize])
        };
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![(3, Value::U64(o0)), (4, Value::U64(o1))]),
          StackEntry::State(State::GlobalBinarySearchReturnIfEqual),
        ])
      }
    }
    State::GlobalBinarySearchReturnIfEqual => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      if (v_by_index_div == e) {
        StepResult::GoTo(State::GlobalBinarySearchReturnFound)
      } else {
        StepResult::GoTo(State::GlobalBinarySearchCmpLess)
      }
    }
    State::GlobalBinarySearchReturnFound => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::OptionU64(Some(div)))
    }
    State::GlobalBinarySearchCmpLess => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      if (v_by_index_div < e) {
        StepResult::GoTo(State::GlobalBinarySearchGoRight)
      } else {
        StepResult::GoTo(State::GlobalBinarySearchGoLeftCheckOverflow)
      }
    }
    State::GlobalBinarySearchGoRight => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalBinarySearchRecursiveCall),
        StackEntry::Retrn(Some(6)),
        StackEntry::Value("_".to_string(), Value::U64(div)),
        StackEntry::Value("_".to_string(), Value::U64(1u64)),
        StackEntry::Value("sum".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalAddEntry),
      ])
    }
    State::GlobalBinarySearchGoLeftCheckOverflow => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      if (div < 0u64) {
        StepResult::GoTo(State::GlobalBinarySearchReturnNone)
      } else {
        StepResult::GoTo(State::GlobalBinarySearchGoLeft)
      }
    }
    State::GlobalBinarySearchGoLeft => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalBinarySearchRecursiveCall),
        StackEntry::Retrn(Some(5)),
        StackEntry::Value("_".to_string(), Value::U64(div)),
        StackEntry::Value("_".to_string(), Value::U64(1u64)),
        StackEntry::Value("sub".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
    State::GlobalBinarySearchRecursiveCall => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalBinarySearchReturnResult),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("_".to_string(), Value::U64(e)),
        StackEntry::Value("_".to_string(), Value::U64(left)),
        StackEntry::Value("_".to_string(), Value::U64(right)),
        StackEntry::Value("div".to_string(), Value::U64(0u64)),
        StackEntry::Value("v_by_index_div".to_string(), Value::U64(0u64)),
        StackEntry::Value("fac_call_res".to_string(), Value::OptionU64(None)),
        StackEntry::State(State::GlobalBinarySearchEntry),
      ])
    }
    State::GlobalBinarySearchReturnResult => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let v_by_index_div: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      let fac_call_res: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::OptionU64(fac_call_res))
    }
    State::GlobalDivEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      {
        let out = { a / b };
        StepResult::Return(Value::U64(out))
      }
    }
    State::GlobalFactorialEntry => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fac_call_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let subtract_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      if (n == 1u64) {
        StepResult::GoTo(State::GlobalFactorialReturn1)
      } else {
        StepResult::GoTo(State::GlobalFactorialSubtract)
      }
    }
    State::GlobalFactorialReturn1 => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fac_call_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let subtract_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(1u64))
    }
    State::GlobalFactorialSubtract => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fac_call_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let subtract_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialFactorialCall),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value("_".to_string(), Value::U64(n)),
        StackEntry::Value("_".to_string(), Value::U64(1u64)),
        StackEntry::Value("sub".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
    State::GlobalFactorialFactorialCall => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fac_call_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let subtract_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialMultiply),
        StackEntry::Retrn(Some(4)),
        StackEntry::Value("_".to_string(), Value::U64(subtract_res)),
        StackEntry::Value("fac_call_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("subtract_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("result".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalFactorialEntry),
      ])
    }
    State::GlobalFactorialMultiply => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fac_call_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let subtract_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialReturn),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("_".to_string(), Value::U64(n)),
        StackEntry::Value("_".to_string(), Value::U64(fac_call_res)),
        StackEntry::Value("mult".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalMultEntry),
      ])
    }
    State::GlobalFactorialReturn => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let fac_call_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let subtract_res: u64 =
        if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(result))
    }
    State::GlobalMultEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let mult: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      {
        let out = { a * b };
        StepResult::Return(Value::U64(out))
      }
    }
    State::GlobalSubEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let sub: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      {
        let out = {
          let out = a - b;
          out
        };
        StepResult::Return(Value::U64(out))
      }
    }
    State::GlobalSubAddEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let c: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let sumAB: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let subABC: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddSubSum),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value("_".to_string(), Value::U64(a)),
        StackEntry::Value("_".to_string(), Value::U64(b)),
        StackEntry::Value("sum".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalAddEntry),
      ])
    }
    State::GlobalSubAddSubSum => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let c: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let sumAB: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let subABC: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddFinalize),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("_".to_string(), Value::U64(sumAB)),
        StackEntry::Value("_".to_string(), Value::U64(c)),
        StackEntry::Value("sub".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
    State::GlobalSubAddFinalize => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let c: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let sumAB: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      let subABC: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(subABC))
    }
    State::OrderBookAddBuyEntry => {
      let id: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let price: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let qty: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: Vec<Trade> =
        if let StackEntry::Value(_, Value::ArrayTrade(x)) = &vars[3] { x.clone() } else { unreachable!() };
      {
        let out = {
          let ob = &mut heap.order_book;
          let mut remaining = qty;
          let mut trades: Vec<Trade> = Vec::new();

          // Clean stale top asks and match while price allows
          loop {
            // Find current best ask
            let best_ask = loop {
              if let Some(top) = ob.asks_prices.peek() {
                let p = top.0;
                if let Some(level) = ob.asks_by_price.get(&p) {
                  if !level.is_empty() {
                    break Some(p);
                  }
                }
                // stale level
                ob.asks_prices.pop();
                continue;
              } else {
                break None;
              }
            };

            match best_ask {
              Some(ap) if ap <= price && remaining > 0 => {
                // Execute against this level FIFO
                if let Some(level) = ob.asks_by_price.get_mut(&ap) {
                  while remaining > 0 && !level.is_empty() {
                    let maker = &mut level[0];
                    if maker.qty <= remaining {
                      let trade_qty = maker.qty;
                      remaining -= trade_qty;
                      trades.push(Trade { price: ap, qty: trade_qty, taker_id: id, maker_id: maker.id });
                      level.remove(0);
                    } else {
                      maker.qty -= remaining;
                      trades.push(Trade { price: ap, qty: remaining, taker_id: id, maker_id: maker.id });
                      remaining = 0;
                    }
                  }
                  if level.is_empty() {
                    ob.asks_by_price.remove(&ap);
                  }
                }
                // continue loop to next level or exit if remaining==0
              }
              _ => break,
            }
          }

          // If remaining, add to bids book
          if remaining > 0 {
            ob.bids_by_price.entry(price).or_default().push(Order { id, price, qty: remaining });
            ob.bids_prices.push(price);
            ob.orders_index.insert(id, OrderIndex { side: "buy".to_string(), price });
          }

          trades
        };
        StepResult::Return(Value::ArrayTrade(out))
      }
    }
    State::OrderBookAddSellEntry => {
      let id: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let price: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let qty: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let result: Vec<Trade> =
        if let StackEntry::Value(_, Value::ArrayTrade(x)) = &vars[3] { x.clone() } else { unreachable!() };
      {
        let out = {
          let ob = &mut heap.order_book;
          let mut remaining = qty;
          let mut trades: Vec<Trade> = Vec::new();

          // Clean stale top bids and match while price allows
          loop {
            // Find current best bid
            let best_bid = loop {
              if let Some(&bp) = ob.bids_prices.peek() {
                if let Some(level) = ob.bids_by_price.get(&bp) {
                  if !level.is_empty() {
                    break Some(bp);
                  }
                }
                // stale
                ob.bids_prices.pop();
                continue;
              } else {
                break None;
              }
            };

            match best_bid {
              Some(bp) if bp >= price && remaining > 0 => {
                if let Some(level) = ob.bids_by_price.get_mut(&bp) {
                  while remaining > 0 && !level.is_empty() {
                    let maker = &mut level[0];
                    if maker.qty <= remaining {
                      let trade_qty = maker.qty;
                      remaining -= trade_qty;
                      trades.push(Trade { price: bp, qty: trade_qty, taker_id: id, maker_id: maker.id });
                      level.remove(0);
                    } else {
                      maker.qty -= remaining;
                      trades.push(Trade { price: bp, qty: remaining, taker_id: id, maker_id: maker.id });
                      remaining = 0;
                    }
                  }
                  if level.is_empty() {
                    ob.bids_by_price.remove(&bp);
                  }
                }
              }
              _ => break,
            }
          }

          if remaining > 0 {
            ob.asks_by_price.entry(price).or_default().push(Order { id, price, qty: remaining });
            ob.asks_prices.push(std::cmp::Reverse(price));
            ob.orders_index.insert(id, OrderIndex { side: "sell".to_string(), price });
          }

          trades
        };
        StepResult::Return(Value::ArrayTrade(out))
      }
    }
    State::OrderBookBestAskEntry => {
      let result: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      {
        let out = {
          let ob = &mut heap.order_book;
          loop {
            if let Some(top) = ob.asks_prices.peek() {
              let ap = top.0; // Reverse(u64)
              if let Some(level) = ob.asks_by_price.get(&ap) {
                if !level.is_empty() {
                  break Some(ap);
                }
              }
              ob.asks_prices.pop();
            } else {
              break None;
            }
          }
        };
        StepResult::Return(Value::OptionU64(out))
      }
    }
    State::OrderBookBestBidEntry => {
      let result: Option<u64> =
        if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      {
        let out = {
          let ob = &mut heap.order_book;
          loop {
            if let Some(&bp) = ob.bids_prices.peek() {
              if let Some(level) = ob.bids_by_price.get(&bp) {
                if !level.is_empty() {
                  break Some(bp);
                }
              }
              ob.bids_prices.pop();
            } else {
              break None;
            }
          }
        };
        StepResult::Return(Value::OptionU64(out))
      }
    }
    State::OrderBookCancelEntry => {
      let id: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      {
        let out = {
          let ob = &mut heap.order_book;
          let mut ok = 0u64;
          if let Some(idx) = ob.orders_index.remove(&id) {
            let price = idx.price;
            if idx.side == "buy" {
              if let Some(level) = ob.bids_by_price.get_mut(&price) {
                if let Some(pos) = level.iter().position(|o| o.id == id) {
                  level.remove(pos);
                  ok = 1;
                  if level.is_empty() {
                    ob.bids_by_price.remove(&price);
                  }
                }
              }
            } else {
              if let Some(level) = ob.asks_by_price.get_mut(&price) {
                if let Some(pos) = level.iter().position(|o| o.id == id) {
                  level.remove(pos);
                  ok = 1;
                  if level.is_empty() {
                    ob.asks_by_price.remove(&price);
                  }
                }
              }
            }
          }
          ok
        };
        StepResult::Return(Value::U64(out))
      }
    }
    State::OrderBookTopNDepthEntry => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let result: BookSnapshot =
        if let StackEntry::Value(_, Value::BookSnapshot(x)) = &vars[1] { x.clone() } else { unreachable!() };
      {
        let out = {
          let ob = &mut heap.order_book;

          let mut bids_depth: Vec<Level> = Vec::new();
          let mut asks_depth: Vec<Level> = Vec::new();

          // Bids: highest first
          {
            let mut tmp = ob.bids_prices.clone();
            let mut seen = std::collections::HashSet::<u64>::new();
            while (bids_depth.len() as u64) < n {
              if let Some(bp) = tmp.pop() {
                if seen.contains(&bp) {
                  continue;
                }
                if let Some(level) = ob.bids_by_price.get(&bp) {
                  if !level.is_empty() {
                    let qty = level.iter().map(|o| o.qty).sum::<u64>();
                    bids_depth.push(Level { price: bp, qty });
                    seen.insert(bp);
                  }
                }
              } else {
                break;
              }
            }
          }

          // Asks: lowest first
          {
            let mut tmp = ob.asks_prices.clone();
            let mut seen = std::collections::HashSet::<u64>::new();
            while (asks_depth.len() as u64) < n {
              if let Some(std::cmp::Reverse(ap)) = tmp.pop() {
                if seen.contains(&ap) {
                  continue;
                }
                if let Some(level) = ob.asks_by_price.get(&ap) {
                  if !level.is_empty() {
                    let qty = level.iter().map(|o| o.qty).sum::<u64>();
                    asks_depth.push(Level { price: ap, qty });
                    seen.insert(ap);
                  }
                }
              } else {
                break;
              }
            }
          }

          BookSnapshot { bids: bids_depth, asks: asks_depth }
        };
        StepResult::Return(Value::BookSnapshot(out))
      }
    }
  }
}
// Registry: function key -> (prepare_from_values, result_to_value)
pub type PrepareFn = fn(Vec<Value>) -> Vec<StackEntry>;
pub type ResultFn = fn(&[StackEntry]) -> Value;

pub fn application_prepare_AsyncFoo(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("sum".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::ApplicationAsyncFooEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn application_result_AsyncFoo(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn application_prepare_AsyncFoo_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for application.async_foo") };
  let b: u64 =
    if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for application.async_foo") };
  let (stack, _heap) = application_prepare_AsyncFoo(a, b);
  stack
}

fn application_result_AsyncFoo_value(stack: &[StackEntry]) -> Value {
  Value::U64(application_result_AsyncFoo(stack))
}

pub fn application_prepare_SleepAndPow(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("pow".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::ApplicationSleepAndPowEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn application_result_SleepAndPow(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn application_prepare_SleepAndPow_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for application.sleep_and_pow") };
  let b: u64 =
    if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for application.sleep_and_pow") };
  let (stack, _heap) = application_prepare_SleepAndPow(a, b);
  stack
}

fn application_result_SleepAndPow_value(stack: &[StackEntry]) -> Value {
  Value::U64(application_result_SleepAndPow(stack))
}

pub fn global_prepare_Add(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("sum".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::GlobalAddEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn global_result_Add(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn global_prepare_Add_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 = if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for global.add") };
  let b: u64 = if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for global.add") };
  let (stack, _heap) = global_prepare_Add(a, b);
  stack
}

fn global_result_Add_value(stack: &[StackEntry]) -> Value {
  Value::U64(global_result_Add(stack))
}

pub fn global_prepare_BinarySearch(
  e: u64,
  left: u64,
  right: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("e".to_string(), Value::U64(e)));
  stack.push(StackEntry::Value("left".to_string(), Value::U64(left)));
  stack.push(StackEntry::Value("right".to_string(), Value::U64(right)));
  stack.push(StackEntry::Value("div".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("v_by_index_div".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("fac_call_res".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::State(State::GlobalBinarySearchEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn global_result_BinarySearch(stack: &[StackEntry]) -> Option<u64> {
  match stack.last() {
    Some(StackEntry::Value(_, Value::OptionU64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn global_prepare_BinarySearch_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let e: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for global.binary_search") };
  let left: u64 =
    if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for global.binary_search") };
  let right: u64 =
    if let Value::U64(x) = &args[2] { x.clone() } else { unreachable!("invalid args for global.binary_search") };
  let (stack, _heap) = global_prepare_BinarySearch(e, left, right);
  stack
}

fn global_result_BinarySearch_value(stack: &[StackEntry]) -> Value {
  Value::OptionU64(global_result_BinarySearch(stack))
}

pub fn global_prepare_Div(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("div".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::GlobalDivEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn global_result_Div(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn global_prepare_Div_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 = if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for global.div") };
  let b: u64 = if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for global.div") };
  let (stack, _heap) = global_prepare_Div(a, b);
  stack
}

fn global_result_Div_value(stack: &[StackEntry]) -> Value {
  Value::U64(global_result_Div(stack))
}

pub fn global_prepare_Factorial(n: u64) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("n".to_string(), Value::U64(n)));
  stack.push(StackEntry::Value("fac_call_res".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("subtract_res".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("result".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::GlobalFactorialEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn global_result_Factorial(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn global_prepare_Factorial_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let n: u64 = if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for global.factorial") };
  let (stack, _heap) = global_prepare_Factorial(n);
  stack
}

fn global_result_Factorial_value(stack: &[StackEntry]) -> Value {
  Value::U64(global_result_Factorial(stack))
}

pub fn global_prepare_Mult(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("mult".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::GlobalMultEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn global_result_Mult(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn global_prepare_Mult_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 = if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for global.mult") };
  let b: u64 = if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for global.mult") };
  let (stack, _heap) = global_prepare_Mult(a, b);
  stack
}

fn global_result_Mult_value(stack: &[StackEntry]) -> Value {
  Value::U64(global_result_Mult(stack))
}

pub fn global_prepare_Sub(
  a: u64,
  b: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("sub".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::GlobalSubEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn global_result_Sub(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn global_prepare_Sub_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 = if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for global.sub") };
  let b: u64 = if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for global.sub") };
  let (stack, _heap) = global_prepare_Sub(a, b);
  stack
}

fn global_result_Sub_value(stack: &[StackEntry]) -> Value {
  Value::U64(global_result_Sub(stack))
}

pub fn global_prepare_SubAdd(
  a: u64,
  b: u64,
  c: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("a".to_string(), Value::U64(a)));
  stack.push(StackEntry::Value("b".to_string(), Value::U64(b)));
  stack.push(StackEntry::Value("c".to_string(), Value::U64(c)));
  stack.push(StackEntry::Value("sumAB".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Value("subABC".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::GlobalSubAddEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn global_result_SubAdd(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn global_prepare_SubAdd_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let a: u64 = if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for global.subAdd") };
  let b: u64 = if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for global.subAdd") };
  let c: u64 = if let Value::U64(x) = &args[2] { x.clone() } else { unreachable!("invalid args for global.subAdd") };
  let (stack, _heap) = global_prepare_SubAdd(a, b, c);
  stack
}

fn global_result_SubAdd_value(stack: &[StackEntry]) -> Value {
  Value::U64(global_result_SubAdd(stack))
}

pub fn orderBook_prepare_AddBuy(
  id: u64,
  price: u64,
  qty: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::ArrayTrade(vec![])));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("id".to_string(), Value::U64(id)));
  stack.push(StackEntry::Value("price".to_string(), Value::U64(price)));
  stack.push(StackEntry::Value("qty".to_string(), Value::U64(qty)));
  stack.push(StackEntry::Value("result".to_string(), Value::ArrayTrade(vec![])));
  stack.push(StackEntry::State(State::OrderBookAddBuyEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn orderBook_result_AddBuy(stack: &[StackEntry]) -> Vec<Trade> {
  match stack.last() {
    Some(StackEntry::Value(_, Value::ArrayTrade(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn orderBook_prepare_AddBuy_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let id: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for order_book.add_buy") };
  let price: u64 =
    if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for order_book.add_buy") };
  let qty: u64 =
    if let Value::U64(x) = &args[2] { x.clone() } else { unreachable!("invalid args for order_book.add_buy") };
  let (stack, _heap) = orderBook_prepare_AddBuy(id, price, qty);
  stack
}

fn orderBook_result_AddBuy_value(stack: &[StackEntry]) -> Value {
  Value::ArrayTrade(orderBook_result_AddBuy(stack))
}

pub fn orderBook_prepare_AddSell(
  id: u64,
  price: u64,
  qty: u64,
) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::ArrayTrade(vec![])));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("id".to_string(), Value::U64(id)));
  stack.push(StackEntry::Value("price".to_string(), Value::U64(price)));
  stack.push(StackEntry::Value("qty".to_string(), Value::U64(qty)));
  stack.push(StackEntry::Value("result".to_string(), Value::ArrayTrade(vec![])));
  stack.push(StackEntry::State(State::OrderBookAddSellEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn orderBook_result_AddSell(stack: &[StackEntry]) -> Vec<Trade> {
  match stack.last() {
    Some(StackEntry::Value(_, Value::ArrayTrade(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn orderBook_prepare_AddSell_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let id: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for order_book.add_sell") };
  let price: u64 =
    if let Value::U64(x) = &args[1] { x.clone() } else { unreachable!("invalid args for order_book.add_sell") };
  let qty: u64 =
    if let Value::U64(x) = &args[2] { x.clone() } else { unreachable!("invalid args for order_book.add_sell") };
  let (stack, _heap) = orderBook_prepare_AddSell(id, price, qty);
  stack
}

fn orderBook_result_AddSell_value(stack: &[StackEntry]) -> Value {
  Value::ArrayTrade(orderBook_result_AddSell(stack))
}

pub fn orderBook_prepare_BestAsk() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("result".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::State(State::OrderBookBestAskEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn orderBook_result_BestAsk(stack: &[StackEntry]) -> Option<u64> {
  match stack.last() {
    Some(StackEntry::Value(_, Value::OptionU64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn orderBook_prepare_BestAsk_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = orderBook_prepare_BestAsk();
  stack
}

fn orderBook_result_BestAsk_value(stack: &[StackEntry]) -> Value {
  Value::OptionU64(orderBook_result_BestAsk(stack))
}

pub fn orderBook_prepare_BestBid() -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("result".to_string(), Value::OptionU64(None)));
  stack.push(StackEntry::State(State::OrderBookBestBidEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn orderBook_result_BestBid(stack: &[StackEntry]) -> Option<u64> {
  match stack.last() {
    Some(StackEntry::Value(_, Value::OptionU64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn orderBook_prepare_BestBid_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let (stack, _heap) = orderBook_prepare_BestBid();
  stack
}

fn orderBook_result_BestBid_value(stack: &[StackEntry]) -> Value {
  Value::OptionU64(orderBook_result_BestBid(stack))
}

pub fn orderBook_prepare_Cancel(id: u64) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("id".to_string(), Value::U64(id)));
  stack.push(StackEntry::Value("result".to_string(), Value::U64(0u64)));
  stack.push(StackEntry::State(State::OrderBookCancelEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn orderBook_result_Cancel(stack: &[StackEntry]) -> u64 {
  match stack.last() {
    Some(StackEntry::Value(_, Value::U64(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn orderBook_prepare_Cancel_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let id: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for order_book.cancel") };
  let (stack, _heap) = orderBook_prepare_Cancel(id);
  stack
}

fn orderBook_result_Cancel_value(stack: &[StackEntry]) -> Value {
  Value::U64(orderBook_result_Cancel(stack))
}

pub fn orderBook_prepare_TopNDepth(n: u64) -> (Vec<StackEntry>, Heap) {
  let mut stack: Vec<StackEntry> = Vec::new();
  stack.push(StackEntry::Value("ret".to_string(), Value::BookSnapshot(BookSnapshot::default())));
  stack.push(StackEntry::Retrn(Some(1)));
  stack.push(StackEntry::Value("n".to_string(), Value::U64(n)));
  stack.push(StackEntry::Value("result".to_string(), Value::BookSnapshot(BookSnapshot::default())));
  stack.push(StackEntry::State(State::OrderBookTopNDepthEntry));
  let heap = Heap::default();
  (stack, heap)
}

pub fn orderBook_result_TopNDepth(stack: &[StackEntry]) -> BookSnapshot {
  match stack.last() {
    Some(StackEntry::Value(_, Value::BookSnapshot(v))) => v.clone(),
    _ => unreachable!("result not found on stack"),
  }
}

fn orderBook_prepare_TopNDepth_from_values(args: Vec<Value>) -> Vec<StackEntry> {
  let n: u64 =
    if let Value::U64(x) = &args[0] { x.clone() } else { unreachable!("invalid args for order_book.top_n_depth") };
  let (stack, _heap) = orderBook_prepare_TopNDepth(n);
  stack
}

fn orderBook_result_TopNDepth_value(stack: &[StackEntry]) -> Value {
  Value::BookSnapshot(orderBook_result_TopNDepth(stack))
}

pub fn get_prepare_fn(key: &str) -> PrepareFn {
  match key {
    "application.async_foo" => application_prepare_AsyncFoo_from_values,
    "application.sleep_and_pow" => application_prepare_SleepAndPow_from_values,
    "global.add" => global_prepare_Add_from_values,
    "global.binary_search" => global_prepare_BinarySearch_from_values,
    "global.div" => global_prepare_Div_from_values,
    "global.factorial" => global_prepare_Factorial_from_values,
    "global.mult" => global_prepare_Mult_from_values,
    "global.sub" => global_prepare_Sub_from_values,
    "global.subAdd" => global_prepare_SubAdd_from_values,
    "order_book.add_buy" => orderBook_prepare_AddBuy_from_values,
    "order_book.add_sell" => orderBook_prepare_AddSell_from_values,
    "order_book.best_ask" => orderBook_prepare_BestAsk_from_values,
    "order_book.best_bid" => orderBook_prepare_BestBid_from_values,
    "order_book.cancel" => orderBook_prepare_Cancel_from_values,
    "order_book.top_n_depth" => orderBook_prepare_TopNDepth_from_values,
    _ => panic!("shouldnt be here"),
  }
}

pub fn get_result_fn(key: &str) -> ResultFn {
  match key {
    "application.async_foo" => application_result_AsyncFoo_value,
    "application.sleep_and_pow" => application_result_SleepAndPow_value,
    "global.add" => global_result_Add_value,
    "global.binary_search" => global_result_BinarySearch_value,
    "global.div" => global_result_Div_value,
    "global.factorial" => global_result_Factorial_value,
    "global.mult" => global_result_Mult_value,
    "global.sub" => global_result_Sub_value,
    "global.subAdd" => global_result_SubAdd_value,
    "order_book.add_buy" => orderBook_result_AddBuy_value,
    "order_book.add_sell" => orderBook_result_AddSell_value,
    "order_book.best_ask" => orderBook_result_BestAsk_value,
    "order_book.best_bid" => orderBook_result_BestBid_value,
    "order_book.cancel" => orderBook_result_Cancel_value,
    "order_book.top_n_depth" => orderBook_result_TopNDepth_value,
    _ => panic!("shouldnt be here"),
  }
}
