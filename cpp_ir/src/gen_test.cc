// NOTE(dkorolev): This is suboptimal, but it ensures the code builds just with `g++ src.cc`, w/o `-std=c++17`.
#define CURRENT_FOR_CPP14

#include <iostream>
#include <fstream>

#include "../current/bricks/dflags/dflags.h"
#include "../current/bricks/file/file.h"
#include "../current/typesystem/serialization/json.h"

#include "ir.h"

DEFINE_string(in, "", "The input file to parse the JSON of the IR from.");
DEFINE_string(name, "default", "The name to use for the autogenerated tests.");
DEFINE_string(out, "/dev/stdout", "The output file to dump the C++ code into.");

inline void GenerateTestCase(std::ostream& fo, MaroonTestCase const& test, std::string const& name, size_t idx) {
  if (idx == 1) {
    fo << "TEST(Maroon, " << name << ") {" << std::endl;
  } else {
    fo << "TEST(Maroon, " << name << "_" << idx << ") {" << std::endl;
  }
  struct GenerateTestCaseVisitor final {
    std::string const& name;
    std::ostream& fo;
    GenerateTestCaseVisitor(std::string const& name, std::ostream& fo) : name(name), fo(fo) {}
    void operator()(MaroonTestCaseRunFiber const& test) {
      fo << "  MaroonEngine<MAROON_NAMESPACE_" << test.maroon << "::MAROON_spec, MAROON_NAMESPACE_" << test.maroon
         << "::" << test.fiber << "> engine;" << std::endl;
      fo << "  auto const output_error = engine.run();" << std::endl;
      std::ostringstream oss;
      for (auto const& e : test.golden_output) {
        oss << e << std::endl;
      }
      fo << "  EXPECT_EQ(R\"\"\"(" << oss.str() << ")\"\"\", output_error.first);" << std::endl;
      fo << "  EXPECT_EQ(\"\", output_error.second);" << std::endl;
    }
    void operator()(MaroonTestCaseFiberShouldThrow const& test) {
      fo << "  MaroonEngine<MAROON_NAMESPACE_" << test.maroon << "::MAROON_spec, MAROON_NAMESPACE_" << test.maroon
         << "::" << test.fiber << "> engine;" << std::endl;
      fo << "  auto const output_error = engine.run();" << std::endl;
      fo << "  EXPECT_EQ(R\"\"\"(" << test.error << ")\"\"\", output_error.second);" << std::endl;
      fo << "  EXPECT_EQ(\"\", output_error.first);" << std::endl;
    }
  };
  GenerateTestCaseVisitor visitor(name, fo);
  test.Call(visitor);
  fo << '}' << std::endl;
}

constexpr static char const* const kVarsFunctionSignature = "(ImplEnv& MAROON_env)";
constexpr static char const* const kStepFunctionSignature = "(ImplEnv& MAROON_env, ImplResultCollector& MAROON_result)";

int main(int argc, char** argv) {
  ParseDFlags(&argc, &argv);

  if (FLAGS_in.empty()) {
    std::cerr << "The `--in` parameter is required." << std::endl;
    std::exit(1);
  }

  std::ofstream fo(FLAGS_out);

  MaroonIRScenarios scenarios;
  try {
    using T = decltype(scenarios);
    scenarios = ParseJSON<T, JSONFormat::Minimalistic>(current::FileSystem::ReadFileAsString(FLAGS_in));
  } catch (current::Exception const&) {
    std::cerr << "Failed to read and parse the IR JSON from `" << FLAGS_in << "`." << std::endl;
    std::exit(1);
  }

  fo << "#pragma once" << std::endl;
  fo << std::endl;
  fo << "#define CURRENT_FOR_CPP14" << std::endl;
  fo << std::endl;
  fo << "#include \"../src/engine.h\"" << std::endl;

  for (auto const& iter : scenarios.maroon) {
    auto const& maroon_name = iter.first;
    auto const& maroon = iter.second;
    fo << std::endl;
    fo << "namespace MAROON_NAMESPACE_" << maroon_name << " {" << std::endl;
    std::vector<std::string> extra_types_list;

    // Topologically sort the types to figure out their dependencies and the right declaratio order.

    struct TopologicalSorter final {
      std::map<std::string, MaroonIRType> const& types;

      std::set<std::string> user_defined_types;
      std::vector<std::string> types_in_order;
      std::set<std::string> type_seen;

      explicit TopologicalSorter(std::map<std::string, MaroonIRType> const& types) : types(types) {
        for (auto const& cit : types) {
          user_defined_types.insert(cit.first);
        }
        for (auto const& cit : types) {
          dfs(cit.first);
        }
      }

      void dfs(std::string const& type) {
        if (!user_defined_types.count(type)) {
          return;
        }

        if (type_seen.count(type)) {
          return;
        }
        type_seen.insert(type);

        MaroonIRTypeDef const& def = types.at(type).def;
        if (Exists<MaroonIRTypeDefOptional>(def)) {
          dfs(Value<MaroonIRTypeDefOptional>(def).type);
        } else if (Exists<MaroonIRTypeDefStruct>(def)) {
          for (auto const& cit : Value<MaroonIRTypeDefStruct>(def).fields) {
            dfs(cit.type);
          }
        } else if (Exists<MaroonIRTypeDefEnum>(def)) {
          for (auto const& cit : Value<MaroonIRTypeDefEnum>(def).cases) {
            dfs(cit.type);
          }
        }

        types_in_order.push_back(type);
      }
    };

    TopologicalSorter const sorter(maroon.types);

    // Then first forward-declare stuff.
    for (auto const& type_name : sorter.types_in_order) {
      extra_types_list.push_back(type_name);
      fo << "  struct MAROON_TYPE_" << type_name << ";" << std::endl;
    }

    // And afterwards declare the actual types.
    for (auto const& first : sorter.types_in_order) {
      auto const& second = maroon.types.at(first);
      if (Exists<MaroonIRTypeDefOptional>(second.def)) {
        auto const& def = Value<MaroonIRTypeDefOptional>(second.def);
        fo << "  DEFINE_MAROON_OPTIONAL_TYPE(" << first << ", " << def.type << ");\n";
      } else if (Exists<MaroonIRTypeDefStruct>(second.def)) {
        auto const& def = Value<MaroonIRTypeDefStruct>(second.def);
        fo << "  struct MAROON_TYPE_" << first << " final : MaroonTypeBase {" << std::endl;
        fo << "    static char const* const MAROON_type_name_static() { return \"" << first << "\"; }" << std::endl;
        fo << "    char const* const MAROON_type_name() const override { return \"" << first << "\"; }" << std::endl;

        fo << "    void MAROON_display(std::ostream& os) const override {\n";
        fo << "      using namespace MAROON_NAMESPACE_" << maroon_name << ";\n";
        bool first_debug_field = true;
        fo << "      os << '{';\n";
        for (auto const& fiter : def.fields) {
          if (first_debug_field) {
            first_debug_field = false;
          } else {
            fo << "      os << ',';\n";
          }
          fo << "      os << \"" << fiter.name << ":\";\n"
             << "      " << fiter.name << ".MAROON_display(os);\n";
        }
        fo << "    os << '}';\n";
        fo << "  }\n";

        bool has_fields = false;
        for (auto const& fiter : def.fields) {
          has_fields = true;
          fo << "    MAROON_TYPE_" << fiter.type << ' ' << fiter.name << ";\n";
        }
        fo << "    MAROON_TYPE_" << first << "(MaroonLegalInit";
        for (auto const& fiter : def.fields) {
          fo << ", MAROON_TYPE_" << fiter.type << ' ' << fiter.name;
        }
        fo << ')';
        if (has_fields) {
          fo << " : ";
          bool first = true;
          for (auto const& fiter : def.fields) {
            if (first) {
              first = false;
            } else {
              fo << ", ";
            }
            fo << fiter.name << "(std::move(" << fiter.name << "))";
          }
        }
        fo << " {}" << std::endl;
        fo << "  };" << std::endl;
        fo << "  inline MAROON_TYPE_" << first << ' ' << first << '(';
        {
          bool first = true;
          for (auto const& fiter : def.fields) {
            if (first) {
              first = false;
            } else {
              fo << ", ";
            }
            fo << "MAROON_TYPE_" << fiter.type << ' ' << fiter.name;
          }
        }
        fo << ") {\n";
        fo << "    return MAROON_TYPE_" << first << "(MaroonLegalInit()";
        {
          for (auto const& fiter : def.fields) {
            fo << ", std::move(" << fiter.name << ')';
          }
        }
        fo << ");\n";
        fo << "  }\n";
      } else if (Exists<MaroonIRTypeDefEnum>(second.def)) {
        auto const& def = Value<MaroonIRTypeDefEnum>(second.def);
        fo << "  struct MAROON_TYPE_" << first << " final : MaroonTypeBase {" << std::endl;
        fo << "    static char const* const MAROON_type_name_static() { return \"" << first << "\"; }" << std::endl;
        fo << "    char const* const MAROON_type_name() const override { return \"" << first << "\"; }" << std::endl;
        for (auto const& citer : def.cases) {
          fo << "    Optional<MAROON_TYPE_" << citer.type << "> MAROON_CASE_" << citer.key << ";\n";
        }
        fo << "    void MAROON_display(std::ostream& os) const override {\n";
        for (auto const& citer : def.cases) {
          fo << "      if (Exists(MAROON_CASE_" << citer.key << ")) {\n"
             << "        os << \"" << citer.key << "(\";\n"
             << "        Value(MAROON_CASE_" << citer.key << ").MAROON_display(os);\n"
             << "        os << ')';\n"
             << "        return;  // NOTE(dkorolev): Assuming at most one option is set.\n"
             << "      }\n";
        }
        fo << "    os << \"<_>\";\n";
        fo << "  }\n";
        fo << "    MAROON_TYPE_" << first << "(MaroonLegalInit, MAROON_INSTANCE_PLACEHOLDER) {}\n";
        fo << "    MAROON_TYPE_" << first << "(MaroonLegalInit, MAROON_TYPE_" << first << " rhs) {\n"
           << "      *this = std::move(rhs);\n"
           << "      }\n";
        fo << "  };\n";

        for (auto const& fcase : def.cases) {
          fo << "    inline MAROON_TYPE_" << first << ' ' << fcase.key << "(MAROON_TYPE_" << fcase.type << " val) {\n"
             << "      MAROON_TYPE_" << first << " retval(MaroonLegalInit(), _);\n"
             << "      retval.MAROON_CASE_" << fcase.key << " = std::move(val);\n"
             << "      return retval;\n"
             << "    }\n";
        }
      }
    }

    fo << "  struct MAROON_spec final : MaroonDefinition {" << std::endl;
    fo << "    char const* const maroon_name() const override { return \"" << maroon_name << "\"; }" << std::endl;
    fo << "  };" << std::endl;
    for (auto const& iter : maroon.fibers) {
      auto const& fiber_name = iter.first;
      auto const& fiber = iter.second;
      fo << "  struct " << fiber_name << " {" << std::endl;
      fo << "    constexpr static bool kIsFiber = true;" << std::endl;
      fo << "    constexpr static char const* const kFiberName = \"" << fiber_name << "\";" << std::endl;
      struct StatementsRecursiveVisitor final {
        std::ostream& fo;
        std::vector<std::pair<size_t, size_t>> nvars;  // { # upon entering, # to be added on block entry }
        std::string fn_name = "\n#error \"`fn_name` unset.\"\n";
        Optional<std::string> fn_return_type;
        std::vector<MaroonIRVar> local_vars;
        std::vector<MaroonIRVar> next_step_init_vars;

        StatementsRecursiveVisitor(std::ostream& fo) : fo(fo) {}

        void EnsureNoLocalVars() {
          if (!local_vars.empty()) {
            std::cerr << "Internal invariant failed: should have no local variables at this point." << std::endl;
            std::exit(1);
          }
        }

        void ExposeVarsAccessors() {
          size_t tmp_idx = 0;
          for (auto const& var0 : local_vars) {
            if (Exists<MaroonIRVarRegular>(var0)) {
              MaroonIRVarRegular const& var = Value<MaroonIRVarRegular>(var0);
              fo << "      using MAROON_VAR_TYPE_" << var.name << " = MAROON_TYPE_" << var.type << ";\n"
                 << "      auto& " << var.name << " = MAROON_env.AccessVar<MAROON_VAR_TYPE_" << var.name << ">("
                 << tmp_idx << ",\"" << var.name << "\");\n"
                 << "      auto MAROON_VAR_INDEX_" << var.name << " = static_cast<MaroonVarIndex>(" << tmp_idx
                 << ");\n";
            } else if (Exists<MaroonIRVarFunctionArg>(var0)) {
              MaroonIRVarFunctionArg const& var = Value<MaroonIRVarFunctionArg>(var0);
              fo << "      using MAROON_VAR_TYPE_" << var.name << " = MAROON_TYPE_" << var.type << ";\n"
                 << "      auto& " << var.name << " = MAROON_env.AccessVar<MAROON_VAR_TYPE_" << var.name << ">("
                 << tmp_idx << ",\"" << var.name << "\");\n"
                 << "      auto MAROON_VAR_INDEX_" << var.name << " = static_cast<MaroonVarIndex>(" << tmp_idx
                 << ");\n";
            } else if (Exists<MaroonIRVarEnumCaseCapture>(var0)) {
              MaroonIRVarEnumCaseCapture const& var = Value<MaroonIRVarEnumCaseCapture>(var0);
              if (!var.name.empty()) {
                fo << "      using MAROON_VAR_TYPE_" << var.name << " = typename decltype(" << var.src
                   << ".MAROON_CASE_" << var.key << ")::optional_underlying_t;\n"
                   << "      MAROON_VAR_TYPE_" << var.name << "& " << var.name << " = Value(" << var.src
                   << ".MAROON_CASE_" << var.key << ");\n";
              }
            } else {
              std::cerr << "Internal error at " << __LINE__ << std::endl;
              std::exit(1);
            }
            ++tmp_idx;
          }
        }

        void PrintHeader() {
          size_t const entry_vars = local_vars.size();
          size_t const declared_vars = next_step_init_vars.size();

          size_t const step_idx = nvars.size();
          nvars.push_back({entry_vars, declared_vars});

          // Declare the vars.
          fo << "    static void VARS_" << step_idx << kVarsFunctionSignature << "{ // " << fn_name << std::endl;
          ExposeVarsAccessors();
          fo << "      static_cast<void>(MAROON_env);" << std::endl;
          for (auto const& var0 : next_step_init_vars) {
            if (Exists<MaroonIRVarRegular>(var0)) {
              MaroonIRVarRegular const& var = Value<MaroonIRVarRegular>(var0);
              fo << "      MAROON_env.DeclareVar(" << local_vars.size() << ",\"" << var.name
                 << "\", std::make_unique<MAROON_TYPE_" << var.type << ">(MaroonLegalInit()";
              // TODO(dkorolev): If it does not `Exist`, it's an internal error.
              std::string const init = Value(var.init);
              if (!init.empty()) {
                fo << ", " << init;
              }
              fo << "));" << std::endl;
            } else if (Exists<MaroonIRVarFunctionArg>(var0)) {
              MaroonIRVarFunctionArg const& var = Value<MaroonIRVarFunctionArg>(var0);
              fo << "      MAROON_env.DeclareFunctionArg<MAROON_TYPE_" << var.type << ">(" << local_vars.size() << ",\""
                 << var.name << "\");" << std::endl;
            } else if (Exists<MaroonIRVarEnumCaseCapture>(var0)) {
              MaroonIRVarEnumCaseCapture const& var = Value<MaroonIRVarEnumCaseCapture>(var0);
              fo << "      MAROON_env.DeclareCapturedAlias(" << local_vars.size() << ",\"" << var.name << "\");"
                 << std::endl;
            } else {
              std::cerr << "Internal error at " << __LINE__ << std::endl;
              std::exit(1);
            }
            local_vars.push_back(var0);
          }
          next_step_init_vars.clear();
          fo << "    }" << std::endl;

          fo << "    static void IMPL_" << step_idx << kStepFunctionSignature << " {  // " << fn_name << std::endl;
          ExposeVarsAccessors();
          if (Exists(fn_return_type)) {
            fo << "    using T_FUNCTION_RETURN_TYPE = MAROON_TYPE_" << Value(fn_return_type) << ";\n";
          } else {
            // TODO(dkorolev): Unsure if we even need this, but for extra sanity.
            fo << "    using T_FUNCTION_RETURN_TYPE = void;\n";
          }
          for (auto const& var0 : local_vars) {
            if (Exists<MaroonIRVarRegular>(var0)) {
              MaroonIRVarRegular const& var = Value<MaroonIRVarRegular>(var0);
              fo << "      static_cast<void>(" << var.name << ");" << std::endl;
            } else if (Exists<MaroonIRVarFunctionArg>(var0)) {
              MaroonIRVarFunctionArg const& var = Value<MaroonIRVarFunctionArg>(var0);
              fo << "      static_cast<void>(" << var.name << ");" << std::endl;
            } else if (Exists<MaroonIRVarEnumCaseCapture>(var0)) {
              MaroonIRVarEnumCaseCapture const& var = Value<MaroonIRVarEnumCaseCapture>(var0);
              if (!var.name.empty()) {
                fo << "      static_cast<void>(" << var.name << ");" << std::endl;
              }
            } else {
              std::cerr << "Internal error at " << __LINE__ << std::endl;
              std::exit(1);
            }
          }
          fo << "      ";
        }

        void PrintFooter() { fo << "  }" << std::endl; }

        void operator()(MaroonIRStmt const& code) {
          PrintHeader();
          // Enable `STMT(...)` without `STMT({...})` for short `STMT`-s.
          fo << code.stmt << std::endl << ';' << std::endl;
          PrintFooter();
        }

        void operator()(MaroonIRIf const& cond) {
          size_t const step_idx = nvars.size();
          PrintHeader();
          fo << "      if (" << cond.cond << ") {" << std::endl;
          fo << "        MAROON_result.branch(IF_YES_" << step_idx << "());" << std::endl;
          fo << "      } else {" << std::endl;
          fo << "        MAROON_result.branch(IF_NO_" << step_idx << "());" << std::endl;
          fo << "      }" << std::endl;
          PrintFooter();
          // NOTE(dkorolev): On `yes` it will always be the next step index, but that's details.
          fo << "  constexpr static MaroonStateIndex IF_YES_" << step_idx
             << "() { return static_cast<MaroonStateIndex>(" << nvars.size() << "); }" << std::endl;
          cond.yes.Call(*this);

          PrintHeader();
          fo << "      MAROON_result.branch(IF_DONE_" << step_idx << "());";
          PrintFooter();

          fo << "  constexpr static MaroonStateIndex IF_NO_" << step_idx << "() { return static_cast<MaroonStateIndex>("
             << nvars.size() << "); }" << std::endl;
          cond.no.Call(*this);
          fo << "  constexpr static MaroonStateIndex IF_DONE_" << step_idx
             << "() { return static_cast<MaroonStateIndex>(" << nvars.size() << "); }" << std::endl;
        }

        void operator()(MaroonIRBlock const& blk) {
          size_t const save_local_vars_size = local_vars.size();

          for (auto const& var : blk.vars) {
            next_step_init_vars.push_back(var);
          }

          for (auto const& c : blk.code) {
            c.Call(*this);
          }

          // TODO(dkorolev): Destruction, eventually, of those vars, as they leave the last step of the block.
          if (save_local_vars_size + blk.vars.size() != local_vars.size()) {
            std::cerr << "Internal invariant failed: wrong number of local variables at this point." << std::endl;
            std::exit(1);
          }
          local_vars.resize(local_vars.size() - blk.vars.size());
        }

        void operator()(MaroonIRMatchEnumStmt const& enum_stmt) {
          size_t const step_idx = nvars.size();
          PrintHeader();
          size_t in_idx = 0;
          fo << "      if (false) {" << std::endl;
          for (auto const& arm : enum_stmt.arms) {
            ++in_idx;
            if (Exists(arm.key)) {
              fo << "      } else if (Exists(" << enum_stmt.var << ".MAROON_CASE_" << Value(arm.key) << ")) {\n";
              fo << "        MAROON_result.branch(MATCH_" << step_idx << "_ARM_" << in_idx << "());" << std::endl;
            } else {
              fo << "      } else {" << std::endl;
              fo << "        MAROON_result.branch(MATCH_" << step_idx << "_ARM_" << in_idx << "());" << std::endl;
            }
          }
          fo << "      }" << std::endl;
          PrintFooter();

          size_t out_idx = 0;
          for (auto& arm : enum_stmt.arms) {
            ++out_idx;
            fo << "  constexpr static MaroonStateIndex MATCH_" << step_idx << "_ARM_" << out_idx
               << "() { return static_cast<MaroonStateIndex>(" << nvars.size() << "); }" << std::endl;
            (*this)(arm.code);
            if (out_idx != in_idx) {
              PrintHeader();
              fo << "      MAROON_result.branch(MATCH_" << step_idx << "_DONE());";
              PrintFooter();
            }
          }
          fo << "  constexpr static MaroonStateIndex MATCH_" << step_idx << "_DONE"
             << "() { return static_cast<MaroonStateIndex>(" << nvars.size() << "); }" << std::endl;
        }

        void operator()(MaroonIRBlockPlaceholder const&) {
          std::cerr << "Internal invaviant error: seeing `MaroonIRBlockPlaceholder`." << std::endl;
          std::exit(1);
        }
      };

      for (auto const& iter : fiber.functions) {
        auto const& fn_name = iter.first;
        auto const& fn = iter.second;
        if (Exists(fn.ret)) {
          fo << "    using MAROON_F_RETURN_TYPE_" << fn_name << " = MAROON_TYPE_" << Value(fn.ret) << ";\n";
        } else {
          // NOTE(dkorolev): Unnecessary, but let it be.
          fo << "    using MAROON_F_RETURN_TYPE_" << fn_name << " = void;\n";
        }
        fo << "    using MAROON_F_ARGS_" << fn_name << " = std::tuple<";
        bool first = true;
        for (auto const& a : fn.args) {
          if (first) {
            first = false;
          } else {
            fo << ", ";
          }
          fo << "MAROON_TYPE_" << a;
        }
        fo << ">;\n";
      }

      StatementsRecursiveVisitor visitor(fo);
      for (auto const& iter : fiber.functions) {
        auto const& fn_name = iter.first;
        auto const& fn = iter.second;
        visitor.EnsureNoLocalVars();
        fo << "    constexpr static MaroonStateIndex FN_" << fn_name << " = static_cast<MaroonStateIndex>("
           << visitor.nvars.size() << ");" << std::endl;
        fo << "    constexpr static size_t NUMBER_OF_ARGS_" << fn_name << " = " << fn.args.size() << ";\n";
        visitor.fn_name = fn_name;
        visitor.fn_return_type = fn.ret;
        visitor(fn.body);
        visitor.fn_name = "";
        visitor.fn_return_type = nullptr;
      }
      fo << "    constexpr static uint32_t kStepsCount = " << visitor.nvars.size() << ";" << std::endl;
      fo << "    static std::array<MaroonStep, kStepsCount> MAROON_steps() { return {";
      for (uint32_t i = 0; i < visitor.nvars.size(); ++i) {
        if (i) {
          fo << ",";
        }
        fo << "MaroonStep{IMPL_" << i << ',' << visitor.nvars[i].first << ',' << visitor.nvars[i].second << ",VARS_"
           << i << '}';
      }
      fo << "  };" << std::endl;
      fo << "}" << std::endl;
      fo << "  };  // fiber `" << fiber_name << '`' << std::endl;
    }
    fo << "}  // namespace MAROON_NAMESPACE_" << maroon_name << std::endl;
  }

  size_t index = 0;
  for (auto const& test : scenarios.tests) {
    fo << std::endl;
    GenerateTestCase(fo, test, FLAGS_name, ++index);
  }
}
