MAROON(factorial) {
  FIBER(global) {
    FN(main) {
      VAR(result, U64, 0);
      STMT(CALL(result, factorial, (U64(4))));
      STMT({
        DEBUG_EXPR(result);
        RETURN();
      });
    };
    FN(factorial, U64) {
      ARG(n, U64);
      IF(
        n <= U64(1),
        // No need for a `BLOCK` to just `RETURN`, an outer `STMT` is enough.
        STMT(RETURN(U64(1))),
        // Need a `BLOCK` to declare a variable, because need a variable to store the return value of a `CALL`.
        BLOCK {
          // Declare the variable for the intermediate result.
          VAR(r, U64, 0);
          STMT({
            DEBUG("before");
            DEBUG_DUMP_STACK();
            // Make the recursive call.
            CALL(r, factorial, (n - U64(1)));
          });
          // The `CALL` must be the end of an `STMT`, so the `RETURN` part is in the next `STMT`.
          STMT({
            DEBUG("after");
            DEBUG_DUMP_STACK();
            // Return the result.
            RETURN(r * n);
          });
        }
      );
    };
  };
};

// TODO(dkorolev): Should be able to test calling functions with arguments, directly from some `TEST_` macro!
TEST_FIBER(
  factorial,
  global,
  {
    "before",
    "<[result:0],factorial@[n:4,r:0]>",
    "before",
    "<[result:0],factorial@[n:4,r:0],factorial@[n:3,r:0]>",
    "before",
    "<[result:0],factorial@[n:4,r:0],factorial@[n:3,r:0],factorial@[n:2,r:0]>",
    "after",
    "<[result:0],factorial@[n:4,r:0],factorial@[n:3,r:0],factorial@[n:2,r:1]>",
    "after",
    "<[result:0],factorial@[n:4,r:0],factorial@[n:3,r:2]>",
    "after",
    "<[result:0],factorial@[n:4,r:6]>",
    "result=24",
  });
