// Generated by dsl::codegen from IR
#![allow(dead_code)]

#[derive(Clone, Debug, PartialEq)]
pub struct User {
  pub id: String,
  pub age: u64,
  pub email: String,
  pub rating: u64,
}

#[derive(Clone, Debug, PartialEq)]
pub struct GlobalTimeoutMsg {
  pub sec: u64,
}

#[derive(Clone, Debug, PartialEq)]
pub struct UserManagerGetUserMsg {
  pub key: String,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct GlobalHeap {
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct SocialScoreHeap {
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UserManagerHeap {
  pub users: std::collections::HashMap<String, User>,
}

#[derive(Clone, Debug)]
pub enum Heap {
  Global(GlobalHeap),
  SocialScore(SocialScoreHeap),
  UserManager(UserManagerHeap),
}

#[derive(Clone, Debug, PartialEq)]
pub enum State {
  Completed,
  Idle,
  GlobalAddEntry,
  GlobalFactorialEntry,
  GlobalFactorialFactorialCall,
  GlobalFactorialMultiply,
  GlobalFactorialReturn,
  GlobalFactorialReturn1,
  GlobalFactorialSubtract,
  GlobalMultEntry,
  GlobalRandGenEntry,
  GlobalSubEntry,
  SocialScoreIncrementCallAdd,
  SocialScoreIncrementCheckUser,
  SocialScoreIncrementDone,
  SocialScoreIncrementEntry,
  SocialScoreIncrementHaveUser,
  SocialScoreIncrementSelect,
  SocialScoreIncrementSetUser,
  SocialScoreIncrementTimeoutStart,
  SocialScoreIncrementUpdateUser,
  UserManagerGetEntry,
  UserManagerSetEntry,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
  GlobalAddParamA(u64),
  GlobalAddParamB(u64),
  GlobalAddReturn(u64),
  GlobalFactorialParamN(u64),
  GlobalFactorialLocalFacCallRes(u64),
  GlobalFactorialLocalResult(u64),
  GlobalFactorialLocalSubtractRes(u64),
  GlobalFactorialReturn(u64),
  GlobalMultParamA(u64),
  GlobalMultParamB(u64),
  GlobalMultReturn(u64),
  GlobalRandGenReturn(u64),
  GlobalSubParamA(u64),
  GlobalSubParamB(u64),
  GlobalSubReturn(u64),
  SocialScoreIncrementParamUserId(String),
  SocialScoreIncrementLocalNewRating(u64),
  SocialScoreIncrementLocalUpdatedUser(User),
  SocialScoreIncrementLocalUser(User),
  SocialScoreIncrementLocalUserOpt(Option<User>),
  SocialScoreIncrementReturn(()),
  UserManagerGetParamKey(String),
  UserManagerGetReturn(Option<User>),
  UserManagerSetParamKey(String),
  UserManagerSetParamItem(User),
  UserManagerSetReturn(()),
  GlobalTimeoutFieldSec(u64),
  UserManagerGetUserFieldKey(String),
}


#[derive(Clone, Debug, PartialEq)]
pub enum StackEntry {
  State(State),
  Retrn(Option<Value>),
  Value(Value),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  Sleep(u64, State),
  Write(String, State),
  GoTo(State),
  Branch { then_: State, else_: State },
  Select(Vec<State>),
  // Return can carry an optional value to be consumed by the runtime.
  Return(Option<Value>),
  Todo(String),
}pub fn state_args_count(e: &State) -> usize {
  match e {
    State::Completed | State::Idle => 0,
    State::GlobalAddEntry => 2,
    State::GlobalFactorialEntry => 1,
    State::GlobalFactorialFactorialCall => 1,
    State::GlobalFactorialMultiply => 2,
    State::GlobalFactorialReturn => 1,
    State::GlobalFactorialReturn1 => 0,
    State::GlobalFactorialSubtract => 1,
    State::GlobalMultEntry => 2,
    State::GlobalRandGenEntry => 0,
    State::GlobalSubEntry => 2,
    State::SocialScoreIncrementCallAdd => 1,
    State::SocialScoreIncrementCheckUser => 1,
    State::SocialScoreIncrementDone => 0,
    State::SocialScoreIncrementEntry => 1,
    State::SocialScoreIncrementHaveUser => 1,
    State::SocialScoreIncrementSelect => 0,
    State::SocialScoreIncrementSetUser => 2,
    State::SocialScoreIncrementTimeoutStart => 0,
    State::SocialScoreIncrementUpdateUser => 2,
    State::UserManagerGetEntry => 0,
    State::UserManagerSetEntry => 0,
  }
}

pub fn global_step(state: State, vars: &[StackEntry], _heap: &mut Heap) -> StepResult {
  match state {
    State::Completed => StepResult::Done,
    State::Idle => panic!("shoudnt be here"),
    State::GlobalAddEntry => {
      let a: u64 = if let StackEntry::Value(Value::GlobalAddParamA(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(Value::GlobalAddParamB(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::GlobalAddReturn(a + b)))
    }
    State::GlobalFactorialEntry => {
      let n: u64 = if let StackEntry::Value(Value::GlobalFactorialParamN(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::GoTo(State::GlobalFactorialEntry)
    }
    State::GlobalFactorialFactorialCall => {
      let subtractRes: u64 = vars.iter().find_map(|e| if let StackEntry::Value(Value::GlobalFactorialLocalSubtractRes(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable GlobalFactorialLocalSubtractRes on stack");
      StepResult::Next(vec![
        StackEntry::Retrn(None),
        StackEntry::Value(Value::GlobalFactorialParamN(subtractRes)),
        StackEntry::State(State::GlobalFactorialEntry),
      ])
    }
    State::GlobalFactorialMultiply => {
      let facCallRes: u64 = vars.iter().find_map(|e| if let StackEntry::Value(Value::GlobalFactorialLocalFacCallRes(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable GlobalFactorialLocalFacCallRes on stack");
      let n: u64 = vars.iter().find_map(|e| if let StackEntry::Value(Value::GlobalFactorialParamN(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable GlobalFactorialParamN on stack");
      StepResult::Next(vec![
        StackEntry::Retrn(None),
        StackEntry::Value(Value::GlobalMultParamA(n)),
        StackEntry::Value(Value::GlobalMultParamB(facCallRes)),
        StackEntry::State(State::GlobalMultEntry),
      ])
    }
    State::GlobalFactorialReturn => {
      let result: u64 = vars.iter().find_map(|e| if let StackEntry::Value(Value::GlobalFactorialLocalResult(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable GlobalFactorialLocalResult on stack");
      StepResult::Return(Some(Value::GlobalFactorialReturn(result)))
    }
    State::GlobalFactorialReturn1 => {
      StepResult::Return(Some(Value::GlobalFactorialReturn(1u64)))
    }
    State::GlobalFactorialSubtract => {
      let n: u64 = vars.iter().find_map(|e| if let StackEntry::Value(Value::GlobalFactorialParamN(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable GlobalFactorialParamN on stack");
      StepResult::Next(vec![
        StackEntry::Retrn(None),
        StackEntry::Value(Value::GlobalSubParamA(n)),
        StackEntry::Value(Value::GlobalSubParamB(1u64)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
    State::GlobalMultEntry => {
      let a: u64 = if let StackEntry::Value(Value::GlobalMultParamA(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(Value::GlobalMultParamB(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::GlobalMultReturn(a * b)))
    }
    State::GlobalRandGenEntry => {
      StepResult::Return(None)
    }
    State::GlobalSubEntry => {
      let a: u64 = if let StackEntry::Value(Value::GlobalSubParamA(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(Value::GlobalSubParamB(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::GlobalSubReturn(a - b)))
    }
    State::SocialScoreIncrementEntry => {
      let userId: String = if let StackEntry::Value(Value::SocialScoreIncrementParamUserId(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::GoTo(State::SocialScoreIncrementEntry)
    }
    State::SocialScoreIncrementCallAdd => {
      let user: User = vars.iter().find_map(|e| if let StackEntry::Value(Value::SocialScoreIncrementLocalUser(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable SocialScoreIncrementLocalUser on stack");
      StepResult::Next(vec![
        StackEntry::Retrn(None),
        StackEntry::Value(Value::GlobalAddParamA((user).rating)),
        StackEntry::Value(Value::GlobalAddParamB(1u64)),
        StackEntry::State(State::GlobalAddEntry),
      ])
    }
    State::SocialScoreIncrementCheckUser => {
      let userOpt: Option<User> = vars.iter().find_map(|e| if let StackEntry::Value(Value::SocialScoreIncrementLocalUserOpt(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable SocialScoreIncrementLocalUserOpt on stack");
      StepResult::Branch { then_: State::SocialScoreIncrementHaveUser, else_: State::SocialScoreIncrementDone }
    }
    State::SocialScoreIncrementDone => {
      StepResult::Return(None)
    }
    State::SocialScoreIncrementHaveUser => {
      let userOpt: Option<User> = vars.iter().find_map(|e| if let StackEntry::Value(Value::SocialScoreIncrementLocalUserOpt(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable SocialScoreIncrementLocalUserOpt on stack");
      StepResult::Next(vec![
        StackEntry::Value(Value::SocialScoreIncrementLocalUser((userOpt).unwrap())),
        StackEntry::State(State::SocialScoreIncrementCallAdd),
      ])
    }
    State::SocialScoreIncrementSelect => {
      StepResult::Select(vec![State::SocialScoreIncrementCheckUser, State::SocialScoreIncrementDone])
    }
    State::SocialScoreIncrementSetUser => {
      let updatedUser: User = vars.iter().find_map(|e| if let StackEntry::Value(Value::SocialScoreIncrementLocalUpdatedUser(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable SocialScoreIncrementLocalUpdatedUser on stack");
      let userId: String = vars.iter().find_map(|e| if let StackEntry::Value(Value::SocialScoreIncrementParamUserId(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable SocialScoreIncrementParamUserId on stack");
      StepResult::Next(vec![
        StackEntry::Retrn(None),
        StackEntry::Value(Value::UserManagerSetParamKey(userId)),
        StackEntry::Value(Value::UserManagerSetParamItem(updatedUser)),
        StackEntry::State(State::UserManagerSetEntry),
      ])
    }
    State::SocialScoreIncrementTimeoutStart => {
      StepResult::GoTo(State::SocialScoreIncrementSelect)
    }
    State::SocialScoreIncrementUpdateUser => {
      let newRating: u64 = vars.iter().find_map(|e| if let StackEntry::Value(Value::SocialScoreIncrementLocalNewRating(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable SocialScoreIncrementLocalNewRating on stack");
      let user: User = vars.iter().find_map(|e| if let StackEntry::Value(Value::SocialScoreIncrementLocalUser(x)) = e { Some(x.clone()) } else { None }).expect("Missing variable SocialScoreIncrementLocalUser on stack");
      StepResult::Next(vec![
        StackEntry::Value(Value::SocialScoreIncrementLocalUpdatedUser({ let mut tmp = (user).clone(); tmp.rating = (newRating); tmp })),
        StackEntry::State(State::SocialScoreIncrementSetUser),
      ])
    }
    State::UserManagerGetEntry => {
      let key: String = if let StackEntry::Value(Value::UserManagerGetParamKey(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::GoTo(State::UserManagerGetEntry)
    }
    State::UserManagerSetEntry => {
      let key: String = if let StackEntry::Value(Value::UserManagerSetParamKey(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let item: User = if let StackEntry::Value(Value::UserManagerSetParamItem(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::GoTo(State::UserManagerSetEntry)
    }
  }
}
