// Generated by dsl::codegen from IR
#![allow(dead_code)]

#[derive(Clone, Debug, Default, PartialEq)]
pub struct GlobalHeap {
}

#[derive(Clone, Debug)]
pub enum Heap {
  Global(GlobalHeap),
}

#[derive(Clone, Debug, PartialEq)]
pub enum State {
  Completed,
  Idle,
  GlobalAddEntry,
  GlobalFactorialEntry,
  GlobalFactorialFactorialCall,
  GlobalFactorialMultiply,
  GlobalFactorialReturn,
  GlobalFactorialReturn1,
  GlobalFactorialSubtract,
  GlobalMultEntry,
  GlobalSubEntry,
  GlobalSubAddEntry,
  GlobalSubAddFinalize,
  GlobalSubAddSubSum,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
  U64(u64),
}


#[derive(Clone, Debug, PartialEq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(String, Value),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  Sleep(u64, State),
  Write(String, State),
  GoTo(State),
  Branch { then_: State, else_: State },
  Select(Vec<State>),
  // Return can carry an optional value to be consumed by the runtime.
  Return(Option<Value>),
  Todo(String),
}
pub fn func_args_count(e: &State) -> usize {
  match e {
    State::GlobalAddEntry => 2,
    State::GlobalFactorialEntry => 4,
    State::GlobalFactorialFactorialCall => 4,
    State::GlobalFactorialMultiply => 4,
    State::GlobalFactorialReturn => 4,
    State::GlobalFactorialReturn1 => 4,
    State::GlobalFactorialSubtract => 4,
    State::GlobalMultEntry => 2,
    State::GlobalSubEntry => 2,
    State::GlobalSubAddEntry => 5,
    State::GlobalSubAddFinalize => 5,
    State::GlobalSubAddSubSum => 5,
    State::Idle => 0,
    State::Completed => 0,
  }
}
pub fn global_step(state: State, vars: &[StackEntry], _heap: &mut Heap) -> StepResult {
  match state {
    State::Completed => StepResult::Done,
    State::Idle => panic!("shoudnt be here"),
    State::GlobalAddEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(a + b)))
    }
    State::GlobalFactorialEntry => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      if n == 1u64 { StepResult::GoTo(State::GlobalFactorialReturn1) } else { StepResult::GoTo(State::GlobalFactorialSubtract) }
    }
    State::GlobalFactorialFactorialCall => {
      let subtractRes: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialMultiply),
        StackEntry::Retrn(Some(4)),
        StackEntry::Value("n".to_string(), Value::U64(subtractRes)),
        StackEntry::Value("fac_call_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("subtract_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("result".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalFactorialEntry),
      ])
    }
    State::GlobalFactorialMultiply => {
      let facCallRes: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialReturn),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("a".to_string(), Value::U64(n)),
        StackEntry::Value("b".to_string(), Value::U64(facCallRes)),
        StackEntry::State(State::GlobalMultEntry),
      ])
    }
    State::GlobalFactorialReturn => {
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(result)))
    }
    State::GlobalFactorialReturn1 => {
      StepResult::Return(Some(Value::U64(1u64)))
    }
    State::GlobalFactorialSubtract => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialFactorialCall),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value("a".to_string(), Value::U64(n)),
        StackEntry::Value("b".to_string(), Value::U64(1u64)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
    State::GlobalMultEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(a * b)))
    }
    State::GlobalSubEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(a - b)))
    }
    State::GlobalSubAddEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let c: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddSubSum),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value("a".to_string(), Value::U64(a)),
        StackEntry::Value("b".to_string(), Value::U64(b)),
        StackEntry::State(State::GlobalAddEntry),
      ])
    }
    State::GlobalSubAddFinalize => {
      let subABC: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(subABC)))
    }
    State::GlobalSubAddSubSum => {
      let c: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let sumAB: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddFinalize),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("a".to_string(), Value::U64(sumAB)),
        StackEntry::Value("b".to_string(), Value::U64(c)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
  }
}
