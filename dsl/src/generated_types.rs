// Generated by dsl::codegen from IR
#![allow(dead_code)]

#[derive(Clone, Debug, Default, PartialEq)]
pub struct GlobalHeap {
}

#[derive(Clone, Debug)]
pub enum Heap {
  Global(GlobalHeap),
}

#[derive(Clone, Debug, PartialEq)]
pub enum State {
  Completed,
  Idle,
  GlobalAddEntry,
  GlobalSubEntry,
  GlobalSubAddEntry,
  GlobalSubAddFinalize,
  GlobalSubAddSubSum,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
  U64(u64),
}


#[derive(Clone, Debug, PartialEq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(Value),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  Sleep(u64, State),
  Write(String, State),
  GoTo(State),
  Branch { then_: State, else_: State },
  Select(Vec<State>),
  // Return can carry an optional value to be consumed by the runtime.
  Return(Option<Value>),
  Todo(String),
}
pub fn func_args_count(e: &State) -> usize {
  match e {
    State::GlobalAddEntry => 2,
    State::GlobalSubEntry => 2,
    State::GlobalSubAddEntry => 5,
    State::GlobalSubAddFinalize => 5,
    State::GlobalSubAddSubSum => 5,
    State::Idle => 0,
    State::Completed => 0,
  }
}
pub fn global_step(state: State, vars: &[StackEntry], _heap: &mut Heap) -> StepResult {
  match state {
    State::Completed => StepResult::Done,
    State::Idle => panic!("shoudnt be here"),
    State::GlobalAddEntry => {
      let a: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(a + b)))
    }
    State::GlobalSubEntry => {
      let a: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(a - b)))
    }
    State::GlobalSubAddEntry => {
      let a: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let c: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddSubSum),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value(Value::U64(a)),
        StackEntry::Value(Value::U64(b)),
        StackEntry::State(State::GlobalAddEntry),
      ])
    }
    State::GlobalSubAddFinalize => {
      let subABC: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      StepResult::Return(Some(Value::U64(subABC)))
    }
    State::GlobalSubAddSubSum => {
      let c: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let sumAB: u64 = if let StackEntry::Value(Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddFinalize),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value(Value::U64(sumAB)),
        StackEntry::Value(Value::U64(c)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
  }
}
