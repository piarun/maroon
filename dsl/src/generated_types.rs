// Generated by dsl::codegen from IR
#![allow(dead_code)]

#[derive(Clone, Debug, Default, PartialEq)]
pub struct GlobalHeap {
  pub binarySearchValues: Vec<u64>,
}

#[derive(Clone, Debug)]
pub enum Heap {
  Global(GlobalHeap),
}

#[derive(Clone, Debug, PartialEq)]
pub enum State {
  Completed,
  Idle,
  GlobalAddEntry,
  GlobalAddReturn,
  GlobalBinarySearchCalculateDiv,
  GlobalBinarySearchCmpLess,
  GlobalBinarySearchEntry,
  GlobalBinarySearchGoLeft,
  GlobalBinarySearchGoLeftCheckOverflow,
  GlobalBinarySearchGoRight,
  GlobalBinarySearchRecursiveCall,
  GlobalBinarySearchReturnNone,
  GlobalBinarySearchReturnFound,
  GlobalBinarySearchReturnIfEqual,
  GlobalBinarySearchReturnResult,
  GlobalDivEntry,
  GlobalFactorialEntry,
  GlobalFactorialFactorialCall,
  GlobalFactorialMultiply,
  GlobalFactorialReturn,
  GlobalFactorialReturn1,
  GlobalFactorialSubtract,
  GlobalMultEntry,
  GlobalSubEntry,
  GlobalSubAddEntry,
  GlobalSubAddFinalize,
  GlobalSubAddSubSum,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
  OptionU64(Option<u64>),
  U64(u64),
}


#[derive(Clone, Debug, PartialEq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(String, Value),
  // In-place updates to the current frame (offset -> new Value)
  FrameAssign(Vec<(usize, Value)>),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  Sleep(u64, State),
  Write(String, State),
  GoTo(State),
  Branch { then_: State, else_: State },
  Select(Vec<State>),
  // Return can carry an optional value to be consumed by the runtime.
  Return(Value),
  ReturnVoid,
  Todo(String),
}
pub fn func_args_count(e: &State) -> usize {
  match e {
    State::GlobalAddEntry => 3,
    State::GlobalAddReturn => 3,
    State::GlobalBinarySearchCalculateDiv => 6,
    State::GlobalBinarySearchCmpLess => 6,
    State::GlobalBinarySearchEntry => 6,
    State::GlobalBinarySearchGoLeft => 6,
    State::GlobalBinarySearchGoLeftCheckOverflow => 6,
    State::GlobalBinarySearchGoRight => 6,
    State::GlobalBinarySearchRecursiveCall => 6,
    State::GlobalBinarySearchReturnNone => 6,
    State::GlobalBinarySearchReturnFound => 6,
    State::GlobalBinarySearchReturnIfEqual => 6,
    State::GlobalBinarySearchReturnResult => 6,
    State::GlobalDivEntry => 2,
    State::GlobalFactorialEntry => 4,
    State::GlobalFactorialFactorialCall => 4,
    State::GlobalFactorialMultiply => 4,
    State::GlobalFactorialReturn => 4,
    State::GlobalFactorialReturn1 => 4,
    State::GlobalFactorialSubtract => 4,
    State::GlobalMultEntry => 2,
    State::GlobalSubEntry => 2,
    State::GlobalSubAddEntry => 5,
    State::GlobalSubAddFinalize => 5,
    State::GlobalSubAddSubSum => 5,
    State::Idle => 0,
    State::Completed => 0,
  }
}
fn __inline_global_add_entry(a: u64, b: u64, heap: &mut Heap) -> u64 {

let out = a + b;
out

}

fn __inline_global_binarySearch_calculateDiv(left: u64, right: u64, heap: &mut Heap) -> (u64, u64) {

                    let o_div = (left + right) / 2;
                    let Heap::Global(s) = heap;
                    (o_div, s.binarySearchValues[o_div as usize])
                    
}

pub fn global_step(state: State, vars: &[StackEntry], heap: &mut Heap) -> StepResult {
  match state {
    State::Completed => StepResult::Done,
    State::Idle => panic!("shoudnt be here"),
    State::GlobalAddEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let sum: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      { let out = __inline_global_add_entry(a, b, heap); StepResult::Return(Value::U64(out)) }
    }
    State::GlobalAddReturn => {
      let sum: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(sum))
    }
    State::GlobalBinarySearchEntry => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      if left > right { StepResult::GoTo(State::GlobalBinarySearchReturnNone) } else { StepResult::GoTo(State::GlobalBinarySearchCalculateDiv) }
    }
    State::GlobalBinarySearchCalculateDiv => {
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      { let out = __inline_global_binarySearch_calculateDiv(left, right, heap);
        let (o0, o1) = out;
        StepResult::Next(vec![
          StackEntry::FrameAssign(vec![
            ( 3, Value::U64(o0) ),
            ( 4, Value::U64(o1) ),
          ]),
          StackEntry::State(State::GlobalBinarySearchReturnIfEqual),
        ]) }
    }
    State::GlobalBinarySearchCmpLess => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let vByIndexDiv: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      if vByIndexDiv < e { StepResult::GoTo(State::GlobalBinarySearchGoRight) } else { StepResult::GoTo(State::GlobalBinarySearchGoLeftCheckOverflow) }
    }
    State::GlobalBinarySearchGoLeft => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalBinarySearchRecursiveCall),
        StackEntry::Retrn(Some(5)),
        StackEntry::Value("a".to_string(), Value::U64(div)),
        StackEntry::Value("b".to_string(), Value::U64(1u64)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
    State::GlobalBinarySearchGoLeftCheckOverflow => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      if div < 0u64 { StepResult::GoTo(State::GlobalBinarySearchReturnNone) } else { StepResult::GoTo(State::GlobalBinarySearchGoLeft) }
    }
    State::GlobalBinarySearchGoRight => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalBinarySearchRecursiveCall),
        StackEntry::Retrn(Some(6)),
        StackEntry::Value("a".to_string(), Value::U64(div)),
        StackEntry::Value("b".to_string(), Value::U64(1u64)),
        StackEntry::Value("sum".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalAddEntry),
      ])
    }
    State::GlobalBinarySearchRecursiveCall => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let left: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let right: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalBinarySearchReturnResult),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("e".to_string(), Value::U64(e)),
        StackEntry::Value("left".to_string(), Value::U64(left)),
        StackEntry::Value("right".to_string(), Value::U64(right)),
        StackEntry::Value("div".to_string(), Value::U64(0u64)),
        StackEntry::Value("v_by_index_div".to_string(), Value::U64(0u64)),
        StackEntry::Value("fac_call_res".to_string(), Value::OptionU64(None)),
        StackEntry::State(State::GlobalBinarySearchEntry),
      ])
    }
    State::GlobalBinarySearchReturnNone => {
      StepResult::Return(Value::OptionU64(None))
    }
    State::GlobalBinarySearchReturnFound => {
      let div: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::OptionU64(Some(div)))
    }
    State::GlobalBinarySearchReturnIfEqual => {
      let e: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let vByIndexDiv: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      if vByIndexDiv == e { StepResult::GoTo(State::GlobalBinarySearchReturnFound) } else { StepResult::GoTo(State::GlobalBinarySearchCmpLess) }
    }
    State::GlobalBinarySearchReturnResult => {
      let facCallRes: Option<u64> = if let StackEntry::Value(_, Value::OptionU64(x)) = &vars[5] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::OptionU64(facCallRes))
    }
    State::GlobalDivEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(a / b))
    }
    State::GlobalFactorialEntry => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      if n == 1u64 { StepResult::GoTo(State::GlobalFactorialReturn1) } else { StepResult::GoTo(State::GlobalFactorialSubtract) }
    }
    State::GlobalFactorialFactorialCall => {
      let subtractRes: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialMultiply),
        StackEntry::Retrn(Some(4)),
        StackEntry::Value("n".to_string(), Value::U64(subtractRes)),
        StackEntry::Value("fac_call_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("subtract_res".to_string(), Value::U64(0u64)),
        StackEntry::Value("result".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalFactorialEntry),
      ])
    }
    State::GlobalFactorialMultiply => {
      let facCallRes: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialReturn),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("a".to_string(), Value::U64(n)),
        StackEntry::Value("b".to_string(), Value::U64(facCallRes)),
        StackEntry::State(State::GlobalMultEntry),
      ])
    }
    State::GlobalFactorialReturn => {
      let result: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(result))
    }
    State::GlobalFactorialReturn1 => {
      StepResult::Return(Value::U64(1u64))
    }
    State::GlobalFactorialSubtract => {
      let n: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalFactorialFactorialCall),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value("a".to_string(), Value::U64(n)),
        StackEntry::Value("b".to_string(), Value::U64(1u64)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
    State::GlobalMultEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(a * b))
    }
    State::GlobalSubEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(a - b))
    }
    State::GlobalSubAddEntry => {
      let a: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[0] { x.clone() } else { unreachable!() };
      let b: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[1] { x.clone() } else { unreachable!() };
      let c: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddSubSum),
        StackEntry::Retrn(Some(3)),
        StackEntry::Value("a".to_string(), Value::U64(a)),
        StackEntry::Value("b".to_string(), Value::U64(b)),
        StackEntry::Value("sum".to_string(), Value::U64(0u64)),
        StackEntry::State(State::GlobalAddEntry),
      ])
    }
    State::GlobalSubAddFinalize => {
      let subABC: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[4] { x.clone() } else { unreachable!() };
      StepResult::Return(Value::U64(subABC))
    }
    State::GlobalSubAddSubSum => {
      let c: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[2] { x.clone() } else { unreachable!() };
      let sumAB: u64 = if let StackEntry::Value(_, Value::U64(x)) = &vars[3] { x.clone() } else { unreachable!() };
      StepResult::Next(vec![
        StackEntry::State(State::GlobalSubAddFinalize),
        StackEntry::Retrn(Some(2)),
        StackEntry::Value("a".to_string(), Value::U64(sumAB)),
        StackEntry::Value("b".to_string(), Value::U64(c)),
        StackEntry::State(State::GlobalSubEntry),
      ])
    }
  }
}
