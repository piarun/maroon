use crate::ir::*;

fn type_variant_name(t: &Type) -> String {
  match t {
    Type::Int => "U64".into(),
    Type::String => "String".into(),
    Type::Void => "Unit".into(),
    Type::Struct(name, _) => pascal_case(name),
    Type::Custom(name) => pascal_case(name),
    Type::Option(inner) => format!("Option{}", type_variant_name(inner)),
    Type::Array(inner) => format!("Array{}", type_variant_name(inner)),
    Type::Map(k, v) => format!("Map{}To{}", type_variant_name(k), type_variant_name(v)),
  }
}

fn rust_type(t: &Type) -> String {
  match t {
    Type::Int => "u64".into(),
    Type::String => "String".into(),
    Type::Void => "()".into(),
    Type::Map(k, v) => format!("std::collections::HashMap<{}, {}>", rust_type(k), rust_type(v)),
    Type::Array(t) => format!("Vec<{}>", rust_type(t)),
    Type::Struct(name, _) => pascal_case(name),
    Type::Option(t) => format!("Option<{}>", rust_type(t)),
    Type::Custom(name) => pascal_case(name),
  }
}

fn pascal_case(raw: &str) -> String {
  let s = raw.to_string();
  if s.contains('_') {
    let mut out = String::new();
    for part in s.split('_') {
      if part.is_empty() {
        continue;
      }
      let mut chars = part.chars();
      if let Some(f) = chars.next() {
        out.push(f.to_ascii_uppercase());
        for ch in chars {
          out.push(ch.to_ascii_lowercase());
        }
      }
    }
    if out.is_empty() { "_".to_string() } else { out }
  } else {
    // Already in one word, likely camelCase or ALLCAPS. Uppercase first, keep rest as-is to preserve camel.
    let mut chars = s.chars();
    match chars.next() {
      None => "_".to_string(),
      Some(f) => f.to_ascii_uppercase().to_string() + chars.as_str(),
    }
  }
}

fn camel_ident(raw: &str) -> String {
  let p = pascal_case(raw);
  let mut c = p.chars();
  match c.next() {
    None => String::new(),
    Some(f) => f.to_ascii_lowercase().to_string() + c.as_str(),
  }
}

fn variant_name(parts: &[&str]) -> String {
  parts.iter().map(|p| pascal_case(p)).collect::<Vec<_>>().join("")
}

pub fn generate_rust_types(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("// Generated by dsl::codegen from IR\n");
  out.push_str("#![allow(dead_code)]\n\n");

  // 1) Emit custom struct types declared at top-level IR.types
  for t in &ir.types {
    if let Type::Struct(name, fields) = t {
      out.push_str(&format!("#[derive(Clone, Debug, PartialEq)]\npub struct {} {{\n", pascal_case(name)));
      for f in fields {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(&f.name), rust_type(&f.ty)));
      }
      out.push_str("}\n\n");
    }
  }

  // 2) Emit message structs per fiber.in_messages (sorted by fiber, then message name)
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.name.cmp(&b.name));
    for msg in &msgs {
      let msg_ty = variant_name(&[fiber_name, &msg.name, "Msg"]);
      out.push_str(&format!("#[derive(Clone, Debug, PartialEq)]\npub struct {} {{\n", msg_ty));
      let mut fields_sorted = msg.fields.clone();
      fields_sorted.sort_by(|a, b| a.0.cmp(&b.0));
      for (fname, fty) in &fields_sorted {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(fname), rust_type(fty)));
      }
      out.push_str("}\n\n");
    }
  }

  // 3) Emit per-fiber heap structs and a unified Heap enum
  let mut heap_variants: Vec<(String, String)> = Vec::new();
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let heap_struct = variant_name(&[fiber_name, "Heap"]);
    out.push_str(&format!("#[derive(Clone, Debug, Default, PartialEq)]\npub struct {} {{\n", heap_struct));
    let mut heap_fields: Vec<(&String, &Type)> = fiber.heap.iter().collect();
    heap_fields.sort_by(|a, b| a.0.cmp(b.0));
    for (name, ty) in heap_fields {
      out.push_str(&format!("  pub {}: {},\n", camel_ident(name), rust_type(ty)));
    }
    out.push_str("}\n\n");
    heap_variants.push((pascal_case(fiber_name), heap_struct));
  }
  out.push_str("#[derive(Clone, Debug)]\npub enum Heap {\n");
  if heap_variants.is_empty() {
    out.push_str("  Empty,\n");
  } else {
    heap_variants.sort_by(|a, b| a.0.cmp(&b.0));
    for (variant, struct_name) in heap_variants {
      out.push_str(&format!("  {}({}),\n", variant, struct_name));
    }
  }
  out.push_str("}\n\n");

  // 4) Emit State enum variants for all steps of all funcs (always include entry).
  out.push_str("#[derive(Clone, Debug, PartialEq)]\npub enum State {\n");
  // Always include `Completed` and `Idle` as catch-alls to mirror runtime expectations.
  out.push_str("  Completed,\n  Idle,\n");
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      let mut steps: Vec<String> = Vec::new();
      steps.push(func.entry.0.clone());
      for (step_id, _step) in &func.steps {
        steps.push(step_id.0.clone());
      }
      steps.sort();
      steps.dedup();
      for s in steps {
        let v = variant_name(&[fiber_name, func_name, &s]);
        out.push_str(&format!("  {},\n", v));
      }
    }
  }
  out.push_str("}\n\n");

  // 5) Emit Value enum compacted by Rust types actually used in IR (params, locals, returns, message fields).
  use std::collections::BTreeMap;
  let mut used_types: BTreeMap<String, Type> = BTreeMap::new();
  for (_, fiber) in fibers_sorted.iter() {
    for (_, func) in fiber.funcs.iter() {
      for p in &func.in_vars {
        used_types.insert(type_variant_name(&p.type_), p.type_.clone());
      }
      for l in &func.locals {
        used_types.insert(type_variant_name(&l.type_), l.type_.clone());
      }
      used_types.insert(type_variant_name(&func.out), func.out.clone());
    }
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.name.cmp(&b.name));
    for msg in &msgs {
      for (_, fty) in &msg.fields {
        used_types.insert(type_variant_name(fty), fty.clone());
      }
    }
  }

  out.push_str("#[derive(Clone, Debug, PartialEq)]\npub enum Value {\n");
  for (vname, ty) in used_types.iter() {
    out.push_str(&format!("  {}({}),\n", vname, rust_type(ty)));
  }
  out.push_str("}\n\n");

  // 6) Emit runtime-aligned scaffolding types and global_step
  out.push_str(
    r"
#[derive(Clone, Debug, PartialEq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(Value),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  Sleep(u64, State),
  Write(String, State),
  GoTo(State),
  Branch { then_: State, else_: State },
  Select(Vec<State>),
  // Return can carry an optional value to be consumed by the runtime.
  Return(Option<Value>),
  Todo(String),
}",
  );

  // Emit helper that tells how many Value entries are on the stack for a given State.
  out.push_str(&generate_func_args_count(ir));

  out.push_str(&generate_global_step(ir));

  out
}

use std::collections::BTreeSet;

fn collect_vars_from_expr(
  expr: &Expr,
  acc: &mut BTreeSet<String>,
) {
  match expr {
    Expr::Int(_) | Expr::Str(_) => {}
    Expr::Var(name) => {
      acc.insert(name.clone());
    }
    Expr::Equal(a, b) => {
      collect_vars_from_expr(a, acc);
      collect_vars_from_expr(b, acc);
    }
    Expr::IsSome(e) | Expr::Unwrap(e) => collect_vars_from_expr(e, acc),
    Expr::GetField(e, _) => collect_vars_from_expr(e, acc),
    Expr::StructUpdate { base, updates } => {
      collect_vars_from_expr(base, acc);
      for (_, e) in updates {
        collect_vars_from_expr(e, acc);
      }
    }
  }
}

fn var_type_of<'a>(
  func: &'a Func,
  name: &str,
) -> Option<&'a Type> {
  for p in &func.in_vars {
    if p.name == name {
      return Some(&p.type_);
    }
  }
  for l in &func.locals {
    if l.name == name {
      return Some(&l.type_);
    }
  }
  None
}

fn var_is_param(
  func: &Func,
  name: &str,
) -> bool {
  func.in_vars.iter().any(|p| p.name == name)
}

fn render_expr_code(
  expr: &Expr,
  _func: &Func,
) -> String {
  match expr {
    Expr::Int(x) => format!("{}u64", x),
    Expr::Var(name) => camel_ident(name),
    Expr::Equal(a, b) => format!("{} == {}", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::IsSome(e) => format!("({}).is_some()", render_expr_code(e, _func)),
    Expr::Unwrap(e) => format!("({}).unwrap()", render_expr_code(e, _func)),
    Expr::GetField(e, field) => format!("({}).{}", render_expr_code(e, _func), camel_ident(field)),
    Expr::StructUpdate { base, updates } => {
      let mut s = format!("{{ let mut tmp = ({}).clone(); ", render_expr_code(base, _func));
      for (fname, fexpr) in updates {
        s.push_str(&format!("tmp.{} = ({}); ", camel_ident(fname), render_expr_code(fexpr, _func)));
      }
      s.push_str("tmp }");
      s
    }
    Expr::Str(_) => todo!(),
  }
}

fn render_call_step(
  ir: &IR,
  current_fiber: &str,
  current_func_name: &str,
  current_func: &Func,
  target: &FuncRef,
  args: &Vec<Expr>,
  ret_to: &StepId,
  bind: &Option<String>,
) -> String {
  let mut s = String::new();
  let ret_state = variant_name(&[current_fiber, current_func_name, &ret_to.0]);
  if let Some(callee) = find_func(ir, &target.fiber, &target.func) {
    s.push_str("      StepResult::Next(vec![\n");
    s.push_str(&format!("        StackEntry::State(State::{}),\n", ret_state));
    // Compute bind offset if provided
    if let Some(var_name) = bind {
      let params_len = current_func.in_vars.len();
      let locals_len = current_func.locals.len();
      let total_vars = params_len + locals_len;
      let var_index = if let Some(pi) = current_func.in_vars.iter().position(|p| &p.name == var_name) {
        Some(pi)
      } else if let Some(li) = current_func.locals.iter().position(|l| &l.name == var_name) {
        Some(params_len + li)
      } else {
        None
      };
      if let Some(var_ind) = var_index {
        // +1 for the continuation state we just pushed
        let offset = (total_vars + 1) - var_ind;
        s.push_str(&format!("        StackEntry::Retrn(Some({})),\n", offset));
      } else {
        s.push_str("        StackEntry::Retrn(None),\n");
      }
    } else {
      s.push_str("        StackEntry::Retrn(None),\n");
    }
    for (idx, p) in callee.in_vars.iter().enumerate() {
      if let Some(arg) = args.get(idx) {
        let vname = type_variant_name(&p.type_);
        let expr_code = render_expr_code(arg, current_func);
        s.push_str(&format!("        StackEntry::Value(Value::{}({})),\n", vname, expr_code));
      }
    }
    let callee_entry = variant_name(&[&target.fiber, &target.func, &callee.entry.0]);
    s.push_str(&format!("        StackEntry::State(State::{}),\n", callee_entry));
    s.push_str("      ])\n");
  } else {
    s.push_str(&format!("      StepResult::GoTo(State::{})\n", ret_state));
  }
  s
}

fn find_func<'a>(
  ir: &'a IR,
  fiber: &str,
  func: &str,
) -> Option<&'a Func> {
  ir.fibers.get(fiber).and_then(|f| f.funcs.get(func))
}

// Generate a function that returns how many Value entries are expected to be
// located for function. So it shows the stack deep only for XXXEntry steps
// The count is computed as:
// - For any function entry state: number of input params + locals
fn generate_func_args_count(ir: &IR) -> String {
  use std::collections::HashMap;

  let mut counts: HashMap<String, usize> = HashMap::new();
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));

  let mut out = r"
pub fn func_args_count(e: &State) -> usize {
  match e {
"
  .to_string();

  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      let n = func.in_vars.len() + func.locals.len();

      if func_name == "add" || func_name == "sub" {
        // builtin exceptions
        let v = variant_name(&[fiber_name, func_name, "entry"]);
        out.push_str(&format!("    State::{} => {},\n", v, n));
        continue;
      }

      let mut steps_sorted: Vec<&(StepId, Step)> = func.steps.iter().collect();
      steps_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));

      for (step_id, _) in steps_sorted {
        let v = variant_name(&[fiber_name, func_name, &step_id.0]);

        out.push_str(&format!("    State::{} => {},\n", v, n));
      }
    }
  }
  out.push_str(&format!("    State::Idle => 0,\n"));
  out.push_str(&format!("    State::Completed => 0,\n"));

  out.push_str(
    r"  }
}
",
  );
  out
}

fn generate_global_step(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("pub fn global_step(state: State, vars: &[StackEntry], _heap: &mut Heap) -> StepResult {\n");
  out.push_str("  match state {\n");
  out.push_str("    State::Completed => StepResult::Done,\n");
  out.push_str("    State::Idle => panic!(\"shoudnt be here\"),\n");
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      use std::collections::BTreeSet;
      let mut seen: BTreeSet<String> = BTreeSet::new();
      let entry_variant = variant_name(&[fiber_name, func_name, &func.entry.0]);
      if seen.insert(entry_variant.clone()) {
        out.push_str(&format!("    State::{entry_variant} => {{\n"));

        // put variables from stack according to the IR needs
        // TODO: some steps won't need all the variables, so later it should be a bit trickier, when it comes to get indexes in a stack for variables
        for (i, var) in func.in_vars.iter().enumerate() {
          let vname = type_variant_name(&var.type_);
          out.push_str(&format!("      let {}: {} = if let StackEntry::Value(Value::{vname}(x)) = &vars[{}] {{ x.clone() }} else {{ unreachable!() }};\n", var.name, rust_type(&var.type_), i));
        }

        // Bind referenced locals for entry step using positional indices (after params)
        for (i, _var) in func.locals.iter().enumerate() {
          let _ = i;
        }

        // Built-in semantics for some primitive global functions.
        if fiber_name.as_str() == "global" && func_name.as_str() == "add" && func.in_vars.len() == 2 {
          out.push_str(&format!("      StepResult::Return(Some(Value::U64(a + b)))\n"));
        } else if fiber_name.as_str() == "global" && func_name.as_str() == "sub" && func.in_vars.len() == 2 {
          let r_v = variant_name(&[fiber_name, func_name, "Return"]);
          out.push_str(&format!("      StepResult::Return(Some(Value::U64(a - b)))\n"));
        } else if fiber_name.as_str() == "global" && func_name.as_str() == "mult" && func.in_vars.len() == 2 {
          let r_v = variant_name(&[fiber_name, func_name, "Return"]);
          out.push_str(&format!("      StepResult::Return(Some(Value::U64(a * b)))\n"));
        } else if fiber_name.as_str() == "global" && func_name.as_str() == "randGen" && func.in_vars.is_empty() {
          out.push_str(&format!("      StepResult::Return(None)\n"));
        } else {
          // If the entry step is explicitly defined in IR, emit its logic here; otherwise, fallback.
          if let Some((_, entry_step)) = func.steps.iter().find(|(sid, _)| sid.0 == func.entry.0) {
            // Collect referenced vars for this entry step
            let mut referenced: BTreeSet<String> = BTreeSet::new();
            match entry_step {
              Step::Sleep { ms, .. } => collect_vars_from_expr(&ms, &mut referenced),
              Step::Write { text, .. } => collect_vars_from_expr(&text, &mut referenced),
              Step::SendToFiber { args, .. } => {
                for (_, e) in args {
                  collect_vars_from_expr(&e, &mut referenced);
                }
              }
              Step::Await(_) => {}
              Step::Select { arms: _ } => {}
              Step::Call { args, .. } => {
                for e in args {
                  collect_vars_from_expr(&e, &mut referenced);
                }
              }
              Step::Return { value } => {
                if let Some(e) = value {
                  collect_vars_from_expr(&e, &mut referenced);
                }
              }
              Step::If { cond, .. } => collect_vars_from_expr(&cond, &mut referenced),
              Step::Let { expr, .. } => collect_vars_from_expr(&expr, &mut referenced),
            }
            // Bind only locals (params are already bound above) using positional indices
            for var_name in referenced.iter() {
              if let Some(ty) = var_type_of(func, var_name) {
                if !var_is_param(func, var_name) {
                  if let Some(pos) = func.locals.iter().position(|l| &l.name == var_name) {
                    let idx = func.in_vars.len() + pos;
                    let rust_ty = rust_type(ty);
                    let tname = type_variant_name(ty);
                    let local_ident = camel_ident(var_name);
                    out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(Value::{tname}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }};\n"));
                  }
                }
              } else {
                out.push_str(&format!(
                  "      // NOTE: Referenced variable '{var_name}' not found among params/locals.\n"
                ));
              }
            }
            match entry_step {
              Step::Sleep { ms, next } => {
                let next_v = variant_name(&[fiber_name, func_name, &next.0]);
                let ms_code = render_expr_code(&ms, func);
                out.push_str(&format!("      StepResult::Sleep({}, State::{})\n", ms_code, next_v));
              }
              Step::Write { text, next } => {
                let next_v = variant_name(&[fiber_name, func_name, &next.0]);
                let text_code = render_expr_code(&text, func);
                out.push_str(&format!(
                  "      StepResult::Write(format!(\"{}\", {}), State::{})\n",
                  "{}", text_code, next_v
                ));
              }
              Step::SendToFiber { next, .. } => {
                let next_v = variant_name(&[fiber_name, func_name, &next.0]);
                out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
              }
              Step::Await(spec) => {
                let next_v = variant_name(&[fiber_name, func_name, &spec.ret_to.0]);
                out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
              }
              Step::Select { arms } => {
                let mut arm_states: Vec<String> = Vec::new();
                for arm in arms {
                  arm_states.push(variant_name(&[fiber_name, func_name, &arm.ret_to.0]));
                }
                out.push_str("      StepResult::Select(vec![");
                for (i, st) in arm_states.iter().enumerate() {
                  if i > 0 {
                    out.push_str(", ");
                  }
                  out.push_str(&format!("State::{}", st));
                }
                out.push_str("])\n");
              }
              Step::Call { target, args, ret_to, bind } => {
                out.push_str(&render_call_step(ir, fiber_name, func_name, func, target, args, ret_to, bind));
              }
              Step::Return { value } => {
                let ret_v = variant_name(&[fiber_name, func_name, "Return"]);
                if let Some(val_expr) = value {
                  let expr_code = render_expr_code(&val_expr, func);
                  // Return value by its underlying type wrapper
                  out.push_str(&format!(
                    "      StepResult::Return(Some(Value::{}({expr_code})))\n",
                    type_variant_name(&func.out)
                  ));
                } else {
                  out.push_str("      StepResult::Return(None)\n");
                }
              }
              Step::If { cond, then_, else_ } => {
                let then_v = variant_name(&[fiber_name, func_name, &then_.0]);
                let else_v = variant_name(&[fiber_name, func_name, &else_.0]);
                let cond_code = render_expr_code(&cond, func);
                out.push_str(&format!(
                  "      if {} {{ StepResult::GoTo(State::{}) }} else {{ StepResult::GoTo(State::{}) }}\n",
                  cond_code, then_v, else_v
                ));
              }
              Step::Let { local, expr, next } => {
                let next_v = variant_name(&[fiber_name, func_name, &next.0]);
                // Set a local by pushing a value of the underlying type. Runtime will bind it.
                let lty = var_type_of(func, local).expect("unknown local var in Let");
                let vname = type_variant_name(lty);
                let expr_code = render_expr_code(&expr, func);
                out.push_str("      StepResult::Next(vec![\n");
                out.push_str(&format!("        StackEntry::Value(Value::{}({})),\n", vname, expr_code));
                out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
                out.push_str("      ])\n");
              }
            }
          } else {
            // Default: nothing special, fall back to a no-op transition.
            out.push_str(&format!("      StepResult::GoTo(State::{})\n", &entry_variant));
          }
        }
        out.push_str("    }\n");
      }
      let mut steps_sorted: Vec<(&StepId, &Step)> = func.steps.iter().map(|(id, st)| (id, st)).collect();
      steps_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));
      for (step_id, step) in steps_sorted {
        let state_variant = variant_name(&[fiber_name, func_name, &step_id.0]);
        if !seen.insert(state_variant.clone()) {
          continue;
        }
        let mut referenced: BTreeSet<String> = BTreeSet::new();
        match step {
          Step::Sleep { ms, .. } => collect_vars_from_expr(&ms, &mut referenced),
          Step::Write { text, .. } => collect_vars_from_expr(&text, &mut referenced),
          Step::SendToFiber { args, .. } => {
            for (_, e) in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::Await(_) => {}
          Step::Select { arms: _ } => {}
          Step::Call { args, .. } => {
            for e in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::Return { value } => {
            if let Some(e) = value {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::If { cond, .. } => collect_vars_from_expr(&cond, &mut referenced),
          Step::Let { expr, .. } => collect_vars_from_expr(&expr, &mut referenced),
        }
        out.push_str(&format!("    State::{state_variant} => {{\n"));
        for var_name in referenced.iter() {
          if let Some(ty) = var_type_of(func, var_name) {
            let rust_ty = rust_type(ty);
            let tname = type_variant_name(ty);
            let local_ident = camel_ident(var_name);
            if var_is_param(func, var_name) {
              if let Some(pos) = func.in_vars.iter().position(|p| &p.name == var_name) {
                out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(Value::{tname}(x)) = &vars[{pos}] {{ x.clone() }} else {{ unreachable!() }};\n"));
              }
            } else {
              if let Some(pos) = func.locals.iter().position(|l| &l.name == var_name) {
                let idx = func.in_vars.len() + pos;
                out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(Value::{tname}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }};\n"));
              }
            }
          } else {
            out.push_str(&format!("      // NOTE: Referenced variable '{var_name}' not found among params/locals.\n"));
          }
        }
        match step {
          Step::Sleep { ms, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let ms_code = render_expr_code(&ms, func);
            out.push_str(&format!("      StepResult::Sleep({}, State::{})\n", ms_code, next_v));
          }
          Step::Write { text, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let text_code = render_expr_code(&text, func);
            out
              .push_str(&format!("      StepResult::Write(format!(\"{}\", {}), State::{})\n", "{}", text_code, next_v));
          }
          Step::SendToFiber { next, .. } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
          }
          Step::Await(spec) => {
            let next_v = variant_name(&[fiber_name, func_name, &spec.ret_to.0]);
            out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
          }
          Step::Select { arms } => {
            let mut arm_states: Vec<String> = Vec::new();
            for arm in arms {
              arm_states.push(variant_name(&[fiber_name, func_name, &arm.ret_to.0]));
            }
            out.push_str("      StepResult::Select(vec![");
            for (i, st) in arm_states.iter().enumerate() {
              if i > 0 {
                out.push_str(", ");
              }
              out.push_str(&format!("State::{}", st));
            }
            out.push_str("])\n");
          }
          Step::Call { target, args, ret_to, bind } => {
            out.push_str(&render_call_step(ir, fiber_name, func_name, func, target, args, ret_to, bind));
          }
          Step::Return { value } => {
            if let Some(val_expr) = value {
              let expr_code = render_expr_code(&val_expr, func);
              out.push_str(&format!(
                "      StepResult::Return(Some(Value::{}({expr_code})))\n",
                type_variant_name(&func.out)
              ));
            } else {
              out.push_str("      StepResult::Return(None)\n");
            }
          }
          Step::If { cond, then_, else_, .. } => {
            let then_v = variant_name(&[fiber_name, func_name, &then_.0]);
            let else_v = variant_name(&[fiber_name, func_name, &else_.0]);
            let cond_code = render_expr_code(&cond, func);
            out.push_str(&format!(
              "      if {} {{ StepResult::GoTo(State::{}) }} else {{ StepResult::GoTo(State::{}) }}\n",
              cond_code, then_v, else_v
            ));
          }
          Step::Let { local, expr, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let lty = var_type_of(func, local).expect("unknown local var in Let");
            let vname = type_variant_name(lty);
            let expr_code = render_expr_code(&expr, func);
            out.push_str("      StepResult::Next(vec![\n");
            out.push_str(&format!("        StackEntry::Value(Value::{}({})),\n", vname, expr_code));
            out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
            out.push_str("      ])\n");
          }
        }
        out.push_str("    }\n");
      }
    }
  }

  out.push_str("  }\n}\n");
  out
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::collections::HashMap;

  #[test]
  fn generates_types() {
    let ir = IR {
      types: vec![Type::Struct(
        "User".into(),
        vec![StructField { name: "id".into(), ty: Type::String }, StructField { name: "age".into(), ty: Type::Int }],
      )],
      fibers: HashMap::from([
        (
          "userManager".into(),
          Fiber {
            heap: HashMap::from([(
              "users".into(),
              Type::Map(Box::new(Type::String), Box::new(Type::Custom("User".into()))),
            )]),
            in_messages: vec![MessageSpec { name: "GetUser".into(), fields: vec![("key".into(), Type::String)] }],
            funcs: HashMap::from([(
              "get".into(),
              Func {
                in_vars: vec![InVar { name: "key".into(), type_: Type::String }],
                out: Type::Option(Box::new(Type::Custom("User".into()))),
                locals: vec![],
                entry: StepId::new("entry"),
                steps: vec![(StepId::new("entry"), Step::Return { value: None })],
              },
            )]),
          },
        ),
        ("global".into(), Fiber { heap: HashMap::new(), in_messages: vec![], funcs: HashMap::new() }),
      ]),
    };

    let code = generate_rust_types(&ir);
    // Spot-check a few important bits are present.
    assert!(code.contains("pub struct User"));
    assert!(code.contains("pub struct UserManagerGetUserMsg"));
    assert!(code.contains("pub enum Heap"));
    assert!(code.contains("pub enum State"));
    assert!(code.contains("UserManagerGetEntry"));
    assert!(code.contains("pub enum Value"));
    // With compact-by-type Value enum, we expect used types only
    assert!(code.contains("String(String)"));
    assert!(code.contains("OptionUser(Option<User>)"));
  }
}
