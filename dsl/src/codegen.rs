use crate::ir::*;

fn type_variant_name(t: &Type) -> String {
  match t {
    Type::UInt64 => "U64".into(),
    Type::String => "String".into(),
    Type::Void => "Unit".into(),
    Type::Struct(name, _) => pascal_case(name),
    Type::Custom(name) => pascal_case(name),
    Type::Option(inner) => format!("Option{}", type_variant_name(inner)),
    Type::Array(inner) => format!("Array{}", type_variant_name(inner)),
    Type::Map(k, v) => format!("Map{}To{}", type_variant_name(k), type_variant_name(v)),
  }
}

fn rust_type(t: &Type) -> String {
  match t {
    Type::UInt64 => "u64".into(),
    Type::String => "String".into(),
    Type::Void => "()".into(),
    Type::Map(k, v) => format!("std::collections::HashMap<{}, {}>", rust_type(k), rust_type(v)),
    Type::Array(t) => format!("Vec<{}>", rust_type(t)),
    Type::Struct(name, _) => pascal_case(name),
    Type::Option(t) => format!("Option<{}>", rust_type(t)),
    Type::Custom(name) => pascal_case(name),
  }
}

fn pascal_case(raw: &str) -> String {
  let s = raw.to_string();
  if s.contains('_') {
    let mut out = String::new();
    for part in s.split('_') {
      if part.is_empty() {
        continue;
      }
      let mut chars = part.chars();
      if let Some(f) = chars.next() {
        out.push(f.to_ascii_uppercase());
        for ch in chars {
          out.push(ch.to_ascii_lowercase());
        }
      }
    }
    if out.is_empty() { "_".to_string() } else { out }
  } else {
    // Already in one word, likely camelCase or ALLCAPS. Uppercase first, keep rest as-is to preserve camel.
    let mut chars = s.chars();
    match chars.next() {
      None => "_".to_string(),
      Some(f) => f.to_ascii_uppercase().to_string() + chars.as_str(),
    }
  }
}

fn camel_ident(raw: &str) -> String {
  let p = pascal_case(raw);
  let mut c = p.chars();
  match c.next() {
    None => String::new(),
    Some(f) => f.to_ascii_lowercase().to_string() + c.as_str(),
  }
}

fn variant_name(parts: &[&str]) -> String {
  parts.iter().map(|p| pascal_case(p)).collect::<Vec<_>>().join("")
}

pub fn generate_rust_types(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("// Generated by dsl::codegen from IR\n");
  out.push_str("#![allow(dead_code)]\n");
  out.push_str("#![allow(unused_variables)]\n");
  out.push_str("#![allow(non_snake_case)]\n\n");

  // 1) Emit custom struct types declared at top-level IR.types
  for t in &ir.types {
    if let Type::Struct(name, fields) = t {
      out.push_str(&format!("#[derive(Clone, Debug, Default, PartialEq)]\npub struct {} {{\n", pascal_case(name)));
      for f in fields {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(&f.name), rust_type(&f.ty)));
      }
      out.push_str("}\n\n");
    }
  }

  // 2) Emit message structs per fiber.in_messages (sorted by fiber, then message name)
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.0.cmp(&b.0));
    for msg in &msgs {
      let msg_ty = variant_name(&[fiber_name, &msg.0, "Msg"]);
      out.push_str(&format!("#[derive(Clone, Debug, PartialEq)]\npub struct {} {{\n", msg_ty));
      let mut fields_sorted = msg.1.clone();
      fields_sorted.sort_by(|a, b| a.0.cmp(&b.0));
      for (fname, fty) in &fields_sorted {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(fname), rust_type(fty)));
      }
      out.push_str("}\n\n");
    }
  }

  // 3) Emit per-fiber heap structs and a unified Heap enum
  let mut heap_variants: Vec<(String, String)> = Vec::new();
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let heap_struct = variant_name(&[fiber_name, "Heap"]);
    out.push_str(&format!("#[derive(Clone, Debug, Default, PartialEq)]\npub struct {} {{\n", heap_struct));
    let mut heap_fields: Vec<(&String, &Type)> = fiber.heap.iter().collect();
    heap_fields.sort_by(|a, b| a.0.cmp(b.0));
    for (name, ty) in heap_fields {
      out.push_str(&format!("  pub {}: {},\n", camel_ident(name), rust_type(ty)));
    }
    out.push_str("}\n\n");
    heap_variants.push((pascal_case(fiber_name), heap_struct));
  }
  out.push_str("#[derive(Clone, Debug)]\npub enum Heap {\n");
  if heap_variants.is_empty() {
    out.push_str("  Empty,\n");
  } else {
    heap_variants.sort_by(|a, b| a.0.cmp(&b.0));
    for (variant, struct_name) in heap_variants {
      out.push_str(&format!("  {}({}),\n", variant, struct_name));
    }
  }
  out.push_str("}\n\n");

  // 4) Emit State enum variants for all steps of all funcs (always include entry).
  out.push_str("#[derive(Clone, Debug, PartialEq)]\npub enum State {\n");
  // Always include `Completed` and `Idle` as catch-alls to mirror runtime expectations.
  out.push_str("  Completed,\n  Idle,\n");
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      // Identify direct-return RustBlock next steps to suppress from code generation
      use std::collections::BTreeSet as __BTS_CODEGEN;
      let mut suppressed: __BTS_CODEGEN<String> = __BTS_CODEGEN::new();
      for (_sid, st) in &func.steps {
        if let Step::RustBlock { binds, next, .. } = st {
          if binds.len() == 1 {
            if let Some((_, Step::Return { value })) = func.steps.iter().find(|(nsid, _)| nsid.0 == next.0) {
              if let RetValue::Var(vn) = value {
                if vn == &binds[0] {
                  suppressed.insert(next.0.clone());
                }
              }
            }
          }
        }
      }
      // Identify direct-return RustBlock next steps to suppress from State enum
      use std::collections::BTreeSet as __BTS;
      let mut suppressed: __BTS<String> = __BTS::new();
      for (_sid, st) in &func.steps {
        if let Step::RustBlock { binds, next, .. } = st {
          if binds.len() == 1 {
            if let Some((_, Step::Return { value })) = func.steps.iter().find(|(nsid, _)| nsid.0 == next.0) {
              if let RetValue::Var(vn) = value {
                if vn == &binds[0] {
                  suppressed.insert(next.0.clone());
                }
              }
            }
          }
        }
      }
      let mut steps: Vec<String> = Vec::new();
      steps.push(func.entry.0.clone());
      for (step_id, _step) in &func.steps {
        if !suppressed.contains(&step_id.0) {
          steps.push(step_id.0.clone());
        }
      }
      steps.sort();
      steps.dedup();
      for s in steps {
        let v = variant_name(&[fiber_name, func_name, &s]);
        out.push_str(&format!("  {},\n", v));
      }
    }
  }
  out.push_str("}\n\n");

  // 5) Emit Value enum compacted by Rust types actually used in IR (params, locals, returns, message fields).
  use std::collections::BTreeMap;
  let mut used_types: BTreeMap<String, Type> = BTreeMap::new();
  for (_, fiber) in fibers_sorted.iter() {
    for (_, func) in fiber.funcs.iter() {
      for p in &func.in_vars {
        let ty = &p.1;
        used_types.insert(type_variant_name(ty), ty.clone());
      }
      for l in &func.locals {
        let ty = &l.1;
        used_types.insert(type_variant_name(ty), ty.clone());
      }
      used_types.insert(type_variant_name(&func.out), func.out.clone());
    }
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.0.cmp(&b.0));
    for msg in &msgs {
      for (_, fty) in &msg.1 {
        used_types.insert(type_variant_name(fty), fty.clone());
      }
    }
  }

  out.push_str("#[derive(Clone, Debug, PartialEq)]\npub enum Value {\n");
  for (vname, ty) in used_types.iter() {
    out.push_str(&format!("  {}({}),\n", vname, rust_type(ty)));
  }
  out.push_str("}\n\n");

  // 6) Emit runtime-aligned scaffolding types and global_step
  out.push_str(
    r"
#[derive(Clone, Debug, PartialEq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(String, Value),
  // In-place updates to the current frame (offset -> new Value)
  FrameAssign(Vec<(usize, Value)>),
}

#[derive(Clone, Debug, PartialEq)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  Sleep(u64, State),
  Write(String, State),
  GoTo(State),
  Branch { then_: State, else_: State },
  Select(Vec<State>),
  // Return can carry an optional value to be consumed by the runtime.
  Return(Value),
  ReturnVoid,
  Todo(String),
}",
  );

  // Emit helper that tells how many Value entries are on the stack for a given State.
  out.push_str(&generate_func_args_count(ir));

  out.push_str(&generate_global_step(ir));

  // Emit helpers to prepare initial stack/heap and extract result
  out.push_str(&generate_prepare_and_result_helpers(ir));

  out
}

fn generate_prepare_and_result_helpers(ir: &IR) -> String {
  let mut out = String::new();

  // Iterate fibers and functions deterministically
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));

  for (fiber_name, fiber) in fibers_sorted.iter() {
    let heap_struct = variant_name(&[fiber_name, "Heap"]);
    let heap_enum_variant = pascal_case(fiber_name);

    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));

    for (func_name, func) in funcs_sorted {
      // Prepare function signature
      let prepare_fn_name = format!("{}_prepare_{}", camel_ident(fiber_name), camel_ident(func_name));
      let mut params: Vec<String> = Vec::new();
      for p in &func.in_vars {
        let name = p.0;
        let ty = &p.1;
        params.push(format!("{}: {}", camel_ident(name), rust_type(ty)));
      }

      // Return type always: (Vec<StackEntry>, Heap)
      out.push_str(&format!("pub fn {}({}) -> (Vec<StackEntry>, Heap) {{\n", prepare_fn_name, params.join(", ")));
      out.push_str("  let mut stack: Vec<StackEntry> = Vec::new();\n");

      // 1) Push placeholder for return value and continuation marker
      let ret_vname = type_variant_name(&func.out);
      let ret_default = default_value_expr(&func.out);
      out.push_str(&format!(
        "  stack.push(StackEntry::Value(\"ret\".to_string(), Value::{}({})));\n",
        ret_vname, ret_default
      ));
      out.push_str("  stack.push(StackEntry::Retrn(Some(1)));\n");

      // 2) Push input params in order
      for p in &func.in_vars {
        let name = p.0;
        let ty = &p.1;
        let vname = type_variant_name(ty);
        out.push_str(&format!(
          "  stack.push(StackEntry::Value(\"{}\".to_string(), Value::{}({})));\n",
          name,
          vname,
          camel_ident(name)
        ));
      }

      // 3) Allocate locals with defaults
      for l in &func.locals {
        let lname = l.0;
        let lty = &l.1;
        let vname = type_variant_name(lty);
        let def_expr = default_value_expr(lty);
        out.push_str(&format!(
          "  stack.push(StackEntry::Value(\"{}\".to_string(), Value::{}({})));\n",
          lname, vname, def_expr
        ));
      }

      // 4) Push entry state
      let entry_state = variant_name(&[fiber_name, func_name, &func.entry.0]);
      out.push_str(&format!("  stack.push(StackEntry::State(State::{}));\n", entry_state));

      // 5) Initialize heap with defaults for this fiber
      out.push_str(&format!(
        "  let heap = Heap::{}({}::default());\n  (stack, heap)\n}}\n\n",
        heap_enum_variant, heap_struct
      ));

      // Result extraction function
      let result_fn_name = format!("{}_result_{}", camel_ident(fiber_name), camel_ident(func_name));
      let ret_ty = rust_type(&func.out);
      out.push_str(&format!("pub fn {}(stack: &[StackEntry]) -> {} {{\n", result_fn_name, ret_ty));
      out.push_str("  match stack.last() {\n");
      out.push_str("    Some(StackEntry::Value(_, ");
      out.push_str(&format!("Value::{}(v))) => v.clone(),\n", ret_vname));
      out.push_str("    _ => unreachable!(\"result not found on stack\"),\n");
      out.push_str("  }\n}\n\n");
    }
  }

  out
}

use std::collections::BTreeSet;

fn collect_vars_from_expr(
  expr: &Expr,
  acc: &mut BTreeSet<String>,
) {
  match expr {
    Expr::UInt64(_) | Expr::Str(_) => {}
    Expr::Var(name) => {
      acc.insert(name.clone());
    }
    Expr::Equal(a, b) | Expr::Greater(a, b) | Expr::Less(a, b) => {
      collect_vars_from_expr(a, acc);
      collect_vars_from_expr(b, acc);
    }
    Expr::IsSome(e) | Expr::Unwrap(e) => collect_vars_from_expr(e, acc),
    Expr::GetField(e, _) => collect_vars_from_expr(e, acc),
    Expr::StructUpdate { base, updates } => {
      collect_vars_from_expr(base, acc);
      for (_, e) in updates {
        collect_vars_from_expr(e, acc);
      }
    }
  }
}

fn var_type_of<'a>(
  func: &'a Func,
  name: &str,
) -> Option<&'a Type> {
  for p in &func.in_vars {
    if p.0 == name {
      return Some(&p.1);
    }
  }
  for l in &func.locals {
    if l.0 == name {
      return Some(&l.1);
    }
  }
  None
}

fn var_is_param(
  func: &Func,
  name: &str,
) -> bool {
  func.in_vars.iter().any(|p| p.0 == name)
}

fn render_expr_code(
  expr: &Expr,
  _func: &Func,
) -> String {
  match expr {
    Expr::UInt64(x) => format!("{}u64", x),
    Expr::Var(name) => camel_ident(name),
    Expr::Equal(a, b) => format!("{} == {}", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::Greater(a, b) => format!("{} > {}", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::Less(a, b) => format!("{} < {}", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::IsSome(e) => format!("({}).is_some()", render_expr_code(e, _func)),
    Expr::Unwrap(e) => format!("({}).unwrap()", render_expr_code(e, _func)),
    Expr::GetField(e, field) => format!("({}).{}", render_expr_code(e, _func), camel_ident(field)),
    Expr::StructUpdate { base, updates } => {
      let mut s = format!("{{ let mut tmp = ({}).clone(); ", render_expr_code(base, _func));
      for (fname, fexpr) in updates {
        s.push_str(&format!("tmp.{} = ({}); ", camel_ident(fname), render_expr_code(fexpr, _func)));
      }
      s.push_str("tmp }");
      s
    }
    Expr::Str(_) => todo!(),
  }
}

fn render_ret_value(
  rv: &RetValue,
  expected_ty: &Type,
  _func: &Func,
) -> String {
  match rv {
    RetValue::UInt64(x) => format!("{}u64", x),
    RetValue::Str(s) => format!("\"{}\".to_string()", s.replace('"', "\\\"")),
    RetValue::Var(name) => camel_ident(name),
    RetValue::Some(inner) => {
      if let Type::Option(inner_ty) = expected_ty {
        let inner_code = render_ret_value(inner, inner_ty, _func);
        format!("Some({})", inner_code)
      } else {
        let inner_code = render_ret_value(inner, expected_ty, _func);
        format!("Some({})", inner_code)
      }
    }
    RetValue::None => "None".to_string(),
  }
}

fn default_value_expr(t: &Type) -> String {
  match t {
    Type::UInt64 => "0u64".to_string(),
    Type::String => "String::new()".to_string(),
    Type::Void => "()".to_string(),
    Type::Option(_) => "None".to_string(),
    Type::Array(inner) => format!("Vec::<{}>::new()", rust_type(inner)),
    Type::Map(k, v) => format!("std::collections::HashMap::<{}, {}>::new()", rust_type(k), rust_type(v)),
    Type::Struct(name, _) | Type::Custom(name) => format!("{}::default()", pascal_case(name)),
  }
}

fn render_call_step(
  ir: &IR,
  current_fiber: &str,
  current_func_name: &str,
  current_func: &Func,
  target: &FuncRef,
  args: &Vec<Expr>,
  ret_to: &StepId,
  bind: &Option<String>,
) -> String {
  let mut s = String::new();
  let ret_state = variant_name(&[current_fiber, current_func_name, &ret_to.0]);
  if let Some(callee) = find_func(ir, &target.fiber, &target.func) {
    s.push_str("      StepResult::Next(vec![\n");
    s.push_str(&format!("        StackEntry::State(State::{}),\n", ret_state));
    // Compute bind offset if provided
    if let Some(var_name) = bind {
      let params_len = current_func.in_vars.len();
      let locals_len = current_func.locals.len();
      let total_vars = params_len + locals_len;
      let var_index = if let Some(pi) = current_func.in_vars.iter().position(|p| p.0 == var_name.as_str()) {
        Some(pi)
      } else if let Some(li) = current_func.locals.iter().position(|l| l.0 == var_name.as_str()) {
        Some(params_len + li)
      } else {
        None
      };
      if let Some(var_ind) = var_index {
        // +1 for the continuation state we just pushed
        let offset = (total_vars + 1) - var_ind;
        s.push_str(&format!("        StackEntry::Retrn(Some({})),\n", offset));
      } else {
        s.push_str("        StackEntry::Retrn(None),\n");
      }
    } else {
      s.push_str("        StackEntry::Retrn(None),\n");
    }
    for (idx, p) in callee.in_vars.iter().enumerate() {
      if let Some(arg) = args.get(idx) {
        let pname = p.0;
        let pty = &p.1;
        let vname = type_variant_name(pty);
        let expr_code = render_expr_code(arg, current_func);
        s.push_str(&format!(
          "        StackEntry::Value(\"{}\".to_string(), Value::{}({})),\n",
          pname, vname, expr_code
        ));
      }
    }
    // Push default placeholders for callee locals to allocate its frame fully
    for l in &callee.locals {
      let lname = l.0;
      let lty = &l.1;
      let vname = type_variant_name(lty);
      let def_expr = default_value_expr(lty);
      s.push_str(&format!("        StackEntry::Value(\"{}\".to_string(), Value::{}({})),\n", lname, vname, def_expr));
    }
    let callee_entry = variant_name(&[&target.fiber, &target.func, &callee.entry.0]);
    s.push_str(&format!("        StackEntry::State(State::{}),\n", callee_entry));
    s.push_str("      ])\n");
  } else {
    s.push_str(&format!("      StepResult::GoTo(State::{})\n", ret_state));
  }
  s
}

fn collect_vars_from_retvalue(
  rv: &RetValue,
  acc: &mut BTreeSet<String>,
) {
  match rv {
    RetValue::Var(name) => {
      acc.insert(name.clone());
    }
    RetValue::UInt64(_) | RetValue::Str(_) => {}
    RetValue::Some(inner) => collect_vars_from_retvalue(inner, acc),
    RetValue::None => {}
  }
}

fn find_func<'a>(
  ir: &'a IR,
  fiber: &str,
  func: &str,
) -> Option<&'a Func> {
  ir.fibers.get(fiber).and_then(|f| f.funcs.get(func))
}

fn heap_array_elem_type<'a>(
  ir: &'a IR,
  fiber: &str,
  array: &str,
) -> Option<&'a Type> {
  let fib = ir.fibers.get(fiber)?;
  let t = fib.heap.get(array)?;
  match t {
    Type::Array(inner) => Some(inner.as_ref()),
    _ => None,
  }
}

// Generate a function that returns how many Value entries are expected to be
// located for function. So it shows the stack deep only for XXXEntry steps
// The count is computed as:
// - For any function entry state: number of input params + locals
fn generate_func_args_count(ir: &IR) -> String {
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));

  let mut out = r"
pub fn func_args_count(e: &State) -> usize {
  match e {
"
  .to_string();

  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      let n = func.in_vars.len() + func.locals.len();
      // Always include the function's entry state
      let entry_variant = variant_name(&[fiber_name, func_name, &func.entry.0]);
      out.push_str(&format!("    State::{} => {},\n", entry_variant, n));

      // Identify direct-return RustBlock next steps to suppress from func_args_count
      use std::collections::BTreeSet as __BTS2;
      let mut suppressed: __BTS2<String> = __BTS2::new();
      for (_sid, st) in &func.steps {
        if let Step::RustBlock { binds, next, .. } = st {
          if binds.len() == 1 {
            if let Some((_, Step::Return { value })) = func.steps.iter().find(|(nsid, _)| nsid.0 == next.0) {
              if let RetValue::Var(vn) = value {
                if vn == &binds[0] {
                  suppressed.insert(next.0.clone());
                }
              }
            }
          }
        }
      }

      let mut steps_sorted: Vec<&(StepId, Step)> = func.steps.iter().collect();
      steps_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));

      for (step_id, _) in steps_sorted {
        if !suppressed.contains(&step_id.0) {
          let v = variant_name(&[fiber_name, func_name, &step_id.0]);
          out.push_str(&format!("    State::{} => {},\n", v, n));
        }
      }
    }
  }
  out.push_str(&format!("    State::Idle => 0,\n"));
  out.push_str(&format!("    State::Completed => 0,\n"));

  out.push_str(
    r"  }
}
",
  );
  out
}

fn generate_global_step(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("pub fn global_step(state: State, vars: &[StackEntry], heap: &mut Heap) -> StepResult {\n");
  out.push_str("  match state {\n");
  out.push_str("    State::Completed => StepResult::Done,\n");
  out.push_str("    State::Idle => panic!(\"shoudnt be here\"),\n");
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      // Compute suppressed steps (direct-return next of RustBlock) for this function
      use std::collections::BTreeSet as __BTS_CODEGEN2;
      let mut suppressed: __BTS_CODEGEN2<String> = __BTS_CODEGEN2::new();
      for (_sid, st) in &func.steps {
        if let Step::RustBlock { binds, next, .. } = st {
          if binds.len() == 1 {
            if let Some((_, Step::Return { value })) = func.steps.iter().find(|(nsid, _)| nsid.0 == next.0) {
              if let RetValue::Var(vn) = value {
                if vn == &binds[0] {
                  suppressed.insert(next.0.clone());
                }
              }
            }
          }
        }
      }
      use std::collections::BTreeSet;
      let mut seen: BTreeSet<String> = BTreeSet::new();
      let entry_variant = variant_name(&[fiber_name, func_name, &func.entry.0]);
      if seen.insert(entry_variant.clone()) {
        out.push_str(&format!("    State::{entry_variant} => {{\n"));

        // put variables from stack according to the IR needs
        // TODO: some steps won't need all the variables, so later it should be a bit trickier, when it comes to get indexes in a stack for variables
        for (i, var) in func.in_vars.iter().enumerate() {
          let vname_str = var.0;
          let vty = &var.1;
          let vname_ty = type_variant_name(vty);
          out.push_str(&format!(
            "      let {}: {} = if let StackEntry::Value(_, Value::{vname_ty}(x)) = &vars[{}] {{ x.clone() }} else {{ unreachable!() }};\n",
            vname_str, rust_type(vty), i
          ));
        }

        // Bind referenced locals for entry step using positional indices (after params)
        for (i, _var) in func.locals.iter().enumerate() {
          let _ = i;
        }

        // If the entry step is explicitly defined in IR, emit its logic here; otherwise, fallback.
        if let Some((_, entry_step)) = func.steps.iter().find(|(sid, _)| sid.0 == func.entry.0) {
          // Collect referenced vars for this entry step
          let mut referenced: BTreeSet<String> = BTreeSet::new();
          match entry_step {
            Step::Sleep { ms, .. } => collect_vars_from_expr(&ms, &mut referenced),
            Step::Write { text, .. } => collect_vars_from_expr(&text, &mut referenced),
            Step::SendToFiber { args, .. } => {
              for (_, e) in args {
                collect_vars_from_expr(&e, &mut referenced);
              }
            }
            Step::Await(_) => {}
            Step::Select { arms: _ } => {}
            Step::Call { args, .. } => {
              for e in args {
                collect_vars_from_expr(&e, &mut referenced);
              }
            }
            Step::Return { value } => collect_vars_from_retvalue(value, &mut referenced),
            Step::ReturnVoid => {}
            Step::If { cond, .. } => collect_vars_from_expr(&cond, &mut referenced),
            Step::Let { expr, .. } => collect_vars_from_expr(&expr, &mut referenced),
            Step::HeapGetIndex { index, .. } => collect_vars_from_expr(&index, &mut referenced),
            Step::RustBlock { .. } => {
              for p in &func.in_vars {
                referenced.insert(p.0.to_string());
              }
              for l in &func.locals {
                referenced.insert(l.0.to_string());
              }
            }
          }
          // Bind only locals (params are already bound above) using positional indices
          for var_name in referenced.iter() {
            if let Some(ty) = var_type_of(func, var_name) {
              if !var_is_param(func, var_name) {
                if let Some(pos) = func.locals.iter().position(|l| l.0 == var_name.as_str()) {
                  let idx = func.in_vars.len() + pos;
                  let rust_ty = rust_type(ty);
                  let tname = type_variant_name(ty);
                  let local_ident = camel_ident(var_name);
                  out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(_, Value::{tname}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }};\n"));
                }
              }
            } else {
              out
                .push_str(&format!("      // NOTE: Referenced variable '{var_name}' not found among params/locals.\n"));
            }
          }
          match entry_step {
            Step::Sleep { ms, next } => {
              let next_v = variant_name(&[fiber_name, func_name, &next.0]);
              let ms_code = render_expr_code(&ms, func);
              out.push_str(&format!("      StepResult::Sleep({}, State::{})\n", ms_code, next_v));
            }
            Step::Write { text, next } => {
              let next_v = variant_name(&[fiber_name, func_name, &next.0]);
              let text_code = render_expr_code(&text, func);
              out.push_str(&format!(
                "      StepResult::Write(format!(\"{}\", {}), State::{})\n",
                "{}", text_code, next_v
              ));
            }
            Step::SendToFiber { next, .. } => {
              let next_v = variant_name(&[fiber_name, func_name, &next.0]);
              out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
            }
            Step::Await(spec) => {
              let next_v = variant_name(&[fiber_name, func_name, &spec.ret_to.0]);
              out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
            }
            Step::Select { arms } => {
              let mut arm_states: Vec<String> = Vec::new();
              for arm in arms {
                arm_states.push(variant_name(&[fiber_name, func_name, &arm.ret_to.0]));
              }
              out.push_str("      StepResult::Select(vec![");
              for (i, st) in arm_states.iter().enumerate() {
                if i > 0 {
                  out.push_str(", ");
                }
                out.push_str(&format!("State::{}", st));
              }
              out.push_str("])\n");
            }
            Step::Call { target, args, ret_to, bind } => {
              out.push_str(&render_call_step(ir, fiber_name, func_name, func, target, args, ret_to, bind));
            }
            Step::Return { value } => {
              let code = render_ret_value(value, &func.out, func);
              out.push_str(&format!("      StepResult::Return(Value::{}({}))\n", type_variant_name(&func.out), code));
            }
            Step::ReturnVoid => out.push_str("      StepResult::ReturnVoid\n"),
            Step::If { cond, then_, else_ } => {
              let then_v = variant_name(&[fiber_name, func_name, &then_.0]);
              let else_v = variant_name(&[fiber_name, func_name, &else_.0]);
              let cond_code = render_expr_code(&cond, func);
              out.push_str(&format!(
                "      if {} {{ StepResult::GoTo(State::{}) }} else {{ StepResult::GoTo(State::{}) }}\n",
                cond_code, then_v, else_v
              ));
            }
            Step::Let { local, expr, next } => {
              let next_v = variant_name(&[fiber_name, func_name, &next.0]);
              // Set a local by pushing a value of the underlying type. Runtime will bind it.
              let lty = var_type_of(func, local).expect("unknown local var in Let");
              let vname = type_variant_name(lty);
              let expr_code = render_expr_code(&expr, func);
              out.push_str("      StepResult::Next(vec![\n");
              out.push_str(&format!(
                "        StackEntry::Value(\"{}\".to_string(), Value::{}({})),\n",
                local, vname, expr_code
              ));
              out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
              out.push_str("      ])\n");
            }
            Step::HeapGetIndex { array, index, bind, next } => {
              // Update existing local `bind` in-place via Return-binding (no new stack vars)
              let next_v = variant_name(&[fiber_name, func_name, &next.0]);
              let idx_code = render_expr_code(&index, func);
              let heap_variant = pascal_case(fiber_name);
              let heap_field = camel_ident(array);
              let ety = heap_array_elem_type(ir, fiber_name, array).expect("heap array type not found");

              // Compute offset to the bind variable within the current frame
              let params_len = func.in_vars.len();
              let locals_len = func.locals.len();
              let total_vars = params_len + locals_len;
              let var_index = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == bind.as_str()) {
                Some(pi)
              } else if let Some(li) = func.locals.iter().position(|l| l.0 == bind.as_str()) {
                Some(params_len + li)
              } else {
                None
              };
              let bind_offset = if let Some(var_ind) = var_index { (total_vars + 1) - var_ind } else { 0 };

              match ety {
                Type::UInt64 => {
                  // Use global::add(a, 0) to propagate value via Return + Retrn(Some(offset)), with proper callee locals
                  let add_entry = variant_name(&["global", "add", "entry"]);
                  out.push_str("      StepResult::Next(vec![\n");
                  out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
                  out.push_str(&format!("        StackEntry::Retrn(Some({})),\n", bind_offset));
                  out.push_str(&format!(
                      "        StackEntry::Value(\"a\".to_string(), Value::U64(match heap {{ Heap::{}(h) => h.{}[({} as usize)].clone(), _ => unreachable!() }})),\n",
                      heap_variant, heap_field, idx_code
                    ));
                  out.push_str("        StackEntry::Value(\"b\".to_string(), Value::U64(0u64)),\n");
                  out.push_str("        StackEntry::Value(\"sum\".to_string(), Value::U64(0u64)),\n");
                  out.push_str(&format!("        StackEntry::State(State::{}),\n", add_entry));
                  out.push_str("      ])\n");
                }
                _ => {
                  // Directly stage the read value into the local `bind` (non-u64)
                  let vname = type_variant_name(ety);
                  out.push_str("      StepResult::Next(vec![\n");
                  out.push_str(&format!(
                      "        StackEntry::Value(\"{}\".to_string(), Value::{}(match heap {{ Heap::{}(h) => h.{}[({} as usize)].clone(), _ => unreachable!() }})),\n",
                      bind, vname, heap_variant, heap_field, idx_code
                    ));
                  out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
                  out.push_str("      ])\n");
                }
              }
            }
            Step::RustBlock { binds, next, code: rcode } => {
              let next_v = variant_name(&[fiber_name, func_name, &next.0]);
              let mut bind_types: Vec<&Type> = Vec::new();
              for b in binds {
                bind_types.push(var_type_of(func, b).expect("bind var type"));
              }
              if bind_types.len() == 1 {
                // Optimization: if next step is `Return { value: Var(binds[0]) }`, return directly
                let direct_return = func
                  .steps
                  .iter()
                  .find(|(sid, _)| sid.0 == next.0)
                  .and_then(|(_, st)| if let Step::Return { value } = st { Some(value) } else { None })
                  .and_then(|rv| if let RetValue::Var(vn) = rv { Some(vn) } else { None })
                  .map(|vn| vn == &binds[0])
                  .unwrap_or(false);
                if direct_return {
                  let ty_name = type_variant_name(bind_types[0]);
                  out.push_str("      { let out = {\n");
                  out.push_str(rcode);
                  out.push_str("\n      }; ");
                  out.push_str(&format!("StepResult::Return(Value::{}(out)) }}\n", ty_name));
                } else {
                  // Single bind: assign directly into the current frame using offset
                  let ty_name = type_variant_name(bind_types[0]);
                  let bname = binds.get(0).unwrap();
                  let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == bname.as_str()) {
                    format!("{}", pi)
                  } else if let Some(li) = func.locals.iter().position(|l| l.0 == bname.as_str()) {
                    format!("{}", func.in_vars.len() + li)
                  } else {
                    "0".to_string()
                  };
                  out.push_str("      { let out = {\n");
                  out.push_str(rcode);
                  out.push_str("\n      }; StepResult::Next(vec![\n");
                  out.push_str(&format!(
                    "          StackEntry::FrameAssign(vec![( {}, Value::{}(out) )]),\n",
                    pos_expr, ty_name
                  ));
                  out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
                }
              } else {
                out.push_str("      { let out = {\n");
                out.push_str(rcode);
                out.push_str("\n      };\n");
                let tuple_names: Vec<String> = (0..bind_types.len()).map(|i| format!("o{}", i)).collect();
                out.push_str(&format!(
                  "        let ({}) = out;\n        StepResult::Next(vec![\n",
                  tuple_names.join(", ")
                ));
                // Build FrameAssign with all bind updates
                out.push_str("          StackEntry::FrameAssign(vec![\n");
                for (i, b) in binds.iter().enumerate() {
                  let ty_name = type_variant_name(bind_types[i]);
                  let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == b.as_str()) {
                    format!("{}", pi)
                  } else if let Some(li) = func.locals.iter().position(|l| l.0 == b.as_str()) {
                    format!("{}", func.in_vars.len() + li)
                  } else {
                    "0".to_string()
                  };
                  out.push_str(&format!("            ( {}, Value::{}({}) ),\n", pos_expr, ty_name, tuple_names[i]));
                }
                out.push_str("          ]),\n");
                out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
              }
            }
          }
        } else {
          // Default: nothing special, fall back to a no-op transition.
          out.push_str(&format!("      StepResult::GoTo(State::{})\n", &entry_variant));
        }

        out.push_str("    }\n");
      }
      let mut steps_sorted: Vec<(&StepId, &Step)> = func.steps.iter().map(|(id, st)| (id, st)).collect();
      steps_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));
      for (step_id, step) in steps_sorted {
        if suppressed.contains(&step_id.0) {
          continue;
        }
        let state_variant = variant_name(&[fiber_name, func_name, &step_id.0]);
        if !seen.insert(state_variant.clone()) {
          continue;
        }
        let mut referenced: BTreeSet<String> = BTreeSet::new();
        match step {
          Step::Sleep { ms, .. } => collect_vars_from_expr(&ms, &mut referenced),
          Step::Write { text, .. } => collect_vars_from_expr(&text, &mut referenced),
          Step::SendToFiber { args, .. } => {
            for (_, e) in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::Await(_) => {}
          Step::Select { arms: _ } => {}
          Step::Call { args, .. } => {
            for e in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::Return { value } => collect_vars_from_retvalue(value, &mut referenced),
          Step::ReturnVoid => {}
          Step::If { cond, .. } => collect_vars_from_expr(&cond, &mut referenced),
          Step::Let { expr, .. } => collect_vars_from_expr(&expr, &mut referenced),
          Step::HeapGetIndex { index, .. } => collect_vars_from_expr(&index, &mut referenced),
          Step::RustBlock { .. } => {
            for p in &func.in_vars {
              referenced.insert(p.0.to_string());
            }
            for l in &func.locals {
              referenced.insert(l.0.to_string());
            }
          }
        }
        out.push_str(&format!("    State::{state_variant} => {{\n"));
        for var_name in referenced.iter() {
          if let Some(ty) = var_type_of(func, var_name) {
            let rust_ty = rust_type(ty);
            let tname = type_variant_name(ty);
            let local_ident = camel_ident(var_name);
            if var_is_param(func, var_name) {
              if let Some(pos) = func.in_vars.iter().position(|p| p.0 == var_name.as_str()) {
                out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(_, Value::{tname}(x)) = &vars[{pos}] {{ x.clone() }} else {{ unreachable!() }};\n"));
              }
            } else {
              if let Some(pos) = func.locals.iter().position(|l| l.0 == var_name.as_str()) {
                let idx = func.in_vars.len() + pos;
                out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(_, Value::{tname}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }};\n"));
              }
            }
          } else {
            out.push_str(&format!("      // NOTE: Referenced variable '{var_name}' not found among params/locals.\n"));
          }
        }
        match step {
          Step::Sleep { ms, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let ms_code = render_expr_code(&ms, func);
            out.push_str(&format!("      StepResult::Sleep({}, State::{})\n", ms_code, next_v));
          }
          Step::Write { text, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let text_code = render_expr_code(&text, func);
            out
              .push_str(&format!("      StepResult::Write(format!(\"{}\", {}), State::{})\n", "{}", text_code, next_v));
          }
          Step::SendToFiber { next, .. } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
          }
          Step::Await(spec) => {
            let next_v = variant_name(&[fiber_name, func_name, &spec.ret_to.0]);
            out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
          }
          Step::Select { arms } => {
            let mut arm_states: Vec<String> = Vec::new();
            for arm in arms {
              arm_states.push(variant_name(&[fiber_name, func_name, &arm.ret_to.0]));
            }
            out.push_str("      StepResult::Select(vec![");
            for (i, st) in arm_states.iter().enumerate() {
              if i > 0 {
                out.push_str(", ");
              }
              out.push_str(&format!("State::{}", st));
            }
            out.push_str("])\n");
          }
          Step::Call { target, args, ret_to, bind } => {
            out.push_str(&render_call_step(ir, fiber_name, func_name, func, target, args, ret_to, bind));
          }
          Step::Return { value } => {
            let code = render_ret_value(value, &func.out, func);
            out.push_str(&format!("      StepResult::Return(Value::{}({}))\n", type_variant_name(&func.out), code));
          }
          Step::ReturnVoid => out.push_str("      StepResult::ReturnVoid\n"),
          Step::If { cond, then_, else_, .. } => {
            let then_v = variant_name(&[fiber_name, func_name, &then_.0]);
            let else_v = variant_name(&[fiber_name, func_name, &else_.0]);
            let cond_code = render_expr_code(&cond, func);
            out.push_str(&format!(
              "      if {} {{ StepResult::GoTo(State::{}) }} else {{ StepResult::GoTo(State::{}) }}\n",
              cond_code, then_v, else_v
            ));
          }
          Step::Let { local, expr, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let lty = var_type_of(func, local).expect("unknown local var in Let");
            let vname = type_variant_name(lty);
            let expr_code = render_expr_code(&expr, func);
            out.push_str("      StepResult::Next(vec![\n");
            out.push_str(&format!(
              "        StackEntry::Value(\"{}\".to_string(), Value::{}({})),\n",
              local, vname, expr_code
            ));
            out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
            out.push_str("      ])\n");
          }
          Step::HeapGetIndex { array, index, bind, next } => {
            // Update existing local `bind` in-place via Return-binding (no new stack vars)
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let idx_code = render_expr_code(&index, func);
            let heap_variant = pascal_case(fiber_name);
            let heap_field = camel_ident(array);
            let ety = heap_array_elem_type(ir, fiber_name, array).expect("heap array type not found");

            // Compute offset to the bind variable within the current frame
            let params_len = func.in_vars.len();
            let locals_len = func.locals.len();
            let total_vars = params_len + locals_len;
            let var_index = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == bind.as_str()) {
              Some(pi)
            } else if let Some(li) = func.locals.iter().position(|l| l.0 == bind.as_str()) {
              Some(params_len + li)
            } else {
              None
            };
            let bind_offset = if let Some(var_ind) = var_index { (total_vars + 1) - var_ind } else { 0 };

            match ety {
              Type::UInt64 => {
                // Use global::add(a, 0) to propagate value via Return + Retrn(Some(offset)) with callee locals
                let add_entry = variant_name(&["global", "add", "entry"]);
                out.push_str("      StepResult::Next(vec![\n");
                out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
                out.push_str(&format!("        StackEntry::Retrn(Some({})),\n", bind_offset));
                out.push_str(&format!(
                  "        StackEntry::Value(\"a\".to_string(), Value::U64(match heap {{ Heap::{}(h) => h.{}[({} as usize)].clone(), _ => unreachable!() }})),\n",
                  heap_variant, heap_field, idx_code
                ));
                out.push_str("        StackEntry::Value(\"b\".to_string(), Value::U64(0u64)),\n");
                out.push_str("        StackEntry::Value(\"sum\".to_string(), Value::U64(0u64)),\n");
                out.push_str(&format!("        StackEntry::State(State::{}),\n", add_entry));
                out.push_str("      ])\n");
              }
              _ => {
                // Fallback to previous behavior for non-u64 (can be extended later)
                let vname = type_variant_name(ety);
                out.push_str("      StepResult::Next(vec![\n");
                out.push_str(&format!(
                  "        StackEntry::Value(\"{}\".to_string(), Value::{}(match heap {{ Heap::{}(h) => h.{}[({} as usize)].clone(), _ => unreachable!() }})),\n",
                  bind, vname, heap_variant, heap_field, idx_code
                ));
                out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
                out.push_str("      ])\n");
              }
            }
          }
          Step::RustBlock { binds, next, code: rcode } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            // Types by bind order
            let mut bind_types: Vec<&Type> = Vec::new();
            for b in binds {
              bind_types.push(var_type_of(func, b).expect("bind var type"));
            }
            if bind_types.len() == 1 {
              // Optimization: if next step is Return of the bound var, just return it
              let direct_return = func
                .steps
                .iter()
                .find(|(sid, _)| sid.0 == next.0)
                .and_then(|(_, st)| if let Step::Return { value } = st { Some(value) } else { None })
                .and_then(|rv| if let RetValue::Var(vn) = rv { Some(vn) } else { None })
                .map(|vn| vn == &binds[0])
                .unwrap_or(false);
              if direct_return {
                let ty_name = type_variant_name(bind_types[0]);
                out.push_str("      { let out = {\n");
                out.push_str(rcode);
                out.push_str("\n      }; ");
                out.push_str(&format!("StepResult::Return(Value::{}(out)) }}\n", ty_name));
              } else {
                // Single bind: assign directly into the current frame using offset
                let ty_name = type_variant_name(bind_types[0]);
                let bname = binds.get(0).unwrap();
                let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == bname.as_str()) {
                  format!("{}", pi)
                } else if let Some(li) = func.locals.iter().position(|l| l.0 == bname.as_str()) {
                  format!("{}", func.in_vars.len() + li)
                } else {
                  "0".to_string()
                };
                out.push_str("      { let out = {\n");
                out.push_str(rcode);
                out.push_str("\n      }; StepResult::Next(vec![\n");
                out.push_str(&format!(
                  "          StackEntry::FrameAssign(vec![( {}, Value::{}(out) )]),\n",
                  pos_expr, ty_name
                ));
                out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
              }
            } else {
              out.push_str("      { let out = {\n");
              out.push_str(rcode);
              out.push_str("\n      };\n");
              let tuple_names: Vec<String> = (0..bind_types.len()).map(|i| format!("o{}", i)).collect();
              out.push_str(&format!(
                "        let ({}) = out;\n        StepResult::Next(vec![\n",
                tuple_names.join(", ")
              ));
              out.push_str("          StackEntry::FrameAssign(vec![\n");
              for (i, b) in binds.iter().enumerate() {
                let ty_name = type_variant_name(bind_types[i]);
                let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == b.as_str()) {
                  format!("{}", pi)
                } else if let Some(li) = func.locals.iter().position(|l| l.0 == b.as_str()) {
                  format!("{}", func.in_vars.len() + li)
                } else {
                  "0".to_string()
                };
                out.push_str(&format!("            ( {}, Value::{}({}) ),\n", pos_expr, ty_name, tuple_names[i]));
              }
              out.push_str("          ]),\n");
              out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
            }
          }
        }
        out.push_str("    }\n");
      }
    }
  }

  out.push_str("  }\n}\n");
  out
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::collections::HashMap;

  #[test]
  fn generates_types() {
    let ir = IR {
      types: vec![Type::Struct(
        "User".into(),
        vec![StructField { name: "id".into(), ty: Type::String }, StructField { name: "age".into(), ty: Type::UInt64 }],
      )],
      fibers: HashMap::from([
        (
          "userManager".into(),
          Fiber {
            heap: HashMap::from([(
              "users".into(),
              Type::Map(Box::new(Type::String), Box::new(Type::Custom("User".into()))),
            )]),
            in_messages: vec![MessageSpec("GetUser", vec![("key", Type::String)])],
            funcs: HashMap::from([(
              "get".into(),
              Func {
                in_vars: vec![InVar("key", Type::String)],
                out: Type::Option(Box::new(Type::Custom("User".into()))),
                locals: vec![],
                entry: StepId::new("entry"),
                steps: vec![(StepId::new("entry"), Step::ReturnVoid)],
              },
            )]),
          },
        ),
        ("global".into(), Fiber { heap: HashMap::new(), in_messages: vec![], funcs: HashMap::new() }),
      ]),
    };

    let code = generate_rust_types(&ir);
    // Spot-check a few important bits are present.
    assert!(code.contains("pub struct User"));
    assert!(code.contains("pub struct UserManagerGetUserMsg"));
    assert!(code.contains("pub enum Heap"));
    assert!(code.contains("pub enum State"));
    assert!(code.contains("UserManagerGetEntry"));
    assert!(code.contains("pub enum Value"));
    // With compact-by-type Value enum, we expect used types only
    assert!(code.contains("String(String)"));
    assert!(code.contains("OptionUser(Option<User>)"));
  }
}
