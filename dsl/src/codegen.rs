use crate::ir::*;

fn rust_type(t: &Type) -> String {
  match t {
    Type::Int => "u64".into(),
    Type::String => "String".into(),
    Type::Void => "()".into(),
    Type::Map(k, v) => format!("std::collections::HashMap<{}, {}>", rust_type(k), rust_type(v)),
    Type::Array(t) => format!("Vec<{}>", rust_type(t)),
    Type::Struct(name, _) => pascal_case(name),
    Type::Option(t) => format!("Option<{}>", rust_type(t)),
    Type::Custom(name) => pascal_case(name),
  }
}

fn pascal_case(raw: &str) -> String {
  let s = raw.to_string();
  if s.contains('_') {
    let mut out = String::new();
    for part in s.split('_') {
      if part.is_empty() {
        continue;
      }
      let mut chars = part.chars();
      if let Some(f) = chars.next() {
        out.push(f.to_ascii_uppercase());
        for ch in chars {
          out.push(ch.to_ascii_lowercase());
        }
      }
    }
    if out.is_empty() { "_".to_string() } else { out }
  } else {
    // Already in one word, likely camelCase or ALLCAPS. Uppercase first, keep rest as-is to preserve camel.
    let mut chars = s.chars();
    match chars.next() {
      None => "_".to_string(),
      Some(f) => f.to_ascii_uppercase().to_string() + chars.as_str(),
    }
  }
}

fn camel_ident(raw: &str) -> String {
  let p = pascal_case(raw);
  let mut c = p.chars();
  match c.next() {
    None => String::new(),
    Some(f) => f.to_ascii_lowercase().to_string() + c.as_str(),
  }
}

fn variant_name(parts: &[&str]) -> String {
  parts.iter().map(|p| pascal_case(p)).collect::<Vec<_>>().join("")
}

pub fn generate_rust_types(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("// Generated by dsl::codegen from IR\n");
  out.push_str("#![allow(dead_code)]\n\n");

  // 1) Emit custom struct types declared at top-level IR.types
  for t in &ir.types {
    if let Type::Struct(name, fields) = t {
      out.push_str(&format!("#[derive(Clone, Debug)]\npub struct {} {{\n", pascal_case(name)));
      for f in fields {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(&f.name), rust_type(&f.ty)));
      }
      out.push_str("}\n\n");
    }
  }

  // 2) Emit message structs per fiber.in_messages (sorted by fiber, then message name)
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.name.cmp(&b.name));
    for msg in &msgs {
      let msg_ty = variant_name(&[fiber_name, &msg.name, "Msg"]);
      out.push_str(&format!("#[derive(Clone, Debug)]\npub struct {} {{\n", msg_ty));
      let mut fields_sorted = msg.fields.clone();
      fields_sorted.sort_by(|a, b| a.0.cmp(&b.0));
      for (fname, fty) in &fields_sorted {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(fname), rust_type(fty)));
      }
      out.push_str("}\n\n");
    }
  }

  // 3) Emit per-fiber heap structs and a unified Heap enum
  let mut heap_variants: Vec<(String, String)> = Vec::new();
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let heap_struct = variant_name(&[fiber_name, "Heap"]);
    out.push_str(&format!("#[derive(Clone, Debug, Default)]\npub struct {} {{\n", heap_struct));
    let mut heap_fields: Vec<(&String, &Type)> = fiber.heap.iter().collect();
    heap_fields.sort_by(|a, b| a.0.cmp(b.0));
    for (name, ty) in heap_fields {
      out.push_str(&format!("  pub {}: {},\n", camel_ident(name), rust_type(ty)));
    }
    out.push_str("}\n\n");
    heap_variants.push((pascal_case(fiber_name), heap_struct));
  }
  out.push_str("#[derive(Clone, Debug)]\npub enum Heap {\n");
  if heap_variants.is_empty() {
    out.push_str("  Empty,\n");
  } else {
    heap_variants.sort_by(|a, b| a.0.cmp(&b.0));
    for (variant, struct_name) in heap_variants {
      out.push_str(&format!("  {}({}),\n", variant, struct_name));
    }
  }
  out.push_str("}\n\n");

  // 4) Emit State enum variants for all steps of all funcs (always include entry).
  out.push_str("#[derive(Clone, Debug)]\npub enum State {\n");
  // Always include `Completed` and `Idle` as catch-alls to mirror runtime expectations.
  out.push_str("  Completed,\n  Idle,\n");
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      let mut steps: Vec<String> = Vec::new();
      steps.push(func.entry.0.clone());
      for (step_id, _step) in &func.steps {
        steps.push(step_id.0.clone());
      }
      steps.sort();
      steps.dedup();
      for s in steps {
        let v = variant_name(&[fiber_name, func_name, &s]);
        out.push_str(&format!("  {},\n", v));
      }
    }
  }
  out.push_str("}\n\n");

  // 5) Emit Value enum for function params, locals, and function return values.
  out.push_str("#[derive(Clone, Debug)]\npub enum Value {\n");
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      // Params
      for p in &func.in_vars {
        let v = variant_name(&[fiber_name, func_name, "Param", &p.name]);
        out.push_str(&format!("  {}({}),\n", v, rust_type(&p.type_)));
      }
      // Locals
      let mut locals_sorted = func.locals.clone();
      locals_sorted.sort_by(|a, b| a.name.cmp(&b.name));
      for l in &locals_sorted {
        let v = variant_name(&[fiber_name, func_name, "Local", &l.name]);
        out.push_str(&format!("  {}({}),\n", v, rust_type(&l.type_)));
      }
      // Return value
      let ret_v = variant_name(&[fiber_name, func_name, "Return"]);
      out.push_str(&format!("  {}({}),\n", ret_v, rust_type(&func.out)));
    }
  }
  // Also include message payload typed wrappers, which can be handy on stacks.
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.name.cmp(&b.name));
    for msg in &msgs {
      let mut fields_sorted = msg.fields.clone();
      fields_sorted.sort_by(|a, b| a.0.cmp(&b.0));
      for (fname, fty) in &fields_sorted {
        let v = variant_name(&[fiber_name, &msg.name, "Field", fname]);
        out.push_str(&format!("  {}({}),\n", v, rust_type(fty)));
      }
    }
  }
  out.push_str("}\n\n");

  // 6) Emit runtime-aligned scaffolding types and global_step
  out.push_str(
    r"
#[derive(Clone, Debug)]
pub enum StackEntry {
  State(State),
  Retrn(State),
  Value(Value),
}

#[derive(Clone, Debug)]
pub enum StepResult {
  Done,
  Next(Vec<StackEntry>),
  Sleep(u64, State),
  Write(String, State),
  GoTo(State),
  Branch { then_: State, else_: State },
  Select(Vec<State>),
  Return(Option<Value>),
  Todo(String),
}",
  );

  out.push_str(&generate_global_step(ir));

  out
}

use std::collections::BTreeSet;

fn collect_vars_from_expr(
  expr: &Expr,
  acc: &mut BTreeSet<String>,
) {
  match expr {
    Expr::Int(_) | Expr::Str(_) => {}
    Expr::Var(name) => {
      acc.insert(name.clone());
    }
    Expr::Equal(a, b) => {
      collect_vars_from_expr(a, acc);
      collect_vars_from_expr(b, acc);
    }
    Expr::IsSome(e) | Expr::Unwrap(e) => collect_vars_from_expr(e, acc),
    Expr::GetField(e, _) => collect_vars_from_expr(e, acc),
    Expr::StructUpdate { base, updates } => {
      collect_vars_from_expr(base, acc);
      for (_, e) in updates {
        collect_vars_from_expr(e, acc);
      }
    }
  }
}

fn var_type_of<'a>(
  func: &'a Func,
  name: &str,
) -> Option<&'a Type> {
  for p in &func.in_vars {
    if p.name == name {
      return Some(&p.type_);
    }
  }
  for l in &func.locals {
    if l.name == name {
      return Some(&l.type_);
    }
  }
  None
}

fn var_is_param(
  func: &Func,
  name: &str,
) -> bool {
  func.in_vars.iter().any(|p| p.name == name)
}

fn render_expr_code(
  expr: &Expr,
  _func: &Func,
) -> String {
  match expr {
    Expr::Int(x) => format!("{}u64", x),
    Expr::Str(s) => format!("\"{}\".to_string()", s.replace('"', "\\\"")),
    Expr::Var(name) => camel_ident(name),
    Expr::Equal(a, b) => format!("(({}) == ({}))", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::IsSome(e) => format!("({}).is_some()", render_expr_code(e, _func)),
    Expr::Unwrap(e) => format!("({}).unwrap()", render_expr_code(e, _func)),
    Expr::GetField(e, field) => format!("({}).{}", render_expr_code(e, _func), camel_ident(field)),
    Expr::StructUpdate { base, updates } => {
      let mut s = format!("{{ let mut tmp = ({}).clone(); ", render_expr_code(base, _func));
      for (fname, fexpr) in updates {
        s.push_str(&format!("tmp.{} = ({}); ", camel_ident(fname), render_expr_code(fexpr, _func)));
      }
      s.push_str("tmp }");
      s
    }
  }
}

fn find_func<'a>(
  ir: &'a IR,
  fiber: &str,
  func: &str,
) -> Option<&'a Func> {
  ir.fibers.get(fiber).and_then(|f| f.funcs.get(func))
}

fn generate_global_step(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("pub fn global_step(state: State, vars: &Vec<Value>, _heap: &mut Heap) -> StepResult {\n");
  out.push_str("  match state {\n");
  out.push_str("    State::Completed => StepResult::Done,\n");
  out.push_str("    State::Idle => StepResult::Done,\n");
  let mut fibers_sorted: Vec<(&String, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.cmp(b.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      use std::collections::BTreeSet;
      let mut seen: BTreeSet<String> = BTreeSet::new();
      let entry_variant = variant_name(&[fiber_name, func_name, &func.entry.0]);
      if seen.insert(entry_variant.clone()) {
        out.push_str(&format!("    State::{entry_variant} => {{\n"));
        out.push_str("      // Entry state â€” typically a dispatcher or initial decision.\n");
        out.push_str("      StepResult::GoTo(State::");
        out.push_str(&entry_variant);
        out.push_str(")\n");
        out.push_str("    }\n");
      }
      let mut steps_sorted: Vec<(&StepId, &Step)> = func.steps.iter().map(|(id, st)| (id, st)).collect();
      steps_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));
      for (step_id, step) in steps_sorted {
        let state_variant = variant_name(&[fiber_name, func_name, &step_id.0]);
        if !seen.insert(state_variant.clone()) {
          continue;
        }
        let mut referenced: BTreeSet<String> = BTreeSet::new();
        match step {
          Step::Sleep { ms, .. } => collect_vars_from_expr(&ms, &mut referenced),
          Step::Write { text, .. } => collect_vars_from_expr(&text, &mut referenced),
          Step::SendToFiber { args, .. } => {
            for (_, e) in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::Await(_) => {}
          Step::Select { arms: _ } => {}
          Step::Call { args, .. } => {
            for e in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::Return { value } => {
            if let Some(e) = value {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::If { cond, .. } => collect_vars_from_expr(&cond, &mut referenced),
          Step::Let { expr, .. } => collect_vars_from_expr(&expr, &mut referenced),
        }
        out.push_str(&format!("    State::{state_variant} => {{\n"));
        for var_name in referenced.iter() {
          if let Some(ty) = var_type_of(func, var_name) {
            let variant = if var_is_param(func, var_name) {
              variant_name(&[fiber_name, func_name, "Param", var_name])
            } else {
              variant_name(&[fiber_name, func_name, "Local", var_name])
            };
            let rust_ty = rust_type(ty);
            let local_ident = camel_ident(var_name);
            out.push_str(&format!("      let {local_ident}: {rust_ty} = vars.iter().find_map(|v| if let Value::{variant}(x) = v {{ Some(x.clone()) }} else {{ None }}).expect(\"Missing variable {variant} on stack\");\n"));
          } else {
            out.push_str(&format!("      // NOTE: Referenced variable '{var_name}' not found among params/locals.\n"));
          }
        }
        match step {
          Step::Sleep { ms, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let ms_code = render_expr_code(&ms, func);
            out.push_str(&format!("      StepResult::Sleep({}, State::{})\n", ms_code, next_v));
          }
          Step::Write { text, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let text_code = render_expr_code(&text, func);
            out
              .push_str(&format!("      StepResult::Write(format!(\"{}\", {}), State::{})\n", "{}", text_code, next_v));
          }
          Step::SendToFiber { next, .. } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
          }
          Step::Await(spec) => {
            let next_v = variant_name(&[fiber_name, func_name, &spec.ret_to.0]);
            out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
          }
          Step::Select { arms } => {
            let mut arm_states: Vec<String> = Vec::new();
            for arm in arms {
              arm_states.push(variant_name(&[fiber_name, func_name, &arm.ret_to.0]));
            }
            out.push_str("      StepResult::Select(vec![");
            for (i, st) in arm_states.iter().enumerate() {
              if i > 0 {
                out.push_str(", ");
              }
              out.push_str(&format!("State::{}", st));
            }
            out.push_str("])\n");
          }
          Step::Call { target, args, ret_to, .. } => {
            let ret_state = variant_name(&[fiber_name, func_name, &ret_to.0]);
            if let Some(callee) = find_func(ir, &target.fiber, &target.func) {
              out.push_str("      StepResult::Next(vec![\n");
              out.push_str(&format!("        StackEntry::Retrn(State::{}),\n", ret_state));
              for (idx, p) in callee.in_vars.iter().enumerate() {
                if let Some(arg) = args.get(idx) {
                  let vname = variant_name(&[&target.fiber, &target.func, "Param", &p.name]);
                  let expr_code = render_expr_code(&arg, func);
                  out.push_str(&format!("        StackEntry::Value(Value::{}({})),\n", vname, expr_code));
                }
              }
              let callee_entry = variant_name(&[&target.fiber, &target.func, &callee.entry.0]);
              out.push_str(&format!("        StackEntry::State(State::{}),\n", callee_entry));
              out.push_str("      ])\n");
            } else {
              out.push_str(&format!("      StepResult::GoTo(State::{})\n", ret_state));
            }
          }
          Step::Return { value } => {
            if let Some(val) = value {
              let vname = variant_name(&[fiber_name, func_name, "Return"]);
              let expr_code = render_expr_code(&val, func);
              out.push_str(&format!("      StepResult::Return(Some(Value::{}({})))\n", vname, expr_code));
            } else {
              out.push_str("      StepResult::Return(None)\n");
            }
          }
          Step::If { then_, else_, .. } => {
            let then_v = variant_name(&[fiber_name, func_name, &then_.0]);
            let else_v = variant_name(&[fiber_name, func_name, &else_.0]);
            out.push_str(&format!(
              "      StepResult::Branch {{ then_: State::{}, else_: State::{} }}\n",
              then_v, else_v
            ));
          }
          Step::Let { local, expr, next } => {
            let next_v = variant_name(&[fiber_name, func_name, &next.0]);
            let vname = variant_name(&[fiber_name, func_name, "Local", &local]);
            let expr_code = render_expr_code(&expr, func);
            out.push_str("      StepResult::Next(vec![\n");
            out.push_str(&format!("        StackEntry::Value(Value::{}({})),\n", vname, expr_code));
            out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
            out.push_str("      ])\n");
          }
        }
        out.push_str("    }\n");
      }
    }
  }

  out.push_str("  }\n}\n");
  out
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::collections::HashMap;

  #[test]
  fn generates_types() {
    let ir = IR {
      types: vec![Type::Struct(
        "User".into(),
        vec![StructField { name: "id".into(), ty: Type::String }, StructField { name: "age".into(), ty: Type::Int }],
      )],
      fibers: HashMap::from([
        (
          "userManager".into(),
          Fiber {
            heap: HashMap::from([(
              "users".into(),
              Type::Map(Box::new(Type::String), Box::new(Type::Custom("User".into()))),
            )]),
            in_messages: vec![MessageSpec { name: "GetUser".into(), fields: vec![("key".into(), Type::String)] }],
            funcs: HashMap::from([(
              "get".into(),
              Func {
                in_vars: vec![InVar { name: "key".into(), type_: Type::String }],
                out: Type::Option(Box::new(Type::Custom("User".into()))),
                locals: vec![],
                entry: StepId::new("entry"),
                steps: vec![(StepId::new("entry"), Step::Return { value: None })],
              },
            )]),
          },
        ),
        ("global".into(), Fiber { heap: HashMap::new(), in_messages: vec![], funcs: HashMap::new() }),
      ]),
    };

    let code = generate_rust_types(&ir);
    // Spot-check a few important bits are present.
    assert!(code.contains("pub struct User"));
    assert!(code.contains("pub struct UserManagerGetUserMsg"));
    assert!(code.contains("pub enum Heap"));
    assert!(code.contains("pub enum State"));
    assert!(code.contains("UserManagerGetEntry"));
    assert!(code.contains("pub enum Value"));
    assert!(code.contains("UserManagerGetParamKey"));
  }
}
