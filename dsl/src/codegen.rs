use crate::ir::*;

fn is_copy_type(t: &Type) -> bool {
  match t {
    Type::UInt64 => true,
    Type::Void => true,
    Type::Option(inner) => is_copy_type(inner),
    // Be conservative by default
    Type::String
    | Type::MaxQueue(_)
    | Type::MinQueue(_)
    | Type::Map(_, _)
    | Type::Array(_)
    | Type::Struct(_, _, _)
    | Type::PubQueueMessage { .. }
    | Type::Future(_)
    | Type::Custom(_) => false,
  }
}

fn type_variant_name(t: &Type) -> String {
  match t {
    Type::UInt64 => "U64".into(),
    Type::String => "String".into(),
    Type::Void => "Unit".into(),
    Type::MaxQueue(inner) => format!("MaxQueue{}", type_variant_name(inner)),
    Type::MinQueue(inner) => format!("MinQueue{}", type_variant_name(inner)),
    Type::Struct(name, _, _) => pascal_case(name),
    Type::PubQueueMessage { name, .. } => pascal_case(name),
    Type::Future(inner) => format!("Future{}", type_variant_name(inner)),
    Type::Custom(name) => pascal_case(name),
    Type::Option(inner) => format!("Option{}", type_variant_name(inner)),
    Type::Array(inner) => format!("Array{}", type_variant_name(inner)),
    Type::Map(k, v) => format!("Map{}To{}", type_variant_name(k), type_variant_name(v)),
  }
}

fn rust_type(t: &Type) -> String {
  match t {
    Type::UInt64 => "u64".into(),
    Type::String => "String".into(),
    Type::Void => "()".into(),
    Type::MaxQueue(inner) => format!("std::collections::BinaryHeap<{}>", rust_type(inner)),
    Type::MinQueue(inner) => format!("std::collections::BinaryHeap<std::cmp::Reverse<{}>>", rust_type(inner)),
    Type::Map(k, v) => format!("std::collections::HashMap<{}, {}>", rust_type(k), rust_type(v)),
    Type::Array(t) => format!("Vec<{}>", rust_type(t)),
    Type::Struct(name, _, _) => pascal_case(name),
    Type::Option(t) => format!("Option<{}>", rust_type(t)),
    Type::PubQueueMessage { name, .. } => pascal_case(name),
    Type::Future(inner) => format!("Future{}", type_variant_name(inner)),
    Type::Custom(name) => pascal_case(name),
  }
}

fn pascal_case(raw: &str) -> String {
  let s = raw.to_string();
  if s.contains('_') {
    let mut out = String::new();
    for part in s.split('_') {
      if part.is_empty() {
        continue;
      }
      let mut chars = part.chars();
      if let Some(f) = chars.next() {
        out.push(f.to_ascii_uppercase());
        for ch in chars {
          out.push(ch.to_ascii_lowercase());
        }
      }
    }
    if out.is_empty() { "_".to_string() } else { out }
  } else {
    // Already in one word, likely camelCase or ALLCAPS. Uppercase first, keep rest as-is to preserve camel.
    let mut chars = s.chars();
    match chars.next() {
      None => "_".to_string(),
      Some(f) => f.to_ascii_uppercase().to_string() + chars.as_str(),
    }
  }
}

fn camel_ident(raw: &str) -> String {
  let p = pascal_case(raw);
  let mut c = p.chars();
  match c.next() {
    None => String::new(),
    Some(f) => f.to_ascii_lowercase().to_string() + c.as_str(),
  }
}

fn variant_name(parts: &[&str]) -> String {
  parts.iter().map(|p| pascal_case(p)).collect::<Vec<_>>().join("")
}

pub fn generate_rust_types(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("// Generated by dsl::codegen from IR\n");
  out.push_str("#![allow(dead_code)]\n");
  out.push_str("#![allow(unused_variables)]\n");
  out.push_str("#![allow(non_snake_case)]\n\n");
  // External deps used throughout the generated file
  out.push_str("use serde::{Serialize, Deserialize};\n");
  out.push_str("use crate::ir::{FiberType, FutureLabel};\n\n");

  // 1) Emit custom struct types declared at top-level IR.types
  // Determine which custom structs need Ord/Eq derives (used inside Min/Max queues)
  use std::collections::BTreeSet as __BTS_NEED_ORD;
  let mut need_ord: __BTS_NEED_ORD<String> = __BTS_NEED_ORD::new();
  for (_fiber_name, fiber) in ir.fibers.iter() {
    for (_hname, hty) in &fiber.heap {
      match hty {
        Type::MinQueue(inner) | Type::MaxQueue(inner) => match inner.as_ref() {
          Type::Custom(n) | Type::Struct(n, _, _) => {
            need_ord.insert(pascal_case(n));
          }
          _ => {}
        },
        _ => {}
      }
    }
  }
  for t in &ir.types {
    match t {
      Type::Struct(name, fields, impl_block) => {
        let ty_name = pascal_case(name);
        // Decide derives based on whether user provided impls
        let ib = impl_block.trim();
        let provides_partial_eq = ib.contains("impl PartialEq") || ib.contains("impl Eq");
        let provides_ord = ib.contains("impl Ord") || ib.contains("impl PartialOrd");
        let derive_partial_eq = !provides_partial_eq;
        let derive_ord = need_ord.contains(&ty_name) && !provides_ord;

        if derive_partial_eq && derive_ord {
          out.push_str(&format!(
            "#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub struct {} {{\n",
            ty_name
          ));
        } else if derive_partial_eq {
          // Derive Eq alongside PartialEq to support Value: Eq
          out.push_str(&format!(
            "#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct {} {{\n",
            ty_name
          ));
        } else {
          out.push_str(&format!(
            "#[derive(Clone, Debug, Default, Serialize, Deserialize)]\npub struct {} {{\n",
            ty_name
          ));
        }
        for f in fields {
          out.push_str(&format!("  pub {}: {},\n", camel_ident(&f.name), rust_type(&f.ty)));
        }
        out.push_str("}\n\n");
        out.push_str(impl_block);
        out.push_str("\n\n");
      }
      Type::PubQueueMessage { name, fields, rust_additions } => {
        // Generate public and private variants for PubQueueMessage
        let ty_pub = format!("{}Pub", pascal_case(name));
        let ty_priv = pascal_case(name);

        // Public variant: all fields except `public_future_id`
        out.push_str(&format!(
          "#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct {} {{\n",
          ty_pub
        ));
        for f in fields.iter().filter(|f| f.name != "public_future_id") {
          out.push_str(&format!("  pub {}: {},\n", camel_ident(&f.name), rust_type(&f.ty)));
        }
        out.push_str("}\n\n");

        // Private variant: includes all fields
        out.push_str(&format!(
          "#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct {} {{\n",
          ty_priv
        ));
        for f in fields {
          out.push_str(&format!("  pub {}: {},\n", camel_ident(&f.name), rust_type(&f.ty)));
        }
        out.push_str("}\n\n");

        // Additional user-provided impls for this type block
        let ib = rust_additions.trim();
        if !ib.is_empty() {
          out.push_str(ib);
          out.push_str("\n\n");
        }
      }
      _ => {}
    }
  }

  // 1.5) Emit wrapper structs for all Future<T> types used anywhere in IR
  use std::collections::BTreeSet as __BTS_FUTS;
  let mut future_wrappers: __BTS_FUTS<String> = __BTS_FUTS::new();
  // Helper to collect wrapper names recursively
  fn collect_future_wrappers(
    ir: &IR,
    ty: &Type,
    acc: &mut std::collections::BTreeSet<String>,
  ) {
    match ty {
      Type::Future(inner) => {
        acc.insert(format!("Future{}", type_variant_name(inner)));
        collect_future_wrappers(ir, inner, acc);
      }
      Type::Option(inner) | Type::Array(inner) | Type::MaxQueue(inner) | Type::MinQueue(inner) => {
        collect_future_wrappers(ir, inner, acc);
      }
      Type::Map(k, v) => {
        collect_future_wrappers(ir, k, acc);
        collect_future_wrappers(ir, v, acc);
      }
      Type::Custom(name) => {
        if let Some(tdef) = ir.types.iter().find(|tt| match tt {
          Type::Struct(n, _, _) if n == name => true,
          Type::PubQueueMessage { name: n, .. } if n == name => true,
          _ => false,
        }) {
          match tdef {
            Type::Struct(_, fields, _) => {
              for f in fields {
                collect_future_wrappers(ir, &f.ty, acc);
              }
            }
            Type::PubQueueMessage { fields, .. } => {
              for f in fields {
                collect_future_wrappers(ir, &f.ty, acc);
              }
            }
            _ => {}
          }
        }
      }
      _ => {}
    }
  }
  // From top-level types
  for t in &ir.types {
    match t {
      Type::Struct(_, fields, _) => {
        for f in fields {
          collect_future_wrappers(ir, &f.ty, &mut future_wrappers);
        }
      }
      Type::PubQueueMessage { fields, .. } => {
        for f in fields {
          collect_future_wrappers(ir, &f.ty, &mut future_wrappers);
        }
      }
      other => collect_future_wrappers(ir, other, &mut future_wrappers),
    }
  }
  // From fibers (params, locals, returns, messages, heap)
  for (_fname, fiber) in ir.fibers.iter() {
    for (_hname, hty) in &fiber.heap {
      collect_future_wrappers(ir, hty, &mut future_wrappers);
    }
    for (_func_name, func) in &fiber.funcs {
      for InVar(_, ty) in &func.in_vars {
        collect_future_wrappers(ir, ty, &mut future_wrappers);
      }
      for LocalVar(_, ty) in &func.locals {
        collect_future_wrappers(ir, ty, &mut future_wrappers);
      }
      collect_future_wrappers(ir, &func.out, &mut future_wrappers);
    }
    for msg in &fiber.in_messages {
      for (_fname, fty) in &msg.1 {
        collect_future_wrappers(ir, fty, &mut future_wrappers);
      }
    }
  }

  for w in future_wrappers.iter() {
    out.push_str(&format!(
      "#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct {}(pub String);\n\n",
      w
    ));
  }

  // 2) Emit message structs per fiber.in_messages (sorted by fiber, then message name)
  let mut fibers_sorted: Vec<(&FiberType, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.0.cmp(&b.0));
    for msg in &msgs {
      let msg_ty = variant_name(&[fiber_name.0.as_str(), &msg.0, "Msg"]);
      out.push_str(&format!("#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct {} {{\n", msg_ty));
      let mut fields_sorted = msg.1.clone();
      fields_sorted.sort_by(|a, b| a.0.cmp(&b.0));
      for (fname, fty) in &fields_sorted {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(fname), rust_type(fty)));
      }
      out.push_str("}\n\n");
    }
  }

  // 3) Emit per-fiber heap structs and a unified Heap enum
  let mut heap_structs: Vec<(String, String)> = Vec::new();
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let heap_struct = variant_name(&[fiber_name.0.as_str(), "Heap"]);
    out.push_str(&format!("#[derive(Clone, Debug, Default)]\npub struct {} {{\n", heap_struct));
    let mut heap_fields: Vec<(&String, &Type)> = fiber.heap.iter().collect();
    heap_fields.sort_by(|a, b| a.0.cmp(b.0));
    for (name, ty) in heap_fields {
      out.push_str(&format!("  pub {}: {},\n", camel_ident(name), rust_type(ty)));
    }
    if !fiber.init_vars.is_empty() {
      let invars_struct = variant_name(&[fiber_name.0.as_str(), "InVars"]);
      out.push_str(&format!("  pub in_vars: {},\n", invars_struct));
    }
    out.push_str("}\n\n");
    if !fiber.init_vars.is_empty() {
      let invars_struct = variant_name(&[fiber_name.0.as_str(), "InVars"]);
      out.push_str(&format!("#[derive(Clone, Debug, Default)]\npub struct {} {{\n", invars_struct));
      let mut init_vars_sorted = fiber.init_vars.clone();
      init_vars_sorted.sort_by(|a, b| a.0.cmp(&b.0));
      for InVar(name, ty) in init_vars_sorted {
        out.push_str(&format!("  pub {}: {},\n", camel_ident(name), rust_type(&ty)));
      }
      out.push_str("}\n\n");
    }
    heap_structs.push((camel_ident(&fiber_name.0), heap_struct));
  }
  // Unified Heap as a struct with all fiber heaps accessible at once
  out.push_str("#[derive(Clone, Debug, Default)]\npub struct Heap {\n");
  heap_structs.sort_by(|a, b| a.0.cmp(&b.0));
  for (field_name, struct_name) in heap_structs {
    out.push_str(&format!("  pub {}: {},\n", field_name, struct_name));
  }
  out.push_str("}\n\n");

  // 4) Emit State enum variants for all steps of all funcs (always include entry).
  out.push_str("#[derive(Clone, Debug, PartialEq, Eq)]\npub enum State {\n");
  // Always include `Completed` and `Idle` as catch-alls to mirror runtime expectations.
  out.push_str("  Completed,\n  Idle,\n");
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      // Identify direct-return RustBlock next steps to suppress from code generation
      use std::collections::BTreeSet as __BTS_CODEGEN;
      let mut suppressed: __BTS_CODEGEN<String> = __BTS_CODEGEN::new();
      for (_sid, st) in &func.steps {
        if let Step::RustBlock { binds, next, .. } = st {
          if binds.len() == 1 {
            if let Some((_, Step::Return { value })) = func.steps.iter().find(|(nsid, _)| nsid.0 == next.0) {
              if let RetValue::Var(vn) = value {
                if vn == &binds[0] {
                  suppressed.insert(next.0.clone());
                }
              }
            }
          }
        }
      }
      // State enum: include entry + all steps except direct-return suppressed ones
      let mut steps: Vec<String> = Vec::new();
      steps.push("entry".to_string());
      for (step_id, step) in &func.steps {
        // Additional safety: suppress direct-return targets even if set calc fails
        let mut suppress_this = suppressed.contains(&step_id.0);
        if !suppress_this {
          if let Step::Return { value } = step {
            if let RetValue::Var(vn) = value {
              let has_direct_rb = func.steps.iter().any(|(_sid2, st2)| match st2 {
                Step::RustBlock { binds, next, .. } => binds.len() == 1 && &binds[0] == vn && next.0 == step_id.0,
                _ => false,
              });
              if has_direct_rb {
                suppress_this = true;
              }
            }
          }
        }
        if !suppress_this {
          steps.push(step_id.0.clone());
        }
      }
      steps.sort();
      steps.dedup();
      for s in steps {
        let v = variant_name(&[fiber_name.0.as_str(), func_name, &s]);
        out.push_str(&format!("  {},\n", v));
      }
    }
  }
  out.push_str("}\n\n");

  // 5) Emit Value enum compacted by Rust types actually used in IR (params, locals, returns, message fields).
  use std::collections::BTreeMap;
  let mut used_types: BTreeMap<String, Type> = BTreeMap::new();
  for (_, fiber) in fibers_sorted.iter() {
    // include init_vars types so Value can carry them
    for InVar(_, ty) in &fiber.init_vars {
      used_types.insert(type_variant_name(ty), ty.clone());
    }
    for (_, func) in fiber.funcs.iter() {
      for p in &func.in_vars {
        let ty = &p.1;
        used_types.insert(type_variant_name(ty), ty.clone());
      }
      for l in &func.locals {
        let ty = &l.1;
        used_types.insert(type_variant_name(ty), ty.clone());
      }
      used_types.insert(type_variant_name(&func.out), func.out.clone());
    }
    let mut msgs = fiber.in_messages.clone();
    msgs.sort_by(|a, b| a.0.cmp(&b.0));
    for msg in &msgs {
      for (_, fty) in &msg.1 {
        used_types.insert(type_variant_name(fty), fty.clone());
      }
    }
  }

  // Ensure Value enum includes both public and private variants for all PubQueueMessage types
  for t in &ir.types {
    if let Type::PubQueueMessage { name, .. } = t {
      let priv_name = pascal_case(name);
      let pub_name = format!("{}Pub", priv_name);
      // Insert/ensure private variant exists (maps to the private struct type)
      used_types.entry(priv_name.clone()).or_insert_with(|| Type::PubQueueMessage {
        name: name.clone(),
        fields: Vec::new(),
        rust_additions: String::new(),
      });
      // Insert public variant referencing a struct with that name so rust_type resolves
      used_types.entry(pub_name.clone()).or_insert_with(|| Type::Struct(pub_name.clone(), Vec::new(), String::new()));
    }
  }

  out.push_str("#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]\npub enum Value {\n");
  for (vname, ty) in used_types.iter() {
    out.push_str(&format!("  {}({}),\n", vname, rust_type(ty)));
  }
  out.push_str("}\n\n");

  // Converters for PubQueueMessage values
  // Convert public -> private with a provided future id
  out.push_str("pub fn pub_to_private(val: Value, future_id: String) -> Value {\n  match val {\n");
  for t in &ir.types {
    if let Type::PubQueueMessage { name, fields, .. } = t {
      let ty_pub = format!("{}Pub", pascal_case(name));
      let ty_priv = pascal_case(name);
      // Copy all non-future fields
      let mut copies: Vec<String> = Vec::new();
      let mut future_assign: Option<String> = None;
      for f in fields {
        if f.name == "public_future_id" {
          match &f.ty {
            Type::String => future_assign = Some("future_id".to_string()),
            Type::Future(inner) => future_assign = Some(format!("Future{}(future_id)", type_variant_name(inner))),
            _ => future_assign = Some("future_id".to_string()),
          }
          continue;
        }
        let idf = camel_ident(&f.name);
        copies.push(format!("{}: m.{}", idf, idf));
      }
      let future_field = camel_ident("public_future_id");
      let future_assign = future_assign.unwrap_or_else(|| "future_id".to_string());
      out.push_str(&format!(
        "    Value::{}(m) => Value::{}({} {{ {} , {}: {} }}),\n",
        ty_pub,
        ty_priv,
        ty_priv,
        copies.join(", "),
        future_field,
        future_assign
      ));
    }
  }
  out.push_str("    _ => panic!(\"pub_to_private is only for PubQueueMessage values\"),\n  }\n}\n\n");

  // Convert private -> public by dropping the future id field
  out.push_str("pub fn private_to_pub(val: Value) -> Value {\n  match val {\n");
  for t in &ir.types {
    if let Type::PubQueueMessage { name, fields, .. } = t {
      let ty_pub = format!("{}Pub", pascal_case(name));
      let ty_priv = pascal_case(name);
      let mut copies: Vec<String> = Vec::new();
      for f in fields.iter().filter(|f| f.name != "public_future_id") {
        let idf = camel_ident(&f.name);
        copies.push(format!("{}: m.{}", idf, idf));
      }
      out.push_str(&format!(
        "    Value::{}(m) => Value::{}({} {{ {} }}),\n",
        ty_priv,
        ty_pub,
        ty_pub,
        copies.join(", ")
      ));
    }
  }
  out.push_str("    _ => panic!(\"private_to_pub is only for PubQueueMessage values\"),\n  }\n}\n\n");

  // 6) Emit runtime-aligned scaffolding types and global_step
  out.push_str(
    r"
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum StackEntry {
  State(State),
  // Option<usize> - local index offset back on stack
  // if it's None - no value will be binded into the local variable of the function that initiated call
  Retrn(Option<usize>),
  Value(String, Value),
  // In-place updates to the current frame (offset -> new Value)
  FrameAssign(Vec<(usize, Value)>),
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum SelectArm {
  Future { future_id: FutureLabel, bind: Option<String>, next: State },
  Queue { queue_name: String, bind: String, next: State },
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum CreatePrimitiveValue {
  Future,
  Queue { name: String, public: bool },
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum SetPrimitiveValue {
  QueueMessage { queue_name: String, value: Value },
  Future { id: String, value: Value },
}

  #[derive(Clone, Debug, PartialEq, Eq)]
  pub enum StepResult {
    Done,
    Next(Vec<StackEntry>),
    ScheduleTimer{ ms: u64, next: State, future_id: FutureLabel },
    GoTo(State),
    Select(Vec<SelectArm>),
    // Atomically create runtime primitives and branch based on outcome.
    Create {
      primitives: Vec<CreatePrimitiveValue>,
      success_next: State,
      success_binds: Vec<String>,
      fail_next: State,
      fail_binds: Vec<String>,
    },
    // Return can carry an optional value to be consumed by the runtime.
    Return(Value),
    ReturnVoid,
    Todo(String),
    // Await a future: (future_id, optional bind_var, next_state)
    Await(FutureLabel, Option<String>, State),
    // Legacy await variant kept for backward compatibility
    AwaitOld(FutureLabel, Option<String>, State),
    // Send a message to a fiber with function and typed args, then continue to `next`.
    SendToFiber { f_type: FiberType, func: String, args: Vec<Value>, next: State, future_id: FutureLabel },
    // Broadcast updates to async primitives (queues/futures) and continue to `next`.
    SetValues { values: Vec<SetPrimitiveValue>, next: State },
    // Debug
    // Print a string message and continue to the provided next state.
  Debug(&'static str, State),
  // Print all current-frame vars in order and continue to next state.
  DebugPrintVars(State),
  // Spawn new fibers (fire-and-forget) and continue to `next`.
  // Runtime may ignore this for now; present for forward-compat.
  CreateFibers { details: Vec<(FiberType, Vec<Value>)>, next: State },
}",
  );

  // Emit helper that tells how many Value entries are on the stack for a given State.
  out.push_str(&generate_func_args_count(ir));

  out.push_str(&generate_global_step(ir));

  // Emit helpers to prepare initial stack/heap and extract result
  out.push_str(&generate_prepare_and_result_helpers(ir));

  // Emit helpers to initialize Heap from fiber init_vars
  out.push_str(&generate_heap_init_helpers(ir));

  out
}

fn generate_prepare_and_result_helpers(ir: &IR) -> String {
  let mut out = String::new();

  // Iterate fibers and functions deterministically
  let mut fibers_sorted: Vec<(&FiberType, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));

  // Registry typedefs
  out.push_str("\n// Registry: function key -> (prepare_from_values, result_to_value)\n");
  out.push_str("pub type PrepareFn = fn(Vec<Value>) -> Vec<StackEntry>;\n");
  out.push_str("pub type ResultFn = fn(&[StackEntry]) -> Value;\n\n");

  // Collect match arms for registries as we go
  let mut prepare_arms: Vec<String> = Vec::new();
  let mut result_arms: Vec<String> = Vec::new();

  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));

    for (func_name, func) in funcs_sorted {
      // Prepare function signature
      let prepare_fn_name = format!("{}_prepare_{}", camel_ident(&fiber_name.0), camel_ident(func_name));
      let mut params: Vec<String> = Vec::new();
      for p in &func.in_vars {
        let name = p.0;
        let ty = &p.1;
        params.push(format!("{}: {}", camel_ident(name), rust_type(ty)));
      }

      // Return type always: (Vec<StackEntry>, Heap)
      out.push_str(&format!("pub fn {}({}) -> (Vec<StackEntry>, Heap) {{\n", prepare_fn_name, params.join(", ")));
      out.push_str("  let mut stack: Vec<StackEntry> = Vec::new();\n");

      // 1) Push continuation marker. For non-void, also push placeholder for return value.
      let ret_vname = type_variant_name(&func.out);
      let ret_default = default_value_expr(&func.out);
      if !matches!(&func.out, Type::Void) {
        out.push_str(&format!(
          "  stack.push(StackEntry::Value(\"ret\".to_string(), Value::{}({})));\n",
          ret_vname, ret_default
        ));
      }
      out.push_str("  stack.push(StackEntry::Retrn(Some(1)));\n");

      // 2) Push input params in order
      for p in &func.in_vars {
        let name = p.0;
        let ty = &p.1;
        let vname = type_variant_name(ty);
        out.push_str(&format!(
          "  stack.push(StackEntry::Value(\"{}\".to_string(), Value::{}({})));\n",
          name,
          vname,
          camel_ident(name)
        ));
      }

      // 3) Allocate locals with defaults
      for l in &func.locals {
        let lname = l.0;
        let lty = &l.1;
        let vname = type_variant_name(lty);
        let def_expr = default_value_expr(lty);
        out.push_str(&format!(
          "  stack.push(StackEntry::Value(\"{}\".to_string(), Value::{}({})));\n",
          lname, vname, def_expr
        ));
      }

      // 4) Push entry state
      let entry_state = variant_name(&[fiber_name.0.as_str(), func_name, "entry"]);
      out.push_str(&format!("  stack.push(StackEntry::State(State::{}));\n", entry_state));

      // 5) Initialize heap with defaults for this fiber
      out.push_str(&format!("  let heap = Heap::default();\n  (stack, heap)\n}}\n\n"));

      // Result extraction function
      let result_fn_name = format!("{}_result_{}", camel_ident(&fiber_name.0), camel_ident(func_name));
      let ret_ty = rust_type(&func.out);
      out.push_str(&format!("pub fn {}(stack: &[StackEntry]) -> {} {{\n", result_fn_name, ret_ty));
      if matches!(&func.out, Type::Void) {
        // Void results are not placed on the stack; just return unit.
        out.push_str("  let _ = stack;\n  ()\n}\n\n");
      } else {
        out.push_str("  match stack.last() {\n");
        out.push_str("    Some(StackEntry::Value(_, ");
        out.push_str(&format!("Value::{}(v))) => v.clone(),\n", ret_vname));
        out.push_str("    _ => unreachable!(\"result not found on stack\"),\n");
        out.push_str("  }\n}\n\n");
      }
      // 6) Generate untyped wrappers for registry
      // Prepare-from-Vec<Value>
      let wrapper_prepare = format!("fn {}_from_values(args: Vec<Value>) -> Vec<StackEntry> {{\n", prepare_fn_name);
      out.push_str(&wrapper_prepare);
      for (idx, p) in func.in_vars.iter().enumerate() {
        let pname = camel_ident(p.0);
        let vname = type_variant_name(&p.1);
        let rty = rust_type(&p.1);
        out.push_str(&format!(
          "  let {}: {} = if let Value::{}(x) = &args[{}] {{ x.clone() }} else {{ unreachable!(\"invalid args for {}.{}\") }};\n",
          pname, rty, vname, idx, fiber_name, func_name
        ));
      }
      let arg_list = func.in_vars.iter().map(|p| camel_ident(p.0)).collect::<Vec<_>>().join(", ");
      out.push_str(&format!("  let (stack, _heap) = {}({});\n  stack\n}}\n\n", prepare_fn_name, arg_list));

      // Result-to-Value wrapper
      let out_vname = type_variant_name(&func.out);
      out.push_str(&format!(
        "fn {}_value(stack: &[StackEntry]) -> Value {{ Value::{}({}(stack)) }}\n\n",
        result_fn_name, out_vname, result_fn_name
      ));

      // 7) Append registry match arms (use IR names as-is)
      let key_exact = format!("{}.{}", fiber_name, func_name);
      prepare_arms.push(format!("    \"{}\" => {}_from_values,\n", key_exact, prepare_fn_name));
      result_arms.push(format!("    \"{}\" => {}_value,\n", key_exact, result_fn_name));
    }
  }

  // Emit registry functions
  out.push_str("pub fn get_prepare_fn(key: &str) -> PrepareFn {\n  match key {\n");
  prepare_arms.sort();
  for arm in prepare_arms {
    out.push_str(&arm);
  }
  out.push_str("    _ => panic!(\"shouldnt be here\"),\n  }\n}\n\n");

  out.push_str("pub fn get_result_fn(key: &str) -> ResultFn {\n  match key {\n");
  result_arms.sort();
  for arm in result_arms {
    out.push_str(&arm);
  }
  out.push_str("    _ => panic!(\"shouldnt be here\"),\n  }\n}\n\n");

  out
}

fn generate_heap_init_helpers(ir: &IR) -> String {
  let mut out = String::new();

  // alias
  out.push_str("pub type HeapInitFn = fn(Vec<Value>) -> Heap;\n\n");

  // For each fiber, emit a typed prepare function and a Vec<Value> wrapper
  let mut fibers_sorted: Vec<(&FiberType, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));

  // registry arms
  let mut init_arms: Vec<String> = Vec::new();

  for (fiber_name, fiber) in fibers_sorted.iter() {
    let fname = camel_ident(&fiber_name.0);
    let prepare_fn_name = format!("{}_prepare_heap", fname);

    // typed signature params by init_vars
    let mut params: Vec<String> = Vec::new();
    for InVar(n, t) in &fiber.init_vars {
      params.push(format!("{}: {}", camel_ident(n), rust_type(t)));
    }

    out.push_str(&format!("pub fn {}({}) -> Heap {{\n", prepare_fn_name, params.join(", ")));
    out.push_str("  let mut heap = Heap::default();\n");
    if !fiber.init_vars.is_empty() {
      let heap_field = camel_ident(&fiber_name.0);
      for InVar(n, _) in &fiber.init_vars {
        out.push_str(&format!("  heap.{}.in_vars.{} = {};\n", heap_field, camel_ident(n), camel_ident(n)));
      }
    }
    out.push_str("  heap\n}\n\n");

    // wrapper from Vec<Value>
    let wrapper_name = format!("{}_prepare_heap_from_values", fname);
    out.push_str(&format!("fn {}(args: Vec<Value>) -> Heap {{\n", wrapper_name));
    for (idx, InVar(n, t)) in fiber.init_vars.iter().enumerate() {
      let vname = type_variant_name(t);
      let rty = rust_type(t);
      out.push_str(&format!(
        "  let {}: {} = if let Value::{}(x) = &args[{}] {{ x.clone() }} else {{ unreachable!(\"invalid init var for {}\") }};\n",
        camel_ident(n), rty, vname, idx, fiber_name.0
      ));
    }
    let call_params = fiber.init_vars.iter().map(|iv| camel_ident(iv.0)).collect::<Vec<_>>().join(", ");
    out.push_str(&format!("  {}({})\n}}\n\n", prepare_fn_name, call_params));

    init_arms.push(format!("    \"{}\" => {}_prepare_heap_from_values,\n", fiber_name.0, fname));
  }

  // registry function
  out.push_str("pub fn get_heap_init_fn(fiber: &FiberType) -> HeapInitFn {\n  match fiber.0.as_str() {\n");
  init_arms.sort();
  for arm in init_arms {
    out.push_str(&arm);
  }
  out.push_str("    _ => |_| Heap::default(),\n  }\n}\n\n");

  out
}

use std::collections::BTreeSet;

fn collect_vars_from_expr(
  expr: &Expr,
  acc: &mut BTreeSet<String>,
) {
  match expr {
    Expr::UInt64(_) | Expr::Str(_) => {}
    Expr::Var(name) => {
      acc.insert(name.0.to_string());
    }
    Expr::Equal(a, b) | Expr::Greater(a, b) | Expr::Less(a, b) => {
      collect_vars_from_expr(a, acc);
      collect_vars_from_expr(b, acc);
    }
    Expr::IsSome(e) | Expr::Unwrap(e) => collect_vars_from_expr(e, acc),
    Expr::GetField(e, _) => collect_vars_from_expr(e, acc),
    Expr::StructUpdate { base, updates } => {
      collect_vars_from_expr(base, acc);
      for (_, e) in updates {
        collect_vars_from_expr(e, acc);
      }
    }
  }
}

fn var_type_of<'a>(
  func: &'a Func,
  name: &str,
) -> Option<&'a Type> {
  for p in &func.in_vars {
    if p.0 == name {
      return Some(&p.1);
    }
  }
  for l in &func.locals {
    if l.0 == name {
      return Some(&l.1);
    }
  }
  None
}

fn var_is_param(
  func: &Func,
  name: &str,
) -> bool {
  func.in_vars.iter().any(|p| p.0 == name)
}

fn render_expr_code(
  expr: &Expr,
  _func: &Func,
) -> String {
  match expr {
    Expr::UInt64(x) => format!("{}u64", x),
    Expr::Var(name) => camel_ident(name.0),
    Expr::Str(s) => format!("\"{}\".to_string()", s.replace('"', "\\\"")),
    Expr::Equal(a, b) => format!("{} == {}", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::Greater(a, b) => format!("{} > {}", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::Less(a, b) => format!("{} < {}", render_expr_code(a, _func), render_expr_code(b, _func)),
    Expr::IsSome(e) => format!("({}).is_some()", render_expr_code(e, _func)),
    Expr::Unwrap(e) => format!("({}).unwrap()", render_expr_code(e, _func)),
    Expr::GetField(e, field) => format!("({}).{}", render_expr_code(e, _func), camel_ident(field)),
    Expr::StructUpdate { base, updates } => {
      let mut s = format!("{{ let mut tmp = ({}).clone(); ", render_expr_code(base, _func));
      for (fname, fexpr) in updates {
        s.push_str(&format!("tmp.{} = ({}); ", camel_ident(fname), render_expr_code(fexpr, _func)));
      }
      s.push_str("tmp }");
      s
    }
  }
}

fn render_ret_value(
  rv: &RetValue,
  expected_ty: &Type,
  _func: &Func,
) -> String {
  match rv {
    RetValue::UInt64(x) => format!("{}u64", x),
    RetValue::Str(s) => format!("\"{}\".to_string()", s.replace('"', "\\\"")),
    RetValue::Var(name) => camel_ident(name.0),
    RetValue::Some(inner) => {
      if let Type::Option(inner_ty) = expected_ty {
        let inner_code = render_ret_value(inner, inner_ty, _func);
        format!("Some({})", inner_code)
      } else {
        let inner_code = render_ret_value(inner, expected_ty, _func);
        format!("Some({})", inner_code)
      }
    }
    RetValue::None => "None".to_string(),
  }
}

fn default_value_expr(t: &Type) -> String {
  match t {
    Type::UInt64 => "0u64".to_string(),
    Type::String => "String::new()".to_string(),
    Type::Void => "()".to_string(),
    Type::MaxQueue(inner) => format!("std::collections::BinaryHeap::<{}>::new()", rust_type(inner)),
    Type::MinQueue(inner) => format!("std::collections::BinaryHeap::<std::cmp::Reverse<{}>>::new()", rust_type(inner)),
    Type::Option(_) => "None".to_string(),
    Type::Array(inner) => format!("Vec::<{}>::new()", rust_type(inner)),
    Type::Map(k, v) => format!("std::collections::HashMap::<{}, {}>::new()", rust_type(k), rust_type(v)),
    Type::Struct(name, _, _) | Type::Custom(name) => {
      format!("{}::default()", pascal_case(name))
    }
    Type::PubQueueMessage { name, .. } => {
      format!("{}::default()", pascal_case(name))
    }
    Type::Future(inner) => {
      format!("Future{}::default()", type_variant_name(inner))
    }
  }
}

fn render_call_step(
  ir: &IR,
  current_fiber: &str,
  current_func_name: &str,
  current_func: &Func,
  target: &FuncRef,
  args: &Vec<Expr>,
  ret_to: &StepId,
  bind: &Option<LocalVarRef>,
) -> String {
  let mut s = String::new();
  let ret_state = variant_name(&[current_fiber, current_func_name, &ret_to.0]);
  if let Some(callee) = find_func(ir, &target.fiber, &target.func) {
    s.push_str("      StepResult::Next(vec![\n");
    s.push_str(&format!("        StackEntry::State(State::{}),\n", ret_state));
    // Compute bind offset if provided
    if let Some(var_name) = bind {
      let params_len = current_func.in_vars.len();
      let locals_len = current_func.locals.len();
      let total_vars = params_len + locals_len;
      let var_index = if let Some(pi) = current_func.in_vars.iter().position(|p| p.0 == var_name.0) {
        Some(pi)
      } else if let Some(li) = current_func.locals.iter().position(|l| l.0 == var_name.0) {
        Some(params_len + li)
      } else {
        None
      };
      if let Some(var_ind) = var_index {
        // +1 for the continuation state we just pushed
        let offset = (total_vars + 1) - var_ind;
        s.push_str(&format!("        StackEntry::Retrn(Some({})),\n", offset));
      } else {
        s.push_str("        StackEntry::Retrn(None),\n");
      }
    } else {
      s.push_str("        StackEntry::Retrn(None),\n");
    }
    for (idx, p) in callee.in_vars.iter().enumerate() {
      if let Some(arg) = args.get(idx) {
        let pname = p.0;
        let pty = &p.1;
        let vname = type_variant_name(pty);
        let expr_code = render_expr_code(arg, current_func);
        s.push_str(&format!(
          "        StackEntry::Value(\"{}\".to_string(), Value::{}({})),\n",
          pname, vname, expr_code
        ));
      }
    }
    // Push default placeholders for callee locals to allocate its frame fully
    for l in &callee.locals {
      let lname = l.0;
      let lty = &l.1;
      let vname = type_variant_name(lty);
      let def_expr = default_value_expr(lty);
      s.push_str(&format!("        StackEntry::Value(\"{}\".to_string(), Value::{}({})),\n", lname, vname, def_expr));
    }
    let callee_entry = variant_name(&[&target.fiber, &target.func, "entry"]);
    s.push_str(&format!("        StackEntry::State(State::{}),\n", callee_entry));
    s.push_str("      ])\n");
  } else {
    s.push_str(&format!("      StepResult::GoTo(State::{})\n", ret_state));
  }
  s
}

fn collect_vars_from_retvalue(
  rv: &RetValue,
  acc: &mut BTreeSet<String>,
) {
  match rv {
    RetValue::Var(name) => {
      acc.insert(name.0.to_string());
    }
    RetValue::UInt64(_) | RetValue::Str(_) => {}
    RetValue::Some(inner) => collect_vars_from_retvalue(inner, acc),
    RetValue::None => {}
  }
}

fn find_func<'a>(
  ir: &'a IR,
  fiber: &str,
  func: &str,
) -> Option<&'a Func> {
  ir.fibers.get(fiber).and_then(|f| f.funcs.get(func))
}

// Generate a function that returns how many Value entries are expected to be
// located for function. So it shows the stack deep only for XXXEntry steps
// The count is computed as:
// - For any function entry state: number of input params + locals
fn generate_func_args_count(ir: &IR) -> String {
  let mut fibers_sorted: Vec<(&FiberType, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));

  let mut out = r"
pub fn func_args_count(e: &State) -> usize {
  match e {
"
  .to_string();

  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      let n = func.in_vars.len() + func.locals.len();
      // Always include the function's entry state
      let entry_variant = variant_name(&[fiber_name.0.as_str(), func_name, "entry"]);
      out.push_str(&format!("    State::{} => {},\n", entry_variant, n));

      // Identify direct-return RustBlock next steps to suppress from func_args_count
      use std::collections::BTreeSet as __BTS2;
      let mut suppressed: __BTS2<String> = __BTS2::new();
      for (_sid, st) in &func.steps {
        if let Step::RustBlock { binds, next, .. } = st {
          if binds.len() == 1 {
            if let Some((_, Step::Return { value })) = func.steps.iter().find(|(nsid, _)| nsid.0 == next.0) {
              if let RetValue::Var(vn) = value {
                if vn == &binds[0] {
                  suppressed.insert(next.0.clone());
                }
              }
            }
          }
        }
      }

      let mut steps_sorted: Vec<&(StepId, Step)> = func.steps.iter().collect();
      steps_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));

      for (step_id, step) in steps_sorted {
        // Skip entry here since it's already added explicitly above
        if step_id.0 == "entry" {
          continue;
        }
        // Additional safety: suppress direct-return targets
        let mut skip = suppressed.contains(&step_id.0);
        if !skip {
          if let Step::Return { value } = step {
            if let RetValue::Var(vn) = value {
              let has_direct_rb = func.steps.iter().any(|(_sid2, st2)| match st2 {
                Step::RustBlock { binds, next, .. } => binds.len() == 1 && &binds[0] == vn && next.0 == step_id.0,
                _ => false,
              });
              if has_direct_rb {
                skip = true;
              }
            }
          }
        }
        if !skip {
          let v = variant_name(&[fiber_name.0.as_str(), func_name, &step_id.0]);
          out.push_str(&format!("    State::{} => {},\n", v, n));
        }
      }
    }
  }
  out.push_str(&format!("    State::Idle => 0,\n"));
  out.push_str(&format!("    State::Completed => 0,\n"));

  out.push_str(
    r"  }
}
",
  );
  out
}

fn generate_global_step(ir: &IR) -> String {
  let mut out = String::new();
  out.push_str("pub fn global_step(state: State, vars: &[StackEntry], heap: &mut Heap) -> StepResult {\n");
  out.push_str("  match state {\n");
  out.push_str("    State::Completed => StepResult::Done,\n");
  out.push_str("    State::Idle => panic!(\"shoudnt be here\"),\n");
  let mut fibers_sorted: Vec<(&FiberType, &Fiber)> = ir.fibers.iter().collect();
  fibers_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));
  for (fiber_name, fiber) in fibers_sorted.iter() {
    let mut funcs_sorted: Vec<(&String, &Func)> = fiber.funcs.iter().collect();
    funcs_sorted.sort_by(|a, b| a.0.cmp(b.0));
    for (func_name, func) in funcs_sorted {
      // Compute suppressed steps (direct-return next of RustBlock) for this function
      use std::collections::BTreeSet as __BTS_CODEGEN2;
      let mut suppressed: __BTS_CODEGEN2<String> = __BTS_CODEGEN2::new();
      for (_sid, st) in &func.steps {
        if let Step::RustBlock { binds, next, .. } = st {
          if binds.len() == 1 {
            if let Some((_, Step::Return { value })) = func.steps.iter().find(|(nsid, _)| nsid.0 == next.0) {
              if let RetValue::Var(vn) = value {
                if vn == &binds[0] {
                  suppressed.insert(next.0.clone());
                }
              }
            }
          }
        }
      }
      use std::collections::BTreeSet;
      let mut seen: BTreeSet<String> = BTreeSet::new();
      let entry_variant = variant_name(&[fiber_name.0.as_str(), func_name, "entry"]);
      if seen.insert(entry_variant.clone()) {
        out.push_str(&format!("    State::{entry_variant} => {{\n"));

        // put variables from stack according to the IR needs
        // TODO: some steps won't need all the variables, so later it should be a bit trickier, when it comes to get indexes in a stack for variables
        for (i, var) in func.in_vars.iter().enumerate() {
          let vname_str = var.0;
          let vty = &var.1;
          let vname_ty = type_variant_name(vty);
          out.push_str(&format!(
            "      let {}: {} = if let StackEntry::Value(_, Value::{vname_ty}(x)) = &vars[{}] {{ x.clone() }} else {{ unreachable!() }};\n",
            vname_str, rust_type(vty), i
          ));
        }

        // Bind referenced locals for entry step using positional indices (after params)
        for (i, _var) in func.locals.iter().enumerate() {
          let _ = i;
        }

        // If the entry step is explicitly defined in IR, emit its logic here; otherwise, fallback.
        if let Some((_, entry_step)) = func.steps.iter().find(|(sid, _)| sid.0 == "entry") {
          // Collect referenced vars for this entry step
          let mut referenced: BTreeSet<String> = BTreeSet::new();
          match entry_step {
            Step::Debug(_, _) => {}
            Step::DebugPrintVars(_) => {}
            Step::ScheduleTimer { .. } => {}
            // handled below to capture referenced init_vars
            Step::SendToFiber { args, .. } => {
              for (_, e) in args {
                collect_vars_from_expr(&e, &mut referenced);
              }
            }
            Step::SetValues { values, .. } => {
              for v in values {
                match v {
                  crate::ir::SetPrimitive::QueueMessage { f_var_queue_name, var_name } => {
                    referenced.insert(f_var_queue_name.0.to_string());
                    referenced.insert(var_name.0.to_string());
                  }
                  crate::ir::SetPrimitive::Future { f_var_name, var_name } => {
                    referenced.insert(f_var_name.0.to_string());
                    referenced.insert(var_name.0.to_string());
                  }
                }
              }
            }
            Step::Create { primitives, .. } => {
              for p in primitives {
                if let crate::ir::RuntimePrimitive::Queue { name, .. } = p {
                  referenced.insert(name.0.to_string());
                }
              }
            }
            Step::CreateFibers { details, .. } => {
              for d in details {
                for v in &d.init_vars {
                  referenced.insert(v.0.to_string());
                }
              }
            }
            Step::Await(_) => {}
            Step::Select { arms } => {
              for arm in arms {
                if let AwaitSpec::Queue { queue_name, .. } = arm {
                  referenced.insert(queue_name.0.to_string());
                }
              }
            }
            Step::Call { args, .. } => {
              for e in args {
                collect_vars_from_expr(&e, &mut referenced);
              }
            }
            Step::Return { value } => collect_vars_from_retvalue(value, &mut referenced),
            Step::ReturnVoid => {}
            Step::If { cond, .. } => collect_vars_from_expr(&cond, &mut referenced),
            Step::Let { expr, .. } => collect_vars_from_expr(&expr, &mut referenced),
            Step::RustBlock { .. } => {
              for p in &func.in_vars {
                referenced.insert(p.0.to_string());
              }
              for l in &func.locals {
                referenced.insert(l.0.to_string());
              }
            }
          }
          // Bind only locals (params are already bound above) using positional indices
          for var_name in referenced.iter() {
            if let Some(ty) = var_type_of(func, var_name) {
              if !var_is_param(func, var_name) {
                if let Some(pos) = func.locals.iter().position(|l| l.0 == var_name.as_str()) {
                  let idx = func.in_vars.len() + pos;
                  let rust_ty = rust_type(ty);
                  let tname = type_variant_name(ty);
                  let local_ident = camel_ident(var_name);
                  out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(_, Value::{tname}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }};\n"));
                }
              }
            } else if let Some(iv) = fiber.init_vars.iter().find(|iv| iv.0 == var_name.as_str()) {
              // Referenced fiber-level init var; bind from heap
              let rust_ty = rust_type(&iv.1);
              let heap_field = camel_ident(&fiber_name.0);
              let local_ident = camel_ident(var_name);
              out.push_str(&format!(
                "      let {local_ident}: {rust_ty} = heap.{heap_field}.in_vars.{local_ident}.clone();\n"
              ));
            } else {
              out
                .push_str(&format!("      // NOTE: Referenced variable '{var_name}' not found among params/locals/init_vars.\n"));
            }
          }
          match entry_step {
            Step::Debug(msg, next) => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              out.push_str(&format!("      StepResult::Debug(\"{}\", State::{})\n", msg, next_v));
            }
            Step::CreateFibers { details, next } => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              let mut dparts: Vec<String> = Vec::new();
              for d in details {
                let mut arg_vals: Vec<String> = Vec::new();
                for v in &d.init_vars {
                  // Extract from vars by index regardless of binding
                  if let Some(ty) = var_type_of(func, v.0) {
                    let vname = type_variant_name(ty);
                    let idx_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == v.0) {
                      format!("{}", pi)
                    } else if let Some(li) = func.locals.iter().position(|l| l.0 == v.0) {
                      format!("{}", func.in_vars.len() + li)
                    } else {
                      "0".to_string()
                    };
                    let val_expr = format!(
                      "if let StackEntry::Value(_, Value::{}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }}",
                      vname,
                      idx = idx_expr
                    );
                    arg_vals.push(format!("Value::{}({})", vname, val_expr));
                  } else {
                    // Fallback to string
                    let idx_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == v.0) {
                      format!("{}", pi)
                    } else if let Some(li) = func.locals.iter().position(|l| l.0 == v.0) {
                      format!("{}", func.in_vars.len() + li)
                    } else {
                      "0".to_string()
                    };
                    let val_expr = format!(
                      "if let StackEntry::Value(_, Value::String(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }}",
                      idx = idx_expr
                    );
                    arg_vals.push(format!("Value::String({})", val_expr));
                  }
                }
                dparts.push(format!("(FiberType::new(\"{}\"), vec![{}])", d.f_name.0, arg_vals.join(", ")));
              }
              out.push_str("      StepResult::CreateFibers { details: vec![");
              out.push_str(&dparts.join(", "));
              out.push_str("], next: State::");
              out.push_str(&next_v);
              out.push_str(" }\n");
            }
            Step::Create { primitives, success, fail } => {
              let success_v = variant_name(&[fiber_name.0.as_str(), func_name, &success.next.0]);
              let fail_v = variant_name(&[fiber_name.0.as_str(), func_name, &fail.next.0]);
              // Build primitives vec
              let mut parts: Vec<String> = Vec::new();
              for p in primitives {
                match p {
                  crate::ir::RuntimePrimitive::Future => parts.push("CreatePrimitiveValue::Future".to_string()),
                  crate::ir::RuntimePrimitive::Queue { name, public } => {
                    let idx_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == name.0) {
                      format!("{}", pi)
                    } else if let Some(li) = func.locals.iter().position(|l| l.0 == name.0) {
                      format!("{}", func.in_vars.len() + li)
                    } else {
                      "0".to_string()
                    };
                    let q_expr = format!(
                      "if let StackEntry::Value(_, Value::String(x)) = &vars[{}] {{ x.clone() }} else {{ unreachable!() }}",
                      idx_expr
                    );
                    parts.push(format!("CreatePrimitiveValue::Queue {{ name: {}, public: {} }}", q_expr, public));
                  }
                }
              }
              // Build bind name vectors
              let mut s_binds: Vec<String> = Vec::new();
              for b in &success.id_binds {
                s_binds.push(format!("\"{}\".to_string()", b.0));
              }
              let mut f_binds: Vec<String> = Vec::new();
              for b in &fail.error_binds {
                f_binds.push(format!("\"{}\".to_string()", b.0));
              }
              out.push_str("      StepResult::Create { primitives: vec![");
              out.push_str(&parts.join(", "));
              out.push_str("], success_next: State::");
              out.push_str(&success_v);
              out.push_str(", success_binds: vec![");
              out.push_str(&s_binds.join(", "));
              out.push_str("], fail_next: State::");
              out.push_str(&fail_v);
              out.push_str(", fail_binds: vec![");
              out.push_str(&f_binds.join(", "));
              out.push_str("] }\n");
            }
            Step::DebugPrintVars(next) => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              out.push_str(&format!("      StepResult::DebugPrintVars(State::{})\n", next_v));
            }
            Step::ScheduleTimer { ms, next, future_id } => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              out.push_str(&format!(
                "      StepResult::ScheduleTimer {{ ms: {}u64, next: State::{}, future_id: FutureLabel::new(\"{}\") }}\n",
                ms.0, next_v, future_id.0
              ));
            }
            Step::SetValues { values, next } => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              let mut vparts: Vec<String> = Vec::new();
              for v in values {
                match v {
                  crate::ir::SetPrimitive::QueueMessage { f_var_queue_name, var_name } => {
                    let vty = var_type_of(func, var_name.0).expect("unknown var in SetValues::QueueMessage");
                    let vname = type_variant_name(vty);
                    let mut local_ident = camel_ident(var_name.0);
                    if !is_copy_type(vty) {
                      local_ident = format!("{}.clone()", local_ident);
                    }
                    let q_ident = camel_ident(f_var_queue_name.0);
                    vparts.push(format!(
                      "SetPrimitiveValue::QueueMessage {{ queue_name: {}.clone(), value: Value::{}({}) }}",
                      q_ident, vname, local_ident
                    ));
                  }
                  crate::ir::SetPrimitive::Future { f_var_name, var_name } => {
                    let vty = var_type_of(func, var_name.0).expect("unknown var in SetValues::Future");
                    let vname = type_variant_name(vty);
                    let mut local_ident = camel_ident(var_name.0);
                    if !is_copy_type(vty) {
                      local_ident = format!("{}.clone()", local_ident);
                    }
                    let f_ident = camel_ident(f_var_name.0);
                    let fid_expr = match var_type_of(func, f_var_name.0) {
                      Some(Type::Future(inner)) => {
                        let _ = inner; // silence unused
                        format!("{}.0.clone()", f_ident)
                      }
                      _ => format!("{}.clone()", f_ident),
                    };
                    vparts.push(format!(
                      "SetPrimitiveValue::Future {{ id: {}, value: Value::{}({}) }}",
                      fid_expr, vname, local_ident
                    ));
                  }
                }
              }
              out.push_str("      StepResult::SetValues { values: vec![");
              out.push_str(&vparts.join(", "));
              out.push_str("], next: State::");
              out.push_str(&next_v);
              out.push_str(" }\n");
            }
            Step::Select { arms } => {
              // Build structured Select arms supporting Future and Queue
              let mut arm_parts: Vec<String> = Vec::new();
              for arm in arms {
                match arm {
                  AwaitSpec::Queue { queue_name, message_var, next } => {
                    let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
                    let q_ident = camel_ident(queue_name.0);
                    arm_parts.push(format!(
                      "SelectArm::Queue {{ queue_name: {}.clone(), bind: \"{}\".to_string(), next: State::{} }}",
                      q_ident, message_var.0, next_v
                    ));
                  }
                  AwaitSpec::Future { bind, ret_to, future_id } => {
                    let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &ret_to.0]);
                    match bind {
                    Some(name) => arm_parts.push(format!(
                      "SelectArm::Future {{ future_id: FutureLabel::new(\"{}\"), bind: Some(\"{}\".to_string()), next: State::{} }}",
                      future_id.0, name.0, next_v
                    )),
                    None => arm_parts.push(format!(
                      "SelectArm::Future {{ future_id: FutureLabel::new(\"{}\"), bind: None, next: State::{} }}",
                      future_id.0, next_v
                    )),
                  }
                  }
                }
              }
              out.push_str("      StepResult::Select(vec![");
              out.push_str(&arm_parts.join(", "));
              out.push_str("])\n");
            }
            Step::SendToFiber { fiber, message, args, next, future_id } => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              // Build args vector in callee's param order/types
              if let Some(callee) = find_func(ir, fiber.as_str(), message.as_str()) {
                let mut arg_elems: Vec<String> = Vec::new();
                for (aname, aexpr) in args.iter() {
                  if let Some(param) = callee.in_vars.iter().find(|p| p.0 == aname.as_str()) {
                    let vname = type_variant_name(&param.1);
                    let mut expr_code = render_expr_code(aexpr, func);
                    if let Expr::Var(var_name) = aexpr {
                      if let Some(src_ty) = var_type_of(func, var_name.0) {
                        if !is_copy_type(src_ty) {
                          expr_code = format!("({}).clone()", expr_code);
                        }
                      }
                    }
                    arg_elems.push(format!("Value::{}({})", vname, expr_code));
                  }
                }
                out.push_str("      StepResult::SendToFiber { f_type: FiberType::new(\"");
                out.push_str(fiber);
                out.push_str("\"), func: \"");
                out.push_str(message);
                out.push_str("\".to_string(), args: vec![");
                out.push_str(&arg_elems.join(", "));
                out.push_str("], next: State::");
                out.push_str(&next_v);
                out.push_str(", future_id: FutureLabel::new(\"");
                out.push_str(&future_id.0);
                out.push_str("\") }\n");
              } else {
                out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
              }
            }
            Step::Await(spec) => {
              // Pause current task until a future resolves; push continuation state when resuming.
              match spec {
                AwaitSpecOld::Future { bind, ret_to, future_id } => {
                  let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &ret_to.0]);
                  match bind {
                    Some(name) => out.push_str(&format!(
                      "      StepResult::AwaitOld(FutureLabel::new(\"{}\"), Some(\"{}\".to_string()), State::{})\n",
                      future_id.0, name.0, next_v
                    )),
                    None => out.push_str(&format!(
                      "      StepResult::AwaitOld(FutureLabel::new(\"{}\"), None, State::{})\n",
                      future_id.0, next_v
                    )),
                  }
                }
                AwaitSpecOld::Queue { .. } => {
                  out.push_str("      StepResult::Todo(\"await-queue-in-await\".to_string())\n");
                }
              }
            }
            Step::Call { target, args, ret_to, bind } => {
              out.push_str(&render_call_step(ir, fiber_name.0.as_str(), func_name, func, target, args, ret_to, bind));
            }
            Step::Return { value } => {
              let code = render_ret_value(value, &func.out, func);
              out.push_str(&format!("      StepResult::Return(Value::{}({}))\n", type_variant_name(&func.out), code));
            }
            Step::ReturnVoid => out.push_str("      StepResult::ReturnVoid\n"),
            Step::If { cond, then_, else_ } => {
              let then_v = variant_name(&[fiber_name.0.as_str(), func_name, &then_.0]);
              let else_v = variant_name(&[fiber_name.0.as_str(), func_name, &else_.0]);
              let cond_code = render_expr_code(&cond, func);
              out.push_str(&format!(
                "      if {} {{ StepResult::GoTo(State::{}) }} else {{ StepResult::GoTo(State::{}) }}\n",
                cond_code, then_v, else_v
              ));
            }
            Step::Let { local, expr, next } => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              // Assign into an existing local slot via FrameAssign at the correct offset
              let lty = var_type_of(func, local).expect("unknown local var in Let");
              let vname = type_variant_name(lty);
              let expr_code = render_expr_code(&expr, func);
              let pos_expr = if let Some(li) = func.locals.iter().position(|l| l.0 == local.as_str()) {
                format!("{}", func.in_vars.len() + li)
              } else {
                "0".to_string()
              };
              out.push_str("      StepResult::Next(vec![\n");
              out.push_str(&format!(
                "        StackEntry::FrameAssign(vec![( {}, Value::{}({}) )]),\n",
                pos_expr, vname, expr_code
              ));
              out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
              out.push_str("      ])\n");
            }
            Step::RustBlock { binds, next, code: rcode } => {
              let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
              let mut bind_types: Vec<&Type> = Vec::new();
              for b in binds {
                bind_types.push(var_type_of(func, b.0).expect("bind var type"));
              }
              if bind_types.len() == 1 {
                // Optimization: if next step is `Return { value: Var(binds[0]) }`, return directly
                let direct_return = func
                  .steps
                  .iter()
                  .find(|(sid, _)| sid.0 == next.0)
                  .and_then(|(_, st)| if let Step::Return { value } = st { Some(value) } else { None })
                  .and_then(|rv| if let RetValue::Var(vn) = rv { Some(vn) } else { None })
                  .map(|vn| vn == &binds[0])
                  .unwrap_or(false);
                if direct_return {
                  let ty_name = type_variant_name(bind_types[0]);
                  out.push_str("      { let out = {\n");
                  out.push_str(rcode);
                  out.push_str("\n      }; ");
                  out.push_str(&format!("StepResult::Return(Value::{}(out)) }}\n", ty_name));
                } else {
                  // Single bind: assign directly into the current frame using offset
                  let ty_name = type_variant_name(bind_types[0]);
                  let bname = binds.get(0).unwrap();
                  let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == bname.0) {
                    format!("{}", pi)
                  } else if let Some(li) = func.locals.iter().position(|l| l.0 == bname.0) {
                    format!("{}", func.in_vars.len() + li)
                  } else {
                    "0".to_string()
                  };
                  out.push_str("      { let out = {\n");
                  out.push_str(rcode);
                  out.push_str("\n      }; StepResult::Next(vec![\n");
                  out.push_str(&format!(
                    "          StackEntry::FrameAssign(vec![( {}, Value::{}(out) )]),\n",
                    pos_expr, ty_name
                  ));
                  out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
                }
              } else {
                out.push_str("      { let out = {\n");
                out.push_str(rcode);
                out.push_str("\n      };\n");
                let tuple_names: Vec<String> = (0..bind_types.len()).map(|i| format!("o{}", i)).collect();
                out.push_str(&format!(
                  "        let ({}) = out;\n        StepResult::Next(vec![\n",
                  tuple_names.join(", ")
                ));
                // Build FrameAssign with all bind updates
                out.push_str("          StackEntry::FrameAssign(vec![\n");
                for (i, b) in binds.iter().enumerate() {
                  let ty_name = type_variant_name(bind_types[i]);
                  let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == b.0) {
                    format!("{}", pi)
                  } else if let Some(li) = func.locals.iter().position(|l| l.0 == b.0) {
                    format!("{}", func.in_vars.len() + li)
                  } else {
                    "0".to_string()
                  };
                  out.push_str(&format!("            ( {}, Value::{}({}) ),\n", pos_expr, ty_name, tuple_names[i]));
                }
                out.push_str("          ]),\n");
                out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
              }
            }
          }
        } else {
          // Default: nothing special, fall back to a no-op transition.
          out.push_str(&format!("      StepResult::GoTo(State::{})\n", &entry_variant));
        }

        out.push_str("    }\n");
      }
      let mut steps_sorted: Vec<(&StepId, &Step)> = func.steps.iter().map(|(id, st)| (id, st)).collect();
      steps_sorted.sort_by(|a, b| a.0.0.cmp(&b.0.0));
      for (step_id, step) in steps_sorted {
        // Skip suppressed direct-return next steps
        let mut skip_step = suppressed.contains(&step_id.0);
        if !skip_step {
          if let Step::Return { value } = step {
            if let RetValue::Var(vn) = value {
              let has_direct_rb = func.steps.iter().any(|(_sid2, st2)| match st2 {
                Step::RustBlock { binds, next, .. } => binds.len() == 1 && &binds[0] == vn && next.0 == step_id.0,
                _ => false,
              });
              if has_direct_rb {
                skip_step = true;
              }
            }
          }
        }
        if skip_step {
          continue;
        }
        let state_variant = variant_name(&[fiber_name.0.as_str(), func_name, &step_id.0]);
        if !seen.insert(state_variant.clone()) {
          continue;
        }
        let mut referenced: BTreeSet<String> = BTreeSet::new();
        match step {
          Step::Debug(_, _) => {}
          Step::DebugPrintVars(_) => {}
          Step::ScheduleTimer { .. } => {}
          // handled below to capture referenced init_vars
          Step::SendToFiber { args, .. } => {
            for (_, e) in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::SetValues { values, .. } => {
            for v in values {
              match v {
                crate::ir::SetPrimitive::QueueMessage { f_var_queue_name, var_name } => {
                  referenced.insert(f_var_queue_name.0.to_string());
                  referenced.insert(var_name.0.to_string());
                }
                crate::ir::SetPrimitive::Future { f_var_name, var_name } => {
                  referenced.insert(f_var_name.0.to_string());
                  referenced.insert(var_name.0.to_string());
                }
              }
            }
          }
          Step::Create { primitives, .. } => {
            for p in primitives {
              if let crate::ir::RuntimePrimitive::Queue { name, .. } = p {
                referenced.insert(name.0.to_string());
              }
            }
          }
          Step::CreateFibers { details, .. } => {
            for d in details {
              for v in &d.init_vars {
                referenced.insert(v.0.to_string());
              }
            }
          }
          Step::Await(_) => {}
          Step::Select { arms } => {
            for arm in arms {
              if let AwaitSpec::Queue { queue_name, .. } = arm {
                referenced.insert(queue_name.0.to_string());
              }
            }
          }
          Step::Call { args, .. } => {
            for e in args {
              collect_vars_from_expr(&e, &mut referenced);
            }
          }
          Step::Return { value } => collect_vars_from_retvalue(value, &mut referenced),
          Step::ReturnVoid => {}
          Step::If { cond, .. } => collect_vars_from_expr(&cond, &mut referenced),
          Step::Let { expr, .. } => collect_vars_from_expr(&expr, &mut referenced),
          Step::RustBlock { .. } => {
            for p in &func.in_vars {
              referenced.insert(p.0.to_string());
            }
            for l in &func.locals {
              referenced.insert(l.0.to_string());
            }
          }
        }
        out.push_str(&format!("    State::{state_variant} => {{\n"));
        for var_name in referenced.iter() {
          if let Some(ty) = var_type_of(func, var_name) {
            let rust_ty = rust_type(ty);
            let tname = type_variant_name(ty);
            let local_ident = camel_ident(var_name);
            if var_is_param(func, var_name) {
              if let Some(pos) = func.in_vars.iter().position(|p| p.0 == var_name.as_str()) {
                out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(_, Value::{tname}(x)) = &vars[{pos}] {{ x.clone() }} else {{ unreachable!() }};\n"));
              }
            } else {
              if let Some(pos) = func.locals.iter().position(|l| l.0 == var_name.as_str()) {
                let idx = func.in_vars.len() + pos;
                out.push_str(&format!("      let {local_ident}: {rust_ty} = if let StackEntry::Value(_, Value::{tname}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }};\n"));
              }
            }
          } else if let Some(iv) = fiber.init_vars.iter().find(|iv| iv.0 == var_name.as_str()) {
            let rust_ty = rust_type(&iv.1);
            let heap_field = camel_ident(&fiber_name.0);
            let local_ident = camel_ident(var_name);
            out.push_str(&format!(
              "      let {local_ident}: {rust_ty} = heap.{heap_field}.in_vars.{local_ident}.clone();\n"
            ));
          } else {
            out.push_str(&format!("      // NOTE: Referenced variable '{var_name}' not found among params/locals/init_vars.\n"));
          }
        }
        match step {
          Step::Debug(msg, next) => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            out.push_str(&format!("      StepResult::Debug(\"{}\", State::{})\n", msg, next_v));
          }
          Step::CreateFibers { details, next } => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            let mut dparts: Vec<String> = Vec::new();
            for d in details {
              let mut arg_vals: Vec<String> = Vec::new();
              for v in &d.init_vars {
                if let Some(ty) = var_type_of(func, v.0) {
                  let vname = type_variant_name(ty);
                  let idx_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == v.0) {
                    format!("{}", pi)
                  } else if let Some(li) = func.locals.iter().position(|l| l.0 == v.0) {
                    format!("{}", func.in_vars.len() + li)
                  } else {
                    "0".to_string()
                  };
                  let val_expr = format!(
                    "if let StackEntry::Value(_, Value::{}(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }}",
                    vname,
                    idx = idx_expr
                  );
                  arg_vals.push(format!("Value::{}({})", vname, val_expr));
                } else {
                  let idx_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == v.0) {
                    format!("{}", pi)
                  } else if let Some(li) = func.locals.iter().position(|l| l.0 == v.0) {
                    format!("{}", func.in_vars.len() + li)
                  } else {
                    "0".to_string()
                  };
                  let val_expr = format!(
                    "if let StackEntry::Value(_, Value::String(x)) = &vars[{idx}] {{ x.clone() }} else {{ unreachable!() }}",
                    idx = idx_expr
                  );
                  arg_vals.push(format!("Value::String({})", val_expr));
                }
              }
              dparts.push(format!("(FiberType::new(\"{}\"), vec![{}])", d.f_name.0, arg_vals.join(", ")));
            }
            out.push_str("      StepResult::CreateFibers { details: vec![");
            out.push_str(&dparts.join(", "));
            out.push_str("], next: State::");
            out.push_str(&next_v);
            out.push_str(" }\n");
          }
          Step::Create { primitives, success, fail } => {
            let success_v = variant_name(&[fiber_name.0.as_str(), func_name, &success.next.0]);
            let fail_v = variant_name(&[fiber_name.0.as_str(), func_name, &fail.next.0]);
            let mut parts: Vec<String> = Vec::new();
            for p in primitives {
              match p {
                crate::ir::RuntimePrimitive::Future => parts.push("CreatePrimitiveValue::Future".to_string()),
                crate::ir::RuntimePrimitive::Queue { name, public } => {
                  let idx_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == name.0) {
                    format!("{}", pi)
                  } else if let Some(li) = func.locals.iter().position(|l| l.0 == name.0) {
                    format!("{}", func.in_vars.len() + li)
                  } else {
                    "0".to_string()
                  };
                  let q_expr = format!(
                    "if let StackEntry::Value(_, Value::String(x)) = &vars[{}] {{ x.clone() }} else {{ unreachable!() }}",
                    idx_expr
                  );
                  parts.push(format!("CreatePrimitiveValue::Queue {{ name: {}, public: {} }}", q_expr, public));
                }
              }
            }
            let mut s_binds: Vec<String> = Vec::new();
            for b in &success.id_binds {
              s_binds.push(format!("\"{}\".to_string()", b.0));
            }
            let mut f_binds: Vec<String> = Vec::new();
            for b in &fail.error_binds {
              f_binds.push(format!("\"{}\".to_string()", b.0));
            }
            out.push_str("      StepResult::Create { primitives: vec![");
            out.push_str(&parts.join(", "));
            out.push_str("], success_next: State::");
            out.push_str(&success_v);
            out.push_str(", success_binds: vec![");
            out.push_str(&s_binds.join(", "));
            out.push_str("], fail_next: State::");
            out.push_str(&fail_v);
            out.push_str(", fail_binds: vec![");
            out.push_str(&f_binds.join(", "));
            out.push_str("] }\n");
          }
          Step::DebugPrintVars(next) => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            out.push_str(&format!("      StepResult::DebugPrintVars(State::{})\n", next_v));
          }
          Step::ScheduleTimer { ms, next, future_id } => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            out.push_str(&format!(
              "      StepResult::ScheduleTimer {{ ms: {}u64, next: State::{}, future_id: FutureLabel::new(\"{}\") }}\n",
              ms.0, next_v, future_id.0
            ));
          }
          Step::SetValues { values, next } => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            let mut vparts: Vec<String> = Vec::new();
            for v in values {
              match v {
                crate::ir::SetPrimitive::QueueMessage { f_var_queue_name: queue_name, var_name } => {
                  let vty = var_type_of(func, var_name.0).expect("unknown var in SetValues::QueueMessage");
                  let vname = type_variant_name(vty);
                  let mut local_ident = camel_ident(var_name.0);
                  local_ident = format!("{}.clone()", local_ident);
                  let q_ident = camel_ident(queue_name.0);
                  vparts.push(format!(
                    "SetPrimitiveValue::QueueMessage {{ queue_name: {}.clone(), value: Value::{}({}) }}",
                    q_ident, vname, local_ident
                  ));
                }
                crate::ir::SetPrimitive::Future { f_var_name, var_name } => {
                  let vty = var_type_of(func, var_name.0).expect("unknown var in SetValues::Future");
                  let vname = type_variant_name(vty);
                  let mut local_ident = camel_ident(var_name.0);
                  local_ident = format!("{}.clone()", local_ident);
                  let f_ident = camel_ident(f_var_name.0);
                  // Determine how to extract id: from Future<T>.id or directly if String
                  let fid_expr = match var_type_of(func, f_var_name.0) {
                    Some(Type::Future(inner)) => {
                      let _ = inner; // suppress unused warning in generation
                      format!("{}.0.clone()", f_ident)
                    }
                    _ => format!("{}.clone()", f_ident),
                  };
                  vparts.push(format!(
                    "SetPrimitiveValue::Future {{ id: {}, value: Value::{}({}) }}",
                    fid_expr, vname, local_ident
                  ));
                }
              }
            }
            out.push_str("      StepResult::SetValues { values: vec![");
            out.push_str(&vparts.join(", "));
            out.push_str("], next: State::");
            out.push_str(&next_v);
            out.push_str(" }\n");
          }
          Step::Select { arms } => {
            // Build structured Select arms supporting Future and Queue
            let mut arm_parts: Vec<String> = Vec::new();
            for arm in arms {
              match arm {
                AwaitSpec::Queue { queue_name, message_var, next } => {
                  let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
                  let q_ident = camel_ident(queue_name.0);
                  arm_parts.push(format!(
                    "SelectArm::Queue {{ queue_name: {}.clone(), bind: \"{}\".to_string(), next: State::{} }}",
                    q_ident, message_var.0, next_v
                  ));
                }
                AwaitSpec::Future { bind, ret_to, future_id } => {
                  let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &ret_to.0]);
                  match bind {
                    Some(name) => arm_parts.push(format!(
                      "SelectArm::Future {{ future_id: FutureLabel::new(\"{}\"), bind: Some(\"{}\".to_string()), next: State::{} }}",
                      future_id.0, name.0, next_v
                    )),
                    None => arm_parts.push(format!(
                      "SelectArm::Future {{ future_id: FutureLabel::new(\"{}\"), bind: None, next: State::{} }}",
                      future_id.0, next_v
                    )),
                  }
                }
              }
            }
            out.push_str("      StepResult::Select(vec![");
            out.push_str(&arm_parts.join(", "));
            out.push_str("])\n");
          }
          Step::SendToFiber { fiber, message, args, next, future_id } => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            if let Some(callee) = find_func(ir, fiber.as_str(), message.as_str()) {
              let mut arg_elems: Vec<String> = Vec::new();
              for (aname, aexpr) in args.iter() {
                if let Some(param) = callee.in_vars.iter().find(|p| p.0 == aname.as_str()) {
                  let vname = type_variant_name(&param.1);
                  let mut expr_code = render_expr_code(aexpr, func);
                  if let Expr::Var(var_name) = aexpr {
                    if let Some(src_ty) = var_type_of(func, var_name.0) {
                      if !is_copy_type(src_ty) {
                        expr_code = format!("({}).clone()", expr_code);
                      }
                    }
                  }
                  arg_elems.push(format!("Value::{}({})", vname, expr_code));
                }
              }
              out.push_str("      StepResult::SendToFiber { f_type: FiberType::new(\"");
              out.push_str(fiber);
              out.push_str("\"), func: \"");
              out.push_str(message);
              out.push_str("\".to_string(), args: vec![");
              out.push_str(&arg_elems.join(", "));
              out.push_str("], next: State::");
              out.push_str(&next_v);
              out.push_str(", future_id: FutureLabel::new(\"");
              out.push_str(&future_id.0);
              out.push_str("\") }\n");
            } else {
              out.push_str(&format!("      StepResult::GoTo(State::{})\n", next_v));
            }
          }
          Step::Await(spec) => {
            // Pause current task until a future resolves; push continuation state when resuming.
            match spec {
              AwaitSpecOld::Future { bind, ret_to, future_id } => {
                let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &ret_to.0]);
                match bind {
                  Some(name) => out.push_str(&format!(
                    "      StepResult::AwaitOld(FutureLabel::new(\"{}\"), Some(\"{}\".to_string()), State::{})\n",
                    future_id.0, name.0, next_v
                  )),
                  None => out.push_str(&format!(
                    "      StepResult::AwaitOld(FutureLabel::new(\"{}\"), None, State::{})\n",
                    future_id.0, next_v
                  )),
                }
              }
              AwaitSpecOld::Queue { .. } => {
                out.push_str("      StepResult::Todo(\"await-queue-in-await\".to_string())\n");
              }
            }
          }
          Step::Call { target, args, ret_to, bind } => {
            out.push_str(&render_call_step(ir, fiber_name.0.as_str(), func_name, func, target, args, ret_to, bind));
          }
          Step::Return { value } => {
            let code = render_ret_value(value, &func.out, func);
            out.push_str(&format!("      StepResult::Return(Value::{}({}))\n", type_variant_name(&func.out), code));
          }
          Step::ReturnVoid => out.push_str("      StepResult::ReturnVoid\n"),
          Step::If { cond, then_, else_, .. } => {
            let then_v = variant_name(&[fiber_name.0.as_str(), func_name, &then_.0]);
            let else_v = variant_name(&[fiber_name.0.as_str(), func_name, &else_.0]);
            let cond_code = render_expr_code(&cond, func);
            out.push_str(&format!(
              "      if {} {{ StepResult::GoTo(State::{}) }} else {{ StepResult::GoTo(State::{}) }}\n",
              cond_code, then_v, else_v
            ));
          }
          Step::Let { local, expr, next } => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            let lty = var_type_of(func, local).expect("unknown local var in Let");
            let vname = type_variant_name(lty);
            let expr_code = render_expr_code(&expr, func);
            let pos_expr = if let Some(li) = func.locals.iter().position(|l| l.0 == local.as_str()) {
              format!("{}", func.in_vars.len() + li)
            } else {
              "0".to_string()
            };
            out.push_str("      StepResult::Next(vec![\n");
            out.push_str(&format!(
              "        StackEntry::FrameAssign(vec![( {}, Value::{}({}) )]),\n",
              pos_expr, vname, expr_code
            ));
            out.push_str(&format!("        StackEntry::State(State::{}),\n", next_v));
            out.push_str("      ])\n");
          }
          Step::RustBlock { binds, next, code: rcode } => {
            let next_v = variant_name(&[fiber_name.0.as_str(), func_name, &next.0]);
            // Types by bind order
            let mut bind_types: Vec<&Type> = Vec::new();
            for b in binds {
              bind_types.push(var_type_of(func, b.0).expect("bind var type"));
            }
            if bind_types.len() == 1 {
              // Optimization: if next step is Return of the bound var, just return it
              let direct_return = func
                .steps
                .iter()
                .find(|(sid, _)| sid.0 == next.0)
                .and_then(|(_, st)| if let Step::Return { value } = st { Some(value) } else { None })
                .and_then(|rv| if let RetValue::Var(vn) = rv { Some(vn) } else { None })
                .map(|vn| vn == &binds[0])
                .unwrap_or(false);
              if direct_return {
                let ty_name = type_variant_name(bind_types[0]);
                out.push_str("      { let out = {\n");
                out.push_str(rcode);
                out.push_str("\n      }; ");
                out.push_str(&format!("StepResult::Return(Value::{}(out)) }}\n", ty_name));
              } else {
                // Single bind: assign directly into the current frame using offset
                let ty_name = type_variant_name(bind_types[0]);
                let bname = binds.get(0).unwrap();
                let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == bname.0) {
                  format!("{}", pi)
                } else if let Some(li) = func.locals.iter().position(|l| l.0 == bname.0) {
                  format!("{}", func.in_vars.len() + li)
                } else {
                  "0".to_string()
                };
                out.push_str("      { let out = {\n");
                out.push_str(rcode);
                out.push_str("\n      }; StepResult::Next(vec![\n");
                out.push_str(&format!(
                  "          StackEntry::FrameAssign(vec![( {}, Value::{}(out) )]),\n",
                  pos_expr, ty_name
                ));
                out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
              }
            } else {
              out.push_str("      { let out = {\n");
              out.push_str(rcode);
              out.push_str("\n      };\n");
              let tuple_names: Vec<String> = (0..bind_types.len()).map(|i| format!("o{}", i)).collect();
              out.push_str(&format!(
                "        let ({}) = out;\n        StepResult::Next(vec![\n",
                tuple_names.join(", ")
              ));
              out.push_str("          StackEntry::FrameAssign(vec![\n");
              for (i, b) in binds.iter().enumerate() {
                let ty_name = type_variant_name(bind_types[i]);
                let pos_expr = if let Some(pi) = func.in_vars.iter().position(|p| p.0 == b.0) {
                  format!("{}", pi)
                } else if let Some(li) = func.locals.iter().position(|l| l.0 == b.0) {
                  format!("{}", func.in_vars.len() + li)
                } else {
                  "0".to_string()
                };
                out.push_str(&format!("            ( {}, Value::{}({}) ),\n", pos_expr, ty_name, tuple_names[i]));
              }
              out.push_str("          ]),\n");
              out.push_str(&format!("          StackEntry::State(State::{}),\n        ]) }}\n", next_v));
            }
          }
        }
        out.push_str("    }\n");
      }
    }
  }

  out.push_str("    _ => StepResult::Todo(\"uncovered-state\".to_string()),\n  }\n}\n");
  out
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::collections::HashMap;

  #[test]
  fn generates_types() {
    let ir = IR {
      types: vec![Type::Struct(
        "User".into(),
        vec![StructField { name: "id".into(), ty: Type::String }, StructField { name: "age".into(), ty: Type::UInt64 }],
        String::new(),
      )],
      fibers: HashMap::from([
        (
          FiberType::new("userManager"),
          Fiber {
            fibers_limit: 1,
            heap: HashMap::from([(
              "users".into(),
              Type::Map(Box::new(Type::String), Box::new(Type::Custom("User".into()))),
            )]),
            in_messages: vec![MessageSpec("GetUser", vec![("key", Type::String)])],
            init_vars: vec![],
            funcs: HashMap::from([(
              "get".into(),
              Func {
                in_vars: vec![InVar("key", Type::String)],
                out: Type::Option(Box::new(Type::Custom("User".into()))),
                locals: vec![],
                steps: vec![(StepId::new("entry"), Step::ReturnVoid)],
              },
            )]),
          },
        ),
        (
          FiberType::new("global"),
          Fiber {
            fibers_limit: 1,
            heap: HashMap::new(),
            in_messages: vec![],
            init_vars: vec![],
            funcs: HashMap::new(),
          },
        ),
      ]),
    };

    let code = generate_rust_types(&ir);
    // Spot-check a few important bits are present.
    assert!(code.contains("pub struct User"));
    assert!(code.contains("pub struct UserManagerGetUserMsg"));
    assert!(code.contains("pub struct Heap"));
    assert!(code.contains("pub enum State"));
    assert!(code.contains("UserManagerGetEntry"));
    assert!(code.contains("pub enum Value"));
    // With compact-by-type Value enum, we expect used types only
    assert!(code.contains("String(String)"));
    assert!(code.contains("OptionUser(Option<User>)"));
  }
}
